{"version":3,"file":"angular-fire-app.js","sources":["../../../src/app/app.ts","../../../src/app/app.module.ts","../../../src/app/firebase.ts","../../../src/app/angular-fire-app.ts"],"sourcesContent":["import { FirebaseApp as IFirebaseApp, getApps } from 'firebase/app';\nimport { from, timer } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\n\n// Need to turn the FirebaseApp interface exported by firebase/app into a class\n// as types don't work in Angular DI. We want developers to be able to inject FirebaseApp like so\n//   constructor(app: FirebaseApp)\n// the cleanest way to achieve this that I found is to export a new interface and class\n// the interface just extends the interface you want to turn into the class. This informs tyepscript\n// that the class has all the same methods/properties as the interface you want to extend without\n// breaking if Firebase adds/removes APIs in future releases. This was a big problem for @angular/fire\n// back when we constructed our own class. Then in the \"new class\" we just return the FirebaseApp in the\n// constructor, this also has the added benefit of Firebase methods taking our DI class without\n// casting. E.g,\n//   constructor(private app: FirebaseApp) { }\n//   ngOnDestroy() { deleteApp(this.app); }\n//\n// tslint:disable-next-line:no-empty-interface\nexport interface FirebaseApp extends IFirebaseApp {}\n\nexport class FirebaseApp {\n  constructor(app: IFirebaseApp) {\n    return app;\n  }\n}\n\nexport interface FirebaseApps extends Array<IFirebaseApp> {}\n\nexport class FirebaseApps {\n  constructor() {\n    return getApps();\n  }\n}\n\nexport const firebaseApp$ = timer(0, 300).pipe(\n  concatMap(() => from(getApps())),\n  distinct(),\n);\n","import {\n  Inject,\n  InjectionToken,\n  Injector,\n  ModuleWithProviders,\n  NgModule,\n  NgZone,\n  Optional,\n  PLATFORM_ID,\n  VERSION as NG_VERSION,\n} from '@angular/core';\nimport { FirebaseApp as IFirebaseApp, getApp, registerVersion } from 'firebase/app';\n\nimport { FirebaseApp, FirebaseApps } from './app';\nimport { VERSION, ɵAngularFireSchedulers } from '@angular/fire';\n\nexport function defaultFirebaseAppFactory(provided: FirebaseApp[]|undefined) {\n  // Use the provided app, if there is only one, otherwise fetch the default app\n  if (provided && provided.length === 1) { return provided[0]; }\n  return new FirebaseApp(getApp());\n}\n\n// With FIREBASE_APPS I wanted to capture the default app instance, if it is initialized by\n// the reserved URL; ɵPROVIDED_FIREBASE_APPS is not for public consumption and serves to ensure that all\n// provideFirebaseApp(...) calls are satisfied before FirebaseApp$ or FirebaseApp is resolved\nexport const PROVIDED_FIREBASE_APPS = new InjectionToken<Array<FirebaseApp>>('angularfire2._apps');\n\n// Injecting FirebaseApp will now only inject the default Firebase App\n// this allows allows beginners to import /__/firebase/init.js to auto initialize Firebase App\n// from the reserved URL.\nconst DEFAULT_FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: defaultFirebaseAppFactory,\n  deps: [\n    [new Optional(), PROVIDED_FIREBASE_APPS ],\n  ],\n};\n\nconst FIREBASE_APPS_PROVIDER = {\n  provide: FirebaseApps,\n  deps: [\n    [new Optional(), PROVIDED_FIREBASE_APPS ],\n  ],\n};\n\nexport function firebaseAppFactory(fn: (injector: Injector) => IFirebaseApp) {\n  return (zone: NgZone, injector: Injector) => {\n    const app = zone.runOutsideAngular(() => fn(injector));\n    return new FirebaseApp(app);\n  };\n}\n\n@NgModule({\n  providers: [\n    DEFAULT_FIREBASE_APP_PROVIDER,\n    FIREBASE_APPS_PROVIDER,\n  ]\n})\nexport class FirebaseAppModule {\n  // tslint:disable-next-line:ban-types\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    registerVersion('angularfire', VERSION.full, 'core');\n    registerVersion('angularfire', VERSION.full, 'app');\n    registerVersion('angular', NG_VERSION.full, platformId.toString());\n  }\n}\n\n// Calling initializeApp({ ... }, 'name') multiple times will add more FirebaseApps into the FIREBASE_APPS\n// injection scope. This allows developers to more easily work with multiple Firebase Applications. Downside\n// is that DI for app name and options doesn't really make sense anymore.\nexport function provideFirebaseApp(fn: (injector: Injector) => IFirebaseApp, ...deps: any[]): ModuleWithProviders<FirebaseAppModule> {\n  return {\n    ngModule: FirebaseAppModule,\n    providers: [{\n      provide: PROVIDED_FIREBASE_APPS,\n      useFactory: firebaseAppFactory(fn),\n      multi: true,\n      deps: [\n        NgZone,\n        Injector,\n        ɵAngularFireSchedulers,\n        ...deps,\n      ],\n    }],\n  };\n}\n","// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nexport * from 'firebase/app';\nimport { ɵzoneWrap } from '@angular/fire';\nimport {\n  deleteApp as _deleteApp,\n  getApp as _getApp,\n  getApps as _getApps,\n  initializeApp as _initializeApp,\n  onLog as _onLog,\n  registerVersion as _registerVersion,\n  setLogLevel as _setLogLevel\n} from 'firebase/app';\n\nexport const deleteApp = ɵzoneWrap(_deleteApp, true);\nexport const getApp = ɵzoneWrap(_getApp, true);\nexport const getApps = ɵzoneWrap(_getApps, true);\nexport const initializeApp = ɵzoneWrap(_initializeApp, true);\nexport const onLog = ɵzoneWrap(_onLog, true);\nexport const registerVersion = ɵzoneWrap(_registerVersion, true);\nexport const setLogLevel = ɵzoneWrap(_setLogLevel, true);\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["getApps","getApp","registerVersion","NG_VERSION","_deleteApp","_getApp","_getApps","_initializeApp","_onLog","_registerVersion","_setLogLevel"],"mappings":"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"}