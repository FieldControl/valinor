import { __awaiter } from 'tslib';
import * as i0 from '@angular/core';
import { InjectionToken, PLATFORM_ID, Injectable, Optional, Inject, NgModule } from '@angular/core';
import { of, EMPTY } from 'rxjs';
import { isPlatformBrowser, isPlatformServer } from '@angular/common';
import { observeOn, switchMap, map, shareReplay } from 'rxjs/operators';
import * as i2 from '@angular/fire';
import { VERSION } from '@angular/fire';
import * as i1 from '@angular/fire/compat';
import { ɵcacheInstance, ɵlazySDKProxy, ɵapplyMixins } from '@angular/fire/compat';
import { isSupported } from 'firebase/analytics';
import * as i2$2 from '@angular/router';
import * as i3 from '@angular/platform-browser';
import * as i2$1 from '@angular/fire/compat/auth';
import firebase from 'firebase/compat/app';
import { ɵscreenViewEvent } from '@angular/fire/analytics';

// DO NOT MODIFY, this file is autogenerated by tools/build.ts
// Export a null object with the same keys as firebase/compat/analytics, so Proxy can work with proxy-polyfill in Internet Explorer
const proxyPolyfillCompat = {
    app: null,
    logEvent: null,
    setCurrentScreen: null,
    setUserId: null,
    setUserProperties: null,
    setAnalyticsCollectionEnabled: null,
};

const COLLECTION_ENABLED = new InjectionToken('angularfire2.analytics.analyticsCollectionEnabled');
const APP_VERSION = new InjectionToken('angularfire2.analytics.appVersion');
const APP_NAME = new InjectionToken('angularfire2.analytics.appName');
const DEBUG_MODE = new InjectionToken('angularfire2.analytics.debugMode');
const CONFIG = new InjectionToken('angularfire2.analytics.config');
const APP_NAME_KEY = 'app_name';
const APP_VERSION_KEY = 'app_version';
const DEBUG_MODE_KEY = 'debug_mode';
const GTAG_CONFIG_COMMAND = 'config';
const GTAG_FUNCTION_NAME = 'gtag'; // TODO rename these
const DATA_LAYER_NAME = 'dataLayer';
const SEND_TO_KEY = 'send_to';
class AngularFireAnalytics {
    constructor(app, analyticsCollectionEnabled, providedAppVersion, providedAppName, debugModeEnabled, providedConfig, 
    // tslint:disable-next-line:ban-types
    platformId, zone, schedulers) {
        this.analyticsInitialized = new Promise(() => { });
        if (isPlatformBrowser(platformId)) {
            window[DATA_LAYER_NAME] = window[DATA_LAYER_NAME] || [];
            // It turns out we can't rely on the measurementId in the Firebase config JSON
            // this identifier is not stable. firebase/analytics does a call to get a fresh value
            // falling back on the one in the config. Rather than do that ourselves we should listen
            // on our gtag function for a analytics config command
            // e.g, ['config', measurementId, { origin: 'firebase', firebase_id }]
            const parseMeasurementId = (...args) => {
                if (args[0] === 'config' && args[2].origin === 'firebase') {
                    this.measurementId = args[1];
                    return true;
                }
                else {
                    return false;
                }
            };
            const patchGtag = (fn) => {
                window[GTAG_FUNCTION_NAME] = (...args) => {
                    if (fn) {
                        fn(...args);
                    }
                    // Inject app_name and app_version into events
                    // TODO(jamesdaniels): I'm doing this as documented but it's still not
                    //   showing up in the console. Investigate. Guessing it's just part of the
                    //   whole GA4 transition mess.
                    if (args[0] === 'event' && args[2][SEND_TO_KEY] === this.measurementId) {
                        if (providedAppName) {
                            args[2][APP_NAME_KEY] = providedAppName;
                        }
                        if (providedAppVersion) {
                            args[2][APP_VERSION_KEY] = providedAppVersion;
                        }
                    }
                    if (debugModeEnabled && typeof console !== 'undefined') {
                        // tslint:disable-next-line:no-console
                        console.info(...args);
                    }
                    /**
                     * According to the gtag documentation, this function that defines a custom data layer cannot be
                     * an arrow function because 'arguments' is not an array. It is actually an object that behaves
                     * like an array and contains more information then just indexes. Transforming this into arrow function
                     * caused issue #2505 where analytics no longer sent any data.
                     */
                    // tslint:disable-next-line: only-arrow-functions
                    (function (..._args) {
                        window[DATA_LAYER_NAME].push(arguments);
                    })(...args);
                };
            };
            // Unclear if we still need to but I was running into config/events I passed
            // to gtag before ['js' timestamp] weren't getting parsed, so let's make a promise
            // that resolves when firebase/analytics has configured gtag.js that we wait on
            // before sending anything
            const firebaseAnalyticsAlreadyInitialized = window[DATA_LAYER_NAME].some(parseMeasurementId);
            if (firebaseAnalyticsAlreadyInitialized) {
                this.analyticsInitialized = Promise.resolve();
                patchGtag();
            }
            else {
                this.analyticsInitialized = new Promise(resolve => {
                    patchGtag((...args) => {
                        if (parseMeasurementId(...args)) {
                            resolve();
                        }
                    });
                });
            }
            if (providedConfig) {
                this.updateConfig(providedConfig);
            }
            if (debugModeEnabled) {
                this.updateConfig({ [DEBUG_MODE_KEY]: 1 });
            }
        }
        else {
            this.analyticsInitialized = Promise.resolve();
        }
        const analytics = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(isSupported), switchMap(supported => supported ? zone.runOutsideAngular(() => import('firebase/compat/analytics')) : EMPTY), map(() => {
            return ɵcacheInstance(`analytics`, 'AngularFireAnalytics', app.name, () => {
                const analytics = app.analytics();
                if (analyticsCollectionEnabled === false) {
                    analytics.setAnalyticsCollectionEnabled(false);
                }
                return analytics;
            }, [app, analyticsCollectionEnabled, providedConfig, debugModeEnabled]);
        }), shareReplay({ bufferSize: 1, refCount: false }));
        return ɵlazySDKProxy(this, analytics, zone);
    }
    updateConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.analyticsInitialized;
            window[GTAG_FUNCTION_NAME](GTAG_CONFIG_COMMAND, this.measurementId, Object.assign(Object.assign({}, config), { update: true }));
        });
    }
}
AngularFireAnalytics.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalytics, deps: [{ token: i1.FirebaseApp }, { token: COLLECTION_ENABLED, optional: true }, { token: APP_VERSION, optional: true }, { token: APP_NAME, optional: true }, { token: DEBUG_MODE, optional: true }, { token: CONFIG, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i2.ɵAngularFireSchedulers }], target: i0.ɵɵFactoryTarget.Injectable });
AngularFireAnalytics.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalytics, providedIn: 'any' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalytics, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'any'
                }]
        }], ctorParameters: function () { return [{ type: i1.FirebaseApp }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [COLLECTION_ENABLED]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [APP_VERSION]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [APP_NAME]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DEBUG_MODE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CONFIG]
                }] }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i0.NgZone }, { type: i2.ɵAngularFireSchedulers }]; } });
ɵapplyMixins(AngularFireAnalytics, [proxyPolyfillCompat]);

class UserTrackingService {
    // TODO a user properties injector
    constructor(analytics, 
    // tslint:disable-next-line:ban-types
    platformId, auth, zone) {
        this.disposables = [];
        firebase.registerVersion('angularfire', VERSION.full, 'compat-user-tracking');
        if (!isPlatformServer(platformId)) {
            let resolveInitialized;
            this.initialized = zone.runOutsideAngular(() => new Promise(resolve => resolveInitialized = resolve));
            this.disposables = [
                auth.authState.subscribe(user => {
                    analytics.setUserId(user === null || user === void 0 ? void 0 : user.uid);
                    resolveInitialized();
                }),
                auth.credential.subscribe(credential => {
                    if (credential) {
                        const method = credential.user.isAnonymous ? 'anonymous' : credential.additionalUserInfo.providerId;
                        if (credential.additionalUserInfo.isNewUser) {
                            analytics.logEvent('sign_up', { method });
                        }
                        analytics.logEvent('login', { method });
                    }
                })
            ];
        }
        else {
            this.initialized = Promise.resolve();
        }
    }
    ngOnDestroy() {
        this.disposables.forEach(it => it.unsubscribe());
    }
}
UserTrackingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UserTrackingService, deps: [{ token: AngularFireAnalytics }, { token: PLATFORM_ID }, { token: i2$1.AngularFireAuth }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
UserTrackingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UserTrackingService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: UserTrackingService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AngularFireAnalytics }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i2$1.AngularFireAuth }, { type: i0.NgZone }]; } });

const SCREEN_VIEW_EVENT = 'screen_view';
class ScreenTrackingService {
    constructor(analytics, router, title, componentFactoryResolver, zone, userTrackingService) {
        firebase.registerVersion('angularfire', VERSION.full, 'compat-screen-tracking');
        if (!router || !analytics) {
            return this;
        }
        zone.runOutsideAngular(() => {
            this.disposable = ɵscreenViewEvent(router, title, componentFactoryResolver).pipe(switchMap((params) => __awaiter(this, void 0, void 0, function* () {
                if (userTrackingService) {
                    yield userTrackingService.initialized;
                }
                return yield analytics.logEvent(SCREEN_VIEW_EVENT, params);
            }))).subscribe();
        });
    }
    ngOnDestroy() {
        if (this.disposable) {
            this.disposable.unsubscribe();
        }
    }
}
ScreenTrackingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ScreenTrackingService, deps: [{ token: AngularFireAnalytics }, { token: i2$2.Router, optional: true }, { token: i3.Title, optional: true }, { token: i0.ComponentFactoryResolver }, { token: i0.NgZone }, { token: UserTrackingService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
ScreenTrackingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ScreenTrackingService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ScreenTrackingService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AngularFireAnalytics }, { type: i2$2.Router, decorators: [{
                    type: Optional
                }] }, { type: i3.Title, decorators: [{
                    type: Optional
                }] }, { type: i0.ComponentFactoryResolver }, { type: i0.NgZone }, { type: UserTrackingService, decorators: [{
                    type: Optional
                }] }]; } });

class AngularFireAnalyticsModule {
    constructor(analytics, screenTracking, userTracking) {
        firebase.registerVersion('angularfire', VERSION.full, 'analytics-compat');
        // calling anything on analytics will eagerly load the SDK
        // tslint:disable-next-line:no-unused-expression
        analytics.app.then(() => { });
    }
}
AngularFireAnalyticsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalyticsModule, deps: [{ token: AngularFireAnalytics }, { token: ScreenTrackingService, optional: true }, { token: UserTrackingService, optional: true }], target: i0.ɵɵFactoryTarget.NgModule });
AngularFireAnalyticsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalyticsModule });
AngularFireAnalyticsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalyticsModule, providers: [AngularFireAnalytics] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAnalyticsModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [AngularFireAnalytics]
                }]
        }], ctorParameters: function () { return [{ type: AngularFireAnalytics }, { type: ScreenTrackingService, decorators: [{
                    type: Optional
                }] }, { type: UserTrackingService, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { APP_NAME, APP_VERSION, AngularFireAnalytics, AngularFireAnalyticsModule, COLLECTION_ENABLED, CONFIG, DEBUG_MODE, ScreenTrackingService, UserTrackingService };
//# sourceMappingURL=angular-fire-compat-analytics.js.map
