{"version":3,"file":"ast.js","sourceRoot":"","sources":["../../../schematics/utils/ast.ts"],"names":[],"mappings":"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","sourcesContent":["import {Tree, SchematicsException} from '@angular-devkit/schematics';\nimport {InsertChange, Change} from '@schematics/angular/utility/change';\nimport {getAppModulePath} from '@schematics/angular/utility/ng-ast-utils';\nimport * as ts from 'typescript';\n\nimport {getMainPath, getTypeScriptSourceFile} from '.';\n\n/**\n * Import and add module to the root module.\n * @param host {Tree} The source tree.\n * @param importedModuleName {String} The name of the imported module.\n * @param importedModulePath {String} The location of the imported module.\n * @param projectName {String} The name of the project.\n */\nexport function addModuleImportToRootModule(\n  host: Tree,\n  importedModuleName: string,\n  importedModulePath: string,\n  projectName?: string,\n) {\n  const mainPath = getMainPath(host, projectName);\n  const appModulePath = getAppModulePath(host, mainPath);\n\n  addModuleImportToModule(\n    host,\n    appModulePath,\n    importedModuleName,\n    importedModulePath,\n  );\n}\n\n/**\n * Import and add module to specific module path.\n * @param host {Tree} The source tree.\n * @param moduleToImportIn {String} The location of the module to import in.\n * @param importedModuleName {String} The name of the imported module.\n * @param importedModulePath {String} The location of the imported module.\n */\nfunction addModuleImportToModule(\n  host: Tree,\n  moduleToImportIn: string,\n  importedModuleName: string,\n  importedModulePath: string,\n) {\n  const moduleSource = getTypeScriptSourceFile(host, moduleToImportIn);\n\n  if (!moduleSource) {\n    throw new SchematicsException(`Module not found: ${moduleToImportIn}`);\n  }\n\n  const changes = addImportToModule(\n    moduleSource,\n    importedModulePath,\n    importedModuleName,\n  );\n  const recorder = host.beginUpdate(moduleToImportIn);\n\n  const inserted = insertImport(\n    moduleSource,\n    moduleToImportIn,\n    importedModuleName,\n    importedModulePath,\n  );\n\n  if (inserted && inserted instanceof InsertChange) {\n    recorder.insertLeft(inserted.pos, inserted.toAdd);\n  }\n\n  changes\n    .filter((change: Change) => change instanceof InsertChange)\n    .forEach((change: InsertChange) =>\n      recorder.insertLeft(change.pos, change.toAdd),\n    );\n\n  host.commitUpdate(recorder);\n}\n\nfunction addImportToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  symbolName: string,\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'imports',\n    symbolName,\n  );\n}\n\nfunction _addSymbolToNgModuleMetadata(\n  source: ts.SourceFile,\n  ngModulePath: string,\n  metadataField: string,\n  expression: string,\n): Change[] {\n  const nodes = getDecoratorMetadata(source, 'NgModule', '@angular/core');\n  let node: any = nodes[0];\n\n  // Find the decorator declaration.\n  if (!node) {\n    return [];\n  }\n  // Get all the children property assignment of object literals.\n  const matchingProperties: ts.ObjectLiteralElement[] = (\n    node as ts.ObjectLiteralExpression\n  ).properties\n    .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)\n    // Filter out every fields that's not \"metadataField\". Also handles string literals\n    // (but not expressions).\n    .filter((prop: ts.PropertyAssignment) => {\n      const name = prop.name;\n      switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n          return (name as ts.Identifier).getText(source) == metadataField;\n        case ts.SyntaxKind.StringLiteral:\n          return (name as ts.StringLiteral).text == metadataField;\n      }\n\n      return false;\n    });\n\n  // Get the last node of the array literal.\n  if (!matchingProperties) {\n    return [];\n  }\n  if (matchingProperties.length == 0) {\n    // We haven't found the field in the metadata declaration. Insert a new field.\n    const expr = node as ts.ObjectLiteralExpression;\n    let position: number;\n    let toInsert: string;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${expression}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${\n          text.match(/^\\r?\\n\\s+/)[0]\n        }${metadataField}: [${expression}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${expression}]`;\n      }\n    }\n    const newMetadataProperty = new InsertChange(\n      ngModulePath,\n      position,\n      toInsert,\n    );\n    return [newMetadataProperty];\n  }\n\n  const assignment = matchingProperties[0] as ts.PropertyAssignment;\n\n  // If it's not an array, nothing we can do really.\n  if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n    return [];\n  }\n\n  const arrLiteral = assignment.initializer as ts.ArrayLiteralExpression;\n  if (arrLiteral.elements.length == 0) {\n    // Forward the property.\n    node = arrLiteral;\n  } else {\n    node = arrLiteral.elements;\n  }\n\n  if (!node) {\n    console.log(\n      'No app module found. Please add your new class to your component.',\n    );\n\n    return [];\n  }\n\n  const isArray = Array.isArray(node);\n  if (isArray) {\n    const nodeArray = node as {} as Array<ts.Node>;\n    const symbolsArray = nodeArray.map((node) => node.getText());\n    if (symbolsArray.includes(expression)) {\n      return [];\n    }\n\n    node = node[node.length - 1];\n  }\n\n  let toInsert: string;\n  let position = node.getEnd();\n  if (!isArray && node.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n    // We haven't found the field in the metadata declaration. Insert a new\n    // field.\n    const expr = node as ts.ObjectLiteralExpression;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${expression}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${\n          text.match(/^\\r?\\n\\s+/)[0]\n        }${metadataField}: [${expression}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${expression}]`;\n      }\n    }\n  } else if (!isArray && node.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n    // We found the field but it's empty. Insert it just before the `]`.\n    position--;\n    toInsert = `${expression}`;\n  } else {\n    // Get the indentation of the last element, if any.\n    const text = node.getFullText(source);\n    if (text.match(/^\\r?\\n/)) {\n      toInsert = `,${text.match(/^\\r?\\n(\\r?)\\s+/)[0]}${expression}`;\n    } else {\n      toInsert = `, ${expression}`;\n    }\n  }\n  const insert = new InsertChange(ngModulePath, position, toInsert);\n  return [insert];\n}\n\nfunction getDecoratorMetadata(\n  source: ts.SourceFile,\n  identifier: string,\n  module: string,\n): ts.Node[] {\n  const angularImports: {[name: string]: string} = findNodes(\n    source,\n    ts.SyntaxKind.ImportDeclaration,\n  )\n    .map((node: ts.ImportDeclaration) => _angularImportsFromNode(node, source))\n    .reduce(\n      (acc: {[name: string]: string}, current: {[name: string]: string}) => {\n        for (const key of Object.keys(current)) {\n          acc[key] = current[key];\n        }\n\n        return acc;\n      },\n      {},\n    );\n\n  return getSourceNodes(source)\n    .filter((node) => {\n      return (\n        node.kind == ts.SyntaxKind.Decorator &&\n        (node as ts.Decorator).expression.kind == ts.SyntaxKind.CallExpression\n      );\n    })\n    .map((node) => (node as ts.Decorator).expression as ts.CallExpression)\n    .filter((expr) => {\n      if (expr.expression.kind == ts.SyntaxKind.Identifier) {\n        const id = expr.expression as ts.Identifier;\n\n        return (\n          id.getFullText(source) == identifier &&\n          angularImports[id.getFullText(source)] === module\n        );\n      } else if (\n        expr.expression.kind == ts.SyntaxKind.PropertyAccessExpression\n      ) {\n        // This covers foo.NgModule when importing * as foo.\n        const paExpr = expr.expression as ts.PropertyAccessExpression;\n        // If the left expression is not an identifier, just give up at that point.\n        if (paExpr.expression.kind !== ts.SyntaxKind.Identifier) {\n          return false;\n        }\n\n        const id = paExpr.name.text;\n        const moduleId = (paExpr.expression as ts.Identifier).getText(source);\n\n        return id === identifier && angularImports[moduleId + '.'] === module;\n      }\n\n      return false;\n    })\n    .filter(\n      (expr) =>\n        expr.arguments[0] &&\n        expr.arguments[0].kind == ts.SyntaxKind.ObjectLiteralExpression,\n    )\n    .map((expr) => expr.arguments[0] as ts.ObjectLiteralExpression);\n}\n\nfunction getSourceNodes(sourceFile: ts.SourceFile): ts.Node[] {\n  const nodes: ts.Node[] = [sourceFile];\n  const result = [];\n\n  while (nodes.length > 0) {\n    const node = nodes.shift();\n\n    if (node) {\n      result.push(node);\n      if (node.getChildCount(sourceFile) >= 0) {\n        nodes.unshift(...node.getChildren());\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction findNodes(\n  node: ts.Node,\n  kind: ts.SyntaxKind | ts.SyntaxKind[],\n  max = Infinity,\n): ts.Node[] {\n  if (!node || max == 0) {\n    return [];\n  }\n\n  const arr: ts.Node[] = [];\n  const hasMatch = Array.isArray(kind)\n    ? kind.includes(node.kind)\n    : node.kind === kind;\n  if (hasMatch) {\n    arr.push(node);\n    max--;\n  }\n  if (max > 0) {\n    for (const child of node.getChildren()) {\n      findNodes(child, kind, max).forEach((node) => {\n        if (max > 0) {\n          arr.push(node);\n        }\n        max--;\n      });\n\n      if (max <= 0) {\n        break;\n      }\n    }\n  }\n\n  return arr;\n}\n\nfunction _angularImportsFromNode(\n  node: ts.ImportDeclaration,\n  _sourceFile: ts.SourceFile,\n): {[name: string]: string} {\n  const ms = node.moduleSpecifier;\n  let modulePath: string;\n  switch (ms.kind) {\n    case ts.SyntaxKind.StringLiteral:\n      modulePath = (ms as ts.StringLiteral).text;\n      break;\n    default:\n      return {};\n  }\n\n  if (!modulePath.startsWith('@angular/')) {\n    return {};\n  }\n\n  if (node.importClause) {\n    if (node.importClause.name) {\n      // This is of the form `import Name from 'path'`. Ignore.\n      return {};\n    } else if (node.importClause.namedBindings) {\n      const nb = node.importClause.namedBindings;\n      if (nb.kind == ts.SyntaxKind.NamespaceImport) {\n        // This is of the form `import * as name from 'path'`. Return `name.`.\n        return {\n          [(nb as ts.NamespaceImport).name.text + '.']: modulePath,\n        };\n      } else {\n        // This is of the form `import {a,b,c} from 'path'`\n        const namedImports = nb as ts.NamedImports;\n\n        return namedImports.elements\n          .map((is: ts.ImportSpecifier) =>\n            is.propertyName ? is.propertyName.text : is.name.text,\n          )\n          .reduce((acc: {[name: string]: string}, curr: string) => {\n            acc[curr] = modulePath;\n\n            return acc;\n          }, {});\n      }\n    }\n\n    return {};\n  } else {\n    // This is of the form `import 'path';`. Nothing to do.\n    return {};\n  }\n}\n\nexport function insertImport(\n  source: ts.SourceFile,\n  fileToEdit: string,\n  symbolName: string,\n  fileName: string,\n  isDefault = false,\n) {\n  const rootNode = source;\n  const allImports = findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);\n\n  // get nodes that map to import statements from the file fileName\n  const relevantImports = allImports.filter((node) => {\n    // StringLiteral of the ImportDeclaration is the import file (fileName in this case).\n    const importFiles = node\n      .getChildren()\n      .filter((child) => child.kind === ts.SyntaxKind.StringLiteral)\n      .map((n) => (n as ts.StringLiteral).text);\n\n    return importFiles.filter((file) => file === fileName).length === 1;\n  });\n\n  if (relevantImports.length > 0) {\n    let importsAsterisk = false;\n    // imports from import file\n    const imports: ts.Node[] = [];\n    relevantImports.forEach((n) => {\n      Array.prototype.push.apply(\n        imports,\n        findNodes(n, ts.SyntaxKind.Identifier),\n      );\n      if (findNodes(n, ts.SyntaxKind.AsteriskToken).length > 0) {\n        importsAsterisk = true;\n      }\n    });\n\n    // if imports * from fileName, don't add symbolName\n    if (importsAsterisk) {\n      return null;\n    }\n\n    const importTextNodes = imports.filter(\n      (n) => (n as ts.Identifier).text === symbolName,\n    );\n\n    // insert import if it's not there\n    if (importTextNodes.length === 0) {\n      const fallbackPos =\n        findNodes(\n          relevantImports[0],\n          ts.SyntaxKind.CloseBraceToken,\n        )[0].getStart() ||\n        findNodes(relevantImports[0], ts.SyntaxKind.FromKeyword)[0].getStart();\n\n      return insertAfterLastOccurrence(\n        imports,\n        `, ${symbolName}`,\n        fileToEdit,\n        fallbackPos,\n      );\n    }\n\n    return null;\n  }\n\n  // no such import declaration exists\n  const useStrict = findNodes(rootNode, ts.SyntaxKind.StringLiteral).filter(\n    (n: ts.StringLiteral) => n.text === 'use strict',\n  );\n  let fallbackPos = 0;\n  if (useStrict.length > 0) {\n    fallbackPos = useStrict[0].end;\n  }\n  const open = isDefault ? '' : '{ ';\n  const close = isDefault ? '' : ' }';\n  // if there are no imports or 'use strict' statement, insert import at beginning of file\n  const insertAtBeginning = allImports.length === 0 && useStrict.length === 0;\n  const separator = insertAtBeginning ? '' : ';\\n';\n  const toInsert =\n    `${separator}import ${open}${symbolName}${close}` +\n    ` from '${fileName}'${insertAtBeginning ? ';\\n' : ''}`;\n\n  return insertAfterLastOccurrence(\n    allImports,\n    toInsert,\n    fileToEdit,\n    fallbackPos,\n    ts.SyntaxKind.StringLiteral,\n  );\n}\n\nfunction insertAfterLastOccurrence(\n  nodes: ts.Node[],\n  toInsert: string,\n  file: string,\n  fallbackPos: number,\n  syntaxKind?: ts.SyntaxKind,\n): Change {\n  // sort() has a side effect, so make a copy so that we won't overwrite the parent's object.\n  let lastItem = [...nodes].sort(nodesByPosition).pop();\n  if (!lastItem) {\n    throw new Error();\n  }\n  if (syntaxKind) {\n    lastItem = findNodes(lastItem, syntaxKind).sort(nodesByPosition).pop();\n  }\n  if (!lastItem && fallbackPos == undefined) {\n    throw new Error(\n      `tried to insert ${toInsert} as first occurrence with no fallback position`,\n    );\n  }\n  const lastItemPosition: number = lastItem ? lastItem.getEnd() : fallbackPos;\n\n  return new InsertChange(file, lastItemPosition, toInsert);\n}\n\nfunction nodesByPosition(first: ts.Node, second: ts.Node): number {\n  return first.getStart() - second.getStart();\n}\n"]}