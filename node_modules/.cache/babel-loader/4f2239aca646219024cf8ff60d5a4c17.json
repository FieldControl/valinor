{"ast":null,"code":"// Inspiration: https://github.com/facebook/react/issues/3386\nvar invariant = require('invariant'),\n    isString = require('lodash.isstring'),\n    flatten = require('lodash.flatten');\n\nfunction replace(string, regexpOrSubstr, newValueOrFn) {\n  invariant(typeof string === 'string', 'First param must be a string');\n  invariant(typeof regexpOrSubstr === 'string' || regexpOrSubstr instanceof RegExp, 'Second param must be a string pattern or a regular expression');\n  var fn = typeof regexpOrSubstr === 'string' ? replaceUsingString : replaceUsingRegexp;\n  return fn(string, regexpOrSubstr, newValueOrFn);\n}\n\nfunction replaceUsingString(string, patternString, newValueOrFn) {\n  var index = string.indexOf(patternString);\n\n  if (index >= 0) {\n    var arr = [];\n    var endIndex = index + patternString.length;\n\n    if (index > 0) {\n      arr.push(string.substring(0, index));\n    }\n\n    arr.push(typeof newValueOrFn === 'function' ? newValueOrFn(string.substring(index, endIndex), index, string) : newValueOrFn);\n\n    if (endIndex < string.length) {\n      arr.push(string.substring(endIndex));\n    }\n\n    return arr;\n  } else {\n    return [string];\n  }\n}\n\nfunction replaceUsingRegexp(string, regexp, newValueOrFn) {\n  var output = [];\n  var replacerIsFn = typeof newValueOrFn === 'function';\n  var storedLastIndex = regexp.lastIndex;\n  regexp.lastIndex = 0;\n  var result;\n  var lastIndex = 0;\n\n  while (result = regexp.exec(string)) {\n    var index = result.index;\n\n    if (result[0] === '') {\n      // When the regexp is an empty string\n      // we still want to advance our cursor to the next item.\n      // This is the behavior of String.replace.\n      regexp.lastIndex++;\n    }\n\n    if (index !== lastIndex) {\n      output.push(string.substring(lastIndex, index));\n    }\n\n    var match = result[0];\n    lastIndex = index + match.length;\n    var out = replacerIsFn ? newValueOrFn.apply(this, result.concat(index, result.input)) : newValueOrFn;\n    output.push(out);\n\n    if (!regexp.global) {\n      break;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    output.push(string.substring(lastIndex));\n  }\n\n  regexp.lastIndex = storedLastIndex;\n  return output;\n}\n\nmodule.exports = function stringReplaceToArray(string, regexpOrSubstr, newSubStrOrFn) {\n  if (isString(string)) {\n    return replace(string, regexpOrSubstr, newSubStrOrFn);\n  } else if (!Array.isArray(string) || !string[0]) {\n    throw new TypeError('First argument must be an array or non-empty string');\n  } else {\n    return flatten(string.map(function (string) {\n      if (!isString(string)) return string;\n      return replace(string, regexpOrSubstr, newSubStrOrFn);\n    }));\n  }\n};","map":{"version":3,"sources":["/Users/mie/Desktop/Web development /valinor/node_modules/string-replace-to-array/string-replace-to-array.js"],"names":["invariant","require","isString","flatten","replace","string","regexpOrSubstr","newValueOrFn","RegExp","fn","replaceUsingString","replaceUsingRegexp","patternString","index","indexOf","arr","endIndex","length","push","substring","regexp","output","replacerIsFn","storedLastIndex","lastIndex","result","exec","match","out","apply","concat","input","global","module","exports","stringReplaceToArray","newSubStrOrFn","Array","isArray","TypeError","map"],"mappings":"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","sourcesContent":["// Inspiration: https://github.com/facebook/react/issues/3386\n\nvar invariant = require('invariant'),\n\tisString = require('lodash.isstring'),\n\tflatten = require('lodash.flatten')\n\nfunction replace (string, regexpOrSubstr, newValueOrFn) {\n\tinvariant(typeof string === 'string', 'First param must be a string')\n\tinvariant(typeof regexpOrSubstr === 'string' || regexpOrSubstr instanceof RegExp, 'Second param must be a string pattern or a regular expression')\n\n\tvar fn = (typeof regexpOrSubstr === 'string') ? replaceUsingString : replaceUsingRegexp\n\n\treturn fn(string, regexpOrSubstr, newValueOrFn)\n}\n\nfunction replaceUsingString (string, patternString, newValueOrFn) {\n\tvar index = string.indexOf(patternString)\n\n\tif (index >= 0) {\n\t\tvar arr = []\n\t\tvar endIndex = index + patternString.length\n\n\t\tif (index > 0) {\n\t\t\tarr.push(string.substring(0, index))\n\t\t}\n\n\t\tarr.push(\n\t\t\t(typeof newValueOrFn === 'function') ?\n\t\t\t\tnewValueOrFn(\n\t\t\t\t\tstring.substring(index, endIndex),\n\t\t\t\t\tindex,\n\t\t\t\t\tstring\n\t\t\t\t) :\n\t\t\t\tnewValueOrFn\n\t\t)\n\n\t\tif (endIndex < string.length) {\n\t\t\tarr.push(string.substring(endIndex))\n\t\t}\n\n\t\treturn arr\n\t} else {\n\t\treturn [string]\n\t}\n}\n\nfunction replaceUsingRegexp (string, regexp, newValueOrFn) {\n\tvar output = []\n\n\tvar replacerIsFn = (typeof newValueOrFn === 'function')\n\n\tvar storedLastIndex = regexp.lastIndex\n\tregexp.lastIndex = 0\n\n\tvar result\n\tvar lastIndex = 0\n\twhile (result = regexp.exec(string)) {\n\t\tvar index = result.index\n\n\t\tif (result[0] === '') {\n\t\t\t// When the regexp is an empty string\n\t\t\t// we still want to advance our cursor to the next item.\n\t\t\t// This is the behavior of String.replace.\n\t\t\tregexp.lastIndex++\n\t\t}\n\n\t\tif (index !== lastIndex) {\n\t\t\toutput.push(string.substring(lastIndex, index))\n\t\t}\n\n\t\tvar match = result[0]\n\t\tlastIndex = index + match.length\n\t\t\n\t\tvar out = replacerIsFn ?\n\t\t\tnewValueOrFn.apply(this, result.concat(index, result.input)) :\n\t\t\tnewValueOrFn\n\t\toutput.push(out)\n\n\t\tif (!regexp.global) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (lastIndex < string.length) {\n\t\toutput.push(string.substring(lastIndex))\n\t}\n\n\tregexp.lastIndex = storedLastIndex\n\treturn output\n}\n\nmodule.exports = function stringReplaceToArray (string, regexpOrSubstr, newSubStrOrFn) {\n\tif (isString(string)) {\n\t\treturn replace(string, regexpOrSubstr, newSubStrOrFn)\n\t} else if (!Array.isArray(string) || !string[0]) {\n\t\tthrow new TypeError('First argument must be an array or non-empty string');\n\t} else {\n\t\treturn flatten(string.map(function (string) {\n\t\t\tif (!isString(string)) return string\n\t\t\treturn replace(string, regexpOrSubstr, newSubStrOrFn)\n\t\t}))\n\t}\n}"]},"metadata":{},"sourceType":"script"}