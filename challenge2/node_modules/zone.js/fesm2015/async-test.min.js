"use strict";
/**
 * @license Angular v12.0.0-next.0
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */!function(e){class s{constructor(s,n,t){this.finishCallback=s,this.failCallback=n,this._pendingMicroTasks=!1,this._pendingMacroTasks=!1,this._alreadyErrored=!1,this._isSync=!1,this.runZone=Zone.current,this.unresolvedChainedPromiseCount=0,this.supportWaitUnresolvedChainedPromise=!1,this.name="asyncTestZone for "+t,this.properties={AsyncTestZoneSpec:this},this.supportWaitUnresolvedChainedPromise=!0===e[Zone.__symbol__("supportWaitUnResolvedChainedPromise")]}isUnresolvedChainedPromisePending(){return this.unresolvedChainedPromiseCount>0}_finishCallbackIfDone(){this._pendingMicroTasks||this._pendingMacroTasks||this.supportWaitUnresolvedChainedPromise&&this.isUnresolvedChainedPromisePending()||this.runZone.run(()=>{setTimeout(()=>{this._alreadyErrored||this._pendingMicroTasks||this._pendingMacroTasks||this.finishCallback()},0)})}patchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const e=Promise[Zone.__symbol__("patchPromiseForTest")];e&&e()}unPatchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const e=Promise[Zone.__symbol__("unPatchPromiseForTest")];e&&e()}onScheduleTask(e,n,t,o){return"eventTask"!==o.type&&(this._isSync=!1),"microTask"===o.type&&o.data&&o.data instanceof Promise&&!0===o.data[s.symbolParentUnresolved]&&this.unresolvedChainedPromiseCount--,e.scheduleTask(t,o)}onInvokeTask(e,s,n,t,o,r){return"eventTask"!==t.type&&(this._isSync=!1),e.invokeTask(n,t,o,r)}onCancelTask(e,s,n,t){return"eventTask"!==t.type&&(this._isSync=!1),e.cancelTask(n,t)}onInvoke(e,s,n,t,o,r,i){try{return this._isSync=!0,e.invoke(n,t,o,r,i)}finally{this._isSync&&this._finishCallbackIfDone()}}onHandleError(e,s,n,t){return e.handleError(n,t)&&(this.failCallback(t),this._alreadyErrored=!0),!1}onHasTask(e,s,n,t){e.hasTask(n,t),"microTask"==t.change?(this._pendingMicroTasks=t.microTask,this._finishCallbackIfDone()):"macroTask"==t.change&&(this._pendingMacroTasks=t.macroTask,this._finishCallbackIfDone())}}s.symbolParentUnresolved=Zone.__symbol__("parentUnresolved"),Zone.AsyncTestZoneSpec=s}("undefined"!=typeof window&&window||"undefined"!=typeof self&&self||global),Zone.__load_patch("asynctest",(e,s,n)=>{function t(e,n,t,o){const r=s.current,i=s.AsyncTestZoneSpec;if(void 0===i)throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/dist/async-test.js");const a=s.ProxyZoneSpec;if(!a)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/dist/proxy.js");const c=a.get();a.assertPresent();const h=s.current.getZoneWith("ProxyZoneSpec"),l=c.getDelegate();return h.parent.run(()=>{const e=new i(()=>{c.getDelegate()==e&&c.setDelegate(l),e.unPatchPromiseForTest(),r.run(()=>{t()})},s=>{c.getDelegate()==e&&c.setDelegate(l),e.unPatchPromiseForTest(),r.run(()=>{o(s)})},"test");c.setDelegate(e),e.patchPromiseForTest()}),s.current.runGuarded(e,n)}s[n.symbol("asyncTest")]=function s(n){return e.jasmine?function(e){e||((e=function(){}).fail=function(e){throw e}),t(n,this,e,s=>{if("string"==typeof s)return e.fail(new Error(s));e.fail(s)})}:function(){return new Promise((e,s)=>{t(n,this,e,s)})}}});