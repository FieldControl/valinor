(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/src/ngtsc/imports/src/emitter", ["require", "exports", "tslib", "@angular/compiler", "typescript", "@angular/compiler-cli/src/ngtsc/file_system", "@angular/compiler-cli/src/ngtsc/file_system/src/util", "@angular/compiler-cli/src/ngtsc/util/src/typescript", "@angular/compiler-cli/src/ngtsc/imports/src/find_export"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnifiedModulesStrategy = exports.RelativePathStrategy = exports.LogicalProjectStrategy = exports.AbsoluteModuleStrategy = exports.LocalIdentifierStrategy = exports.ReferenceEmitter = exports.ImportFlags = void 0;
    var tslib_1 = require("tslib");
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var compiler_1 = require("@angular/compiler");
    var ts = require("typescript");
    var file_system_1 = require("@angular/compiler-cli/src/ngtsc/file_system");
    var util_1 = require("@angular/compiler-cli/src/ngtsc/file_system/src/util");
    var typescript_1 = require("@angular/compiler-cli/src/ngtsc/util/src/typescript");
    var find_export_1 = require("@angular/compiler-cli/src/ngtsc/imports/src/find_export");
    /**
     * Flags which alter the imports generated by the `ReferenceEmitter`.
     */
    var ImportFlags;
    (function (ImportFlags) {
        ImportFlags[ImportFlags["None"] = 0] = "None";
        /**
         * Force the generation of a new import when generating a reference, even if an identifier already
         * exists in the target file which could be used instead.
         *
         * This is sometimes required if there's a risk TypeScript might remove imports during emit.
         */
        ImportFlags[ImportFlags["ForceNewImport"] = 1] = "ForceNewImport";
        /**
         * Don't make use of any aliasing information when emitting a reference.
         *
         * This is sometimes required if emitting into a context where generated references will be fed
         * into TypeScript and type-checked (such as in template type-checking).
         */
        ImportFlags[ImportFlags["NoAliasing"] = 2] = "NoAliasing";
        /**
         * Indicates that an import to a type-only declaration is allowed.
         *
         * For references that occur in type-positions, the referred declaration may be a type-only
         * declaration that is not retained during emit. Including this flag allows to emit references to
         * type-only declarations as used in e.g. template type-checking.
         */
        ImportFlags[ImportFlags["AllowTypeImports"] = 4] = "AllowTypeImports";
    })(ImportFlags = exports.ImportFlags || (exports.ImportFlags = {}));
    /**
     * Generates `Expression`s which refer to `Reference`s in a given context.
     *
     * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
     * `Expression` which refers to a `Reference` in the context of a particular file.
     */
    var ReferenceEmitter = /** @class */ (function () {
        function ReferenceEmitter(strategies) {
            this.strategies = strategies;
        }
        ReferenceEmitter.prototype.emit = function (ref, context, importFlags) {
            var e_1, _a;
            if (importFlags === void 0) { importFlags = ImportFlags.None; }
            try {
                for (var _b = tslib_1.__values(this.strategies), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var strategy = _c.value;
                    var emitted = strategy.emit(ref, context, importFlags);
                    if (emitted !== null) {
                        return emitted;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            throw new Error("Unable to write a reference to " + typescript_1.nodeNameForError(ref.node) + " in " + ref.node.getSourceFile().fileName + " from " + context.fileName);
        };
        return ReferenceEmitter;
    }());
    exports.ReferenceEmitter = ReferenceEmitter;
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
     * such identifiers are available.
     */
    var LocalIdentifierStrategy = /** @class */ (function () {
        function LocalIdentifierStrategy() {
        }
        LocalIdentifierStrategy.prototype.emit = function (ref, context, importFlags) {
            var refSf = typescript_1.getSourceFile(ref.node);
            // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
            // local identifier at all, *except* in the source file where the node is actually declared.
            if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {
                return null;
            }
            // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,
            // etc) and it is in the current file then just use it directly.
            // This is important because the reference could be a property access (e.g. `exports.foo`). In
            // such a case, the reference's `identities` property would be `[foo]`, which would result in an
            // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.
            if (!typescript_1.isDeclaration(ref.node) && refSf === context) {
                return {
                    expression: new compiler_1.WrappedNodeExpr(ref.node),
                    importedFile: null,
                };
            }
            // A Reference can have multiple identities in different files, so it may already have an
            // Identifier in the requested context file.
            var identifier = ref.getIdentityIn(context);
            if (identifier !== null) {
                return {
                    expression: new compiler_1.WrappedNodeExpr(identifier),
                    importedFile: null,
                };
            }
            else {
                return null;
            }
        };
        return LocalIdentifierStrategy;
    }());
    exports.LocalIdentifierStrategy = LocalIdentifierStrategy;
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
     * an absolute import.
     *
     * Part of this strategy involves looking at the target entry point and identifying the exported
     * name of the targeted declaration, as it might be different from the declared name (e.g. a
     * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
     * which maps back to the original directive, an error is thrown.
     */
    var AbsoluteModuleStrategy = /** @class */ (function () {
        function AbsoluteModuleStrategy(program, checker, moduleResolver, reflectionHost) {
            this.program = program;
            this.checker = checker;
            this.moduleResolver = moduleResolver;
            this.reflectionHost = reflectionHost;
            /**
             * A cache of the exports of specific modules, because resolving a module to its exports is a
             * costly operation.
             */
            this.moduleExportsCache = new Map();
        }
        AbsoluteModuleStrategy.prototype.emit = function (ref, context, importFlags) {
            if (ref.bestGuessOwningModule === null) {
                // There is no module name available for this Reference, meaning it was arrived at via a
                // relative path.
                return null;
            }
            else if (!typescript_1.isDeclaration(ref.node)) {
                // It's not possible to import something which isn't a declaration.
                throw new Error("Debug assert: unable to import a Reference to non-declaration of type " + ts.SyntaxKind[ref.node.kind] + ".");
            }
            else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && typescript_1.isTypeDeclaration(ref.node)) {
                throw new Error("Importing a type-only declaration of type " + ts.SyntaxKind[ref.node.kind] + " in a value position is not allowed.");
            }
            // Try to find the exported name of the declaration, if one is available.
            var _a = ref.bestGuessOwningModule, specifier = _a.specifier, resolutionContext = _a.resolutionContext;
            var exports = this.getExportsOfModule(specifier, resolutionContext);
            if (exports === null || !exports.exportMap.has(ref.node)) {
                // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be
                // triggered.
                throw new Error("Symbol " + ref.debugName + " declared in " + typescript_1.getSourceFile(ref.node).fileName + " is not exported from " + specifier + " (import into " + context.fileName + ")");
            }
            var symbolName = exports.exportMap.get(ref.node);
            return {
                expression: new compiler_1.ExternalExpr(new compiler_1.ExternalReference(specifier, symbolName)),
                importedFile: exports.module,
            };
        };
        AbsoluteModuleStrategy.prototype.getExportsOfModule = function (moduleName, fromFile) {
            if (!this.moduleExportsCache.has(moduleName)) {
                this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
            }
            return this.moduleExportsCache.get(moduleName);
        };
        AbsoluteModuleStrategy.prototype.enumerateExportsOfModule = function (specifier, fromFile) {
            var e_2, _a;
            // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
            var entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
            if (entryPointFile === null) {
                return null;
            }
            var exports = this.reflectionHost.getExportsOfModule(entryPointFile);
            if (exports === null) {
                return null;
            }
            var exportMap = new Map();
            try {
                for (var exports_1 = tslib_1.__values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
                    var _b = tslib_1.__read(exports_1_1.value, 2), name_1 = _b[0], declaration = _b[1];
                    if (exportMap.has(declaration.node)) {
                        // An export for this declaration has already been registered. We prefer an export that
                        // has the same name as the declared name, i.e. is not an aliased export. This is relevant
                        // for partial compilations where emitted references should import symbols using a stable
                        // name. This is particularly relevant for declarations inside VE-generated libraries, as
                        // such libraries contain private, unstable reexports of symbols.
                        var existingExport = exportMap.get(declaration.node);
                        if (typescript_1.isNamedDeclaration(declaration.node) && declaration.node.name.text === existingExport) {
                            continue;
                        }
                    }
                    exportMap.set(declaration.node, name_1);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return { module: entryPointFile, exportMap: exportMap };
        };
        return AbsoluteModuleStrategy;
    }());
    exports.AbsoluteModuleStrategy = AbsoluteModuleStrategy;
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
     * both in the logical project "space" of paths.
     *
     * This is trickier than it sounds, as the two files may be in different root directories in the
     * project. Simply calculating a file system relative path between the two is not sufficient.
     * Instead, `LogicalProjectPath`s are used.
     */
    var LogicalProjectStrategy = /** @class */ (function () {
        function LogicalProjectStrategy(reflector, logicalFs) {
            this.reflector = reflector;
            this.logicalFs = logicalFs;
        }
        LogicalProjectStrategy.prototype.emit = function (ref, context) {
            var destSf = typescript_1.getSourceFile(ref.node);
            // Compute the relative path from the importing file to the file being imported. This is done
            // as a logical path computation, because the two files might be in different rootDirs.
            var destPath = this.logicalFs.logicalPathOfSf(destSf);
            if (destPath === null) {
                // The imported file is not within the logical project filesystem.
                return null;
            }
            var originPath = this.logicalFs.logicalPathOfSf(context);
            if (originPath === null) {
                throw new Error("Debug assert: attempt to import from " + context.fileName + " but it's outside the program?");
            }
            // There's no way to emit a relative reference from a file to itself.
            if (destPath === originPath) {
                return null;
            }
            var name = find_export_1.findExportedNameOfNode(ref.node, destSf, this.reflector);
            if (name === null) {
                // The target declaration isn't exported from the file it's declared in. This is an issue!
                return null;
            }
            // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
            // path is now straightforward.
            var moduleName = file_system_1.LogicalProjectPath.relativePathBetween(originPath, destPath);
            return {
                expression: new compiler_1.ExternalExpr({ moduleName: moduleName, name: name }),
                importedFile: destSf,
            };
        };
        return LogicalProjectStrategy;
    }());
    exports.LogicalProjectStrategy = LogicalProjectStrategy;
    /**
     * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
     *
     * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
     * necessitates the stronger logic of `LogicalProjectStrategy`.
     */
    var RelativePathStrategy = /** @class */ (function () {
        function RelativePathStrategy(reflector) {
            this.reflector = reflector;
        }
        RelativePathStrategy.prototype.emit = function (ref, context) {
            var destSf = typescript_1.getSourceFile(ref.node);
            var relativePath = file_system_1.relative(file_system_1.dirname(file_system_1.absoluteFromSourceFile(context)), file_system_1.absoluteFromSourceFile(destSf));
            var moduleName = file_system_1.toRelativeImport(util_1.stripExtension(relativePath));
            var name = find_export_1.findExportedNameOfNode(ref.node, destSf, this.reflector);
            return { expression: new compiler_1.ExternalExpr({ moduleName: moduleName, name: name }), importedFile: destSf };
        };
        return RelativePathStrategy;
    }());
    exports.RelativePathStrategy = RelativePathStrategy;
    /**
     * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
     * references.
     */
    var UnifiedModulesStrategy = /** @class */ (function () {
        function UnifiedModulesStrategy(reflector, unifiedModulesHost) {
            this.reflector = reflector;
            this.unifiedModulesHost = unifiedModulesHost;
        }
        UnifiedModulesStrategy.prototype.emit = function (ref, context) {
            var destSf = typescript_1.getSourceFile(ref.node);
            var name = find_export_1.findExportedNameOfNode(ref.node, destSf, this.reflector);
            if (name === null) {
                return null;
            }
            var moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);
            return {
                expression: new compiler_1.ExternalExpr({ moduleName: moduleName, name: name }),
                importedFile: destSf,
            };
        };
        return UnifiedModulesStrategy;
    }());
    exports.UnifiedModulesStrategy = UnifiedModulesStrategy;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1pdHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvaW1wb3J0cy9zcmMvZW1pdHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0lBQUE7Ozs7OztPQU1HO0lBQ0gsOENBQStGO0lBQy9GLCtCQUFpQztJQUdqQywyRUFBcUk7SUFDckksNkVBQTBEO0lBRTFELGtGQUFnSTtJQUVoSSx1RkFBcUQ7SUFLckQ7O09BRUc7SUFDSCxJQUFZLFdBMkJYO0lBM0JELFdBQVksV0FBVztRQUNyQiw2Q0FBVyxDQUFBO1FBRVg7Ozs7O1dBS0c7UUFDSCxpRUFBcUIsQ0FBQTtRQUVyQjs7Ozs7V0FLRztRQUNILHlEQUFpQixDQUFBO1FBRWpCOzs7Ozs7V0FNRztRQUNILHFFQUF1QixDQUFBO0lBQ3pCLENBQUMsRUEzQlcsV0FBVyxHQUFYLG1CQUFXLEtBQVgsbUJBQVcsUUEyQnRCO0lBMEREOzs7OztPQUtHO0lBQ0g7UUFDRSwwQkFBb0IsVUFBbUM7WUFBbkMsZUFBVSxHQUFWLFVBQVUsQ0FBeUI7UUFBRyxDQUFDO1FBRTNELCtCQUFJLEdBQUosVUFBSyxHQUFjLEVBQUUsT0FBc0IsRUFBRSxXQUEyQzs7WUFBM0MsNEJBQUEsRUFBQSxjQUEyQixXQUFXLENBQUMsSUFBSTs7Z0JBRXRGLEtBQXVCLElBQUEsS0FBQSxpQkFBQSxJQUFJLENBQUMsVUFBVSxDQUFBLGdCQUFBLDRCQUFFO29CQUFuQyxJQUFNLFFBQVEsV0FBQTtvQkFDakIsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUN6RCxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7d0JBQ3BCLE9BQU8sT0FBTyxDQUFDO3FCQUNoQjtpQkFDRjs7Ozs7Ozs7O1lBQ0QsTUFBTSxJQUFJLEtBQUss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ekMsSUFBTSxNQUFNLEdBQUcsMEJBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkMsSUFBTSxJQUFJLEdBQUcsb0NBQXNCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3RFLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtnQkFDakIsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELElBQU0sVUFBVSxHQUNaLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVwRixPQUFPO2dCQUNMLFVBQVUsRUFBRSxJQUFJLHVCQUFZLENBQUMsRUFBQyxVQUFVLFlBQUEsRUFBRSxJQUFJLE1BQUEsRUFBQyxDQUFDO2dCQUNoRCxZQUFZLEVBQUUsTUFBTTthQUNyQixDQUFDO1FBQ0osQ0FBQztRQUNILDZCQUFDO0lBQUQsQ0FBQyxBQWxCRCxJQWtCQztJQWxCWSx3REFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7RXhwcmVzc2lvbiwgRXh0ZXJuYWxFeHByLCBFeHRlcm5hbFJlZmVyZW5jZSwgV3JhcHBlZE5vZGVFeHByfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtVbmlmaWVkTW9kdWxlc0hvc3R9IGZyb20gJy4uLy4uL2NvcmUvYXBpJztcbmltcG9ydCB7YWJzb2x1dGVGcm9tU291cmNlRmlsZSwgZGlybmFtZSwgTG9naWNhbEZpbGVTeXN0ZW0sIExvZ2ljYWxQcm9qZWN0UGF0aCwgcmVsYXRpdmUsIHRvUmVsYXRpdmVJbXBvcnR9IGZyb20gJy4uLy4uL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7c3RyaXBFeHRlbnNpb259IGZyb20gJy4uLy4uL2ZpbGVfc3lzdGVtL3NyYy91dGlsJztcbmltcG9ydCB7RGVjbGFyYXRpb25Ob2RlLCBSZWZsZWN0aW9uSG9zdH0gZnJvbSAnLi4vLi4vcmVmbGVjdGlvbic7XG5pbXBvcnQge2dldFNvdXJjZUZpbGUsIGlzRGVjbGFyYXRpb24sIGlzTmFtZWREZWNsYXJhdGlvbiwgaXNUeXBlRGVjbGFyYXRpb24sIG5vZGVOYW1lRm9yRXJyb3J9IGZyb20gJy4uLy4uL3V0aWwvc3JjL3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge2ZpbmRFeHBvcnRlZE5hbWVPZk5vZGV9IGZyb20gJy4vZmluZF9leHBvcnQnO1xuaW1wb3J0IHtSZWZlcmVuY2V9IGZyb20gJy4vcmVmZXJlbmNlcyc7XG5pbXBvcnQge01vZHVsZVJlc29sdmVyfSBmcm9tICcuL3Jlc29sdmVyJztcblxuXG4vKipcbiAqIEZsYWdzIHdoaWNoIGFsdGVyIHRoZSBpbXBvcnRzIGdlbmVyYXRlZCBieSB0aGUgYFJlZmVyZW5jZUVtaXR0ZXJgLlxuICovXG5leHBvcnQgZW51bSBJbXBvcnRGbGFncyB7XG4gIE5vbmUgPSAweDAwLFxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgZ2VuZXJhdGlvbiBvZiBhIG5ldyBpbXBvcnQgd2hlbiBnZW5lcmF0aW5nIGEgcmVmZXJlbmNlLCBldmVuIGlmIGFuIGlkZW50aWZpZXIgYWxyZWFkeVxuICAgKiBleGlzdHMgaW4gdGhlIHRhcmdldCBmaWxlIHdoaWNoIGNvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICpcbiAgICogVGhpcyBpcyBzb21ldGltZXMgcmVxdWlyZWQgaWYgdGhlcmUncyBhIHJpc2sgVHlwZVNjcmlwdCBtaWdodCByZW1vdmUgaW1wb3J0cyBkdXJpbmcgZW1pdC5cbiAgICovXG4gIEZvcmNlTmV3SW1wb3J0ID0gMHgwMSxcblxuICAvKipcbiAgICogRG9uJ3QgbWFrZSB1c2Ugb2YgYW55IGFsaWFzaW5nIGluZm9ybWF0aW9uIHdoZW4gZW1pdHRpbmcgYSByZWZlcmVuY2UuXG4gICAqXG4gICAqIFRoaXMgaXMgc29tZXRpbWVzIHJlcXVpcmVkIGlmIGVtaXR0aW5nIGludG8gYSBjb250ZXh0IHdoZXJlIGdlbmVyYXRlZCByZWZlcmVuY2VzIHdpbGwgYmUgZmVkXG4gICAqIGludG8gVHlwZVNjcmlwdCBhbmQgdHlwZS1jaGVja2VkIChzdWNoIGFzIGluIHRlbXBsYXRlIHR5cGUtY2hlY2tpbmcpLlxuICAgKi9cbiAgTm9BbGlhc2luZyA9IDB4MDIsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IGFuIGltcG9ydCB0byBhIHR5cGUtb25seSBkZWNsYXJhdGlvbiBpcyBhbGxvd2VkLlxuICAgKlxuICAgKiBGb3IgcmVmZXJlbmNlcyB0aGF0IG9jY3VyIGluIHR5cGUtcG9zaXRpb25zLCB0aGUgcmVmZXJyZWQgZGVjbGFyYXRpb24gbWF5IGJlIGEgdHlwZS1vbmx5XG4gICAqIGRlY2xhcmF0aW9uIHRoYXQgaXMgbm90IHJldGFpbmVkIGR1cmluZyBlbWl0LiBJbmNsdWRpbmcgdGhpcyBmbGFnIGFsbG93cyB0byBlbWl0IHJlZmVyZW5jZXMgdG9cbiAgICogdHlwZS1vbmx5IGRlY2xhcmF0aW9ucyBhcyB1c2VkIGluIGUuZy4gdGVtcGxhdGUgdHlwZS1jaGVja2luZy5cbiAgICovXG4gIEFsbG93VHlwZUltcG9ydHMgPSAweDA0LFxufVxuXG4vKipcbiAqIEFuIGVtaXR0ZXIgc3RyYXRlZ3kgaGFzIHRoZSBhYmlsaXR5IHRvIGluZGljYXRlIHdoaWNoIGB0cy5Tb3VyY2VGaWxlYCBpcyBiZWluZyBpbXBvcnRlZCBieSB0aGVcbiAqIGV4cHJlc3Npb24gdGhhdCBpdCBoYXMgZ2VuZXJhdGVkLiBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWZ1bCBmb3IgY29uc3VtZXJzIG9mIHRoZSBlbWl0dGVkXG4gKiByZWZlcmVuY2UgdGhhdCB3b3VsZCBvdGhlcndpc2UgaGF2ZSB0byBwZXJmb3JtIGEgcmVsYXRpdmVseSBleHBlbnNpdmUgbW9kdWxlIHJlc29sdXRpb24gc3RlcCxcbiAqIGUuZy4gZm9yIGN5Y2xpYyBpbXBvcnQgYW5hbHlzaXMuIEluIGNhc2VzIHRoZSBlbWl0dGVyIGlzIHVuYWJsZSB0byBkZWZpbml0aXZlbHkgZGV0ZXJtaW5lIHRoZVxuICogaW1wb3J0ZWQgc291cmNlIGZpbGUgb3IgYSBjb21wdXRhdGlvbiB3b3VsZCBiZSByZXF1aXJlZCB0byBhY3R1YWxseSBkZXRlcm1pbmUgdGhlIGltcG9ydGVkXG4gKiBzb3VyY2UgZmlsZSwgdGhlbiBgJ3Vua25vd24nYCBzaG91bGQgYmUgcmV0dXJuZWQuIElmIHRoZSBnZW5lcmF0ZWQgZXhwcmVzc2lvbiBkb2VzIG5vdCByZXByZXNlbnRcbiAqIGFuIGltcG9ydCB0aGVuIGBudWxsYCBzaG91bGQgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IHR5cGUgSW1wb3J0ZWRGaWxlID0gdHMuU291cmNlRmlsZXwndW5rbm93bid8bnVsbDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBlbWl0dGVkIGV4cHJlc3Npb24gb2YgYSBgUmVmZXJlbmNlYCB0aGF0IGlzIHZhbGlkIGluIHRoZSBzb3VyY2UgZmlsZSBpdCB3YXNcbiAqIGVtaXR0ZWQgZnJvbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbWl0dGVkUmVmZXJlbmNlIHtcbiAgLyoqXG4gICAqIFRoZSBleHByZXNzaW9uIHRoYXQgcmVmZXJzIHRvIGBSZWZlcmVuY2VgLlxuICAgKi9cbiAgZXhwcmVzc2lvbjogRXhwcmVzc2lvbjtcblxuICAvKipcbiAgICogVGhlIGB0cy5Tb3VyY2VGaWxlYCB0aGF0IGlzIGltcG9ydGVkIGJ5IGBleHByZXNzaW9uYC4gVGhpcyBpcyBub3QgbmVjZXNzYXJpbHkgdGhlIHNvdXJjZSBmaWxlXG4gICAqIG9mIHRoZSBgUmVmZXJlbmNlYCdzIGRlY2xhcmF0aW9uIG5vZGUsIGFzIHRoZSByZWZlcmVuY2UgbWF5IGhhdmUgYmVlbiByZXdyaXR0ZW4gdGhyb3VnaCBhblxuICAgKiBhbGlhcyBleHBvcnQuIEl0IGNvdWxkIGFsc28gYmUgYG51bGxgIGlmIGBleHByZXNzaW9uYCBpcyBhIGxvY2FsIGlkZW50aWZpZXIsIG9yIGAndW5rbm93bidgIGlmXG4gICAqIHRoZSBleGFjdCBzb3VyY2UgZmlsZSB0aGF0IGlzIGJlaW5nIGltcG9ydGVkIGlzIG5vdCBrbm93biB0byB0aGUgZW1pdHRlci5cbiAgICovXG4gIGltcG9ydGVkRmlsZTogSW1wb3J0ZWRGaWxlO1xufVxuXG4vKipcbiAqIEEgcGFydGljdWxhciBzdHJhdGVneSBmb3IgZ2VuZXJhdGluZyBhbiBleHByZXNzaW9uIHdoaWNoIHJlZmVycyB0byBhIGBSZWZlcmVuY2VgLlxuICpcbiAqIFRoZXJlIGFyZSBtYW55IHBvdGVudGlhbCB3YXlzIGEgZ2l2ZW4gYFJlZmVyZW5jZWAgY291bGQgYmUgcmVmZXJyZWQgdG8gaW4gdGhlIGNvbnRleHQgb2YgYSBnaXZlblxuICogZmlsZS4gQSBsb2NhbCBkZWNsYXJhdGlvbiBjb3VsZCBiZSBhdmFpbGFibGUsIHRoZSBgUmVmZXJlbmNlYCBjb3VsZCBiZSBpbXBvcnRhYmxlIHZpYSBhIHJlbGF0aXZlXG4gKiBpbXBvcnQgd2l0aGluIHRoZSBwcm9qZWN0LCBvciBhbiBhYnNvbHV0ZSBpbXBvcnQgaW50byBgbm9kZV9tb2R1bGVzYCBtaWdodCBiZSBuZWNlc3NhcnkuXG4gKlxuICogRGlmZmVyZW50IGBSZWZlcmVuY2VFbWl0U3RyYXRlZ3lgIGltcGxlbWVudGF0aW9ucyBpbXBsZW1lbnQgc3BlY2lmaWMgbG9naWMgZm9yIGdlbmVyYXRpbmcgc3VjaFxuICogcmVmZXJlbmNlcy4gQSBzaW5nbGUgc3RyYXRlZ3kgKHN1Y2ggYXMgdXNpbmcgYSBsb2NhbCBkZWNsYXJhdGlvbikgbWF5IG5vdCBhbHdheXMgYmUgYWJsZSB0b1xuICogZ2VuZXJhdGUgYW4gZXhwcmVzc2lvbiBmb3IgZXZlcnkgYFJlZmVyZW5jZWAgKGZvciBleGFtcGxlLCBpZiBubyBsb2NhbCBpZGVudGlmaWVyIGlzIGF2YWlsYWJsZSksXG4gKiBhbmQgbWF5IHJldHVybiBgbnVsbGAgaW4gc3VjaCBhIGNhc2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5IHtcbiAgLyoqXG4gICAqIEVtaXQgYW4gYEV4cHJlc3Npb25gIHdoaWNoIHJlZmVycyB0byB0aGUgZ2l2ZW4gYFJlZmVyZW5jZWAgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyXG4gICAqIHNvdXJjZSBmaWxlLCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHJlZiB0aGUgYFJlZmVyZW5jZWAgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIGFuIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIGNvbnRleHQgdGhlIHNvdXJjZSBmaWxlIGluIHdoaWNoIHRoZSBgRXhwcmVzc2lvbmAgbXVzdCBiZSB2YWxpZFxuICAgKiBAcGFyYW0gaW1wb3J0RmxhZ3MgYSBmbGFnIHdoaWNoIGNvbnRyb2xzIHdoZXRoZXIgaW1wb3J0cyBzaG91bGQgYmUgZ2VuZXJhdGVkIG9yIG5vdFxuICAgKiBAcmV0dXJucyBhbiBgRW1pdHRlZFJlZmVyZW5jZWAgd2hpY2ggcmVmZXJzIHRvIHRoZSBgUmVmZXJlbmNlYCwgb3IgYG51bGxgIGlmIG5vbmUgY2FuIGJlXG4gICAqICAgZ2VuZXJhdGVkXG4gICAqL1xuICBlbWl0KHJlZjogUmVmZXJlbmNlLCBjb250ZXh0OiB0cy5Tb3VyY2VGaWxlLCBpbXBvcnRGbGFnczogSW1wb3J0RmxhZ3MpOiBFbWl0dGVkUmVmZXJlbmNlfG51bGw7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGBFeHByZXNzaW9uYHMgd2hpY2ggcmVmZXIgdG8gYFJlZmVyZW5jZWBzIGluIGEgZ2l2ZW4gY29udGV4dC5cbiAqXG4gKiBBIGBSZWZlcmVuY2VFbWl0dGVyYCB1c2VzIG9uZSBvciBtb3JlIGBSZWZlcmVuY2VFbWl0U3RyYXRlZ3lgIGltcGxlbWVudGF0aW9ucyB0byBwcm9kdWNlIGFuXG4gKiBgRXhwcmVzc2lvbmAgd2hpY2ggcmVmZXJzIHRvIGEgYFJlZmVyZW5jZWAgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIGZpbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWZlcmVuY2VFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdHJhdGVnaWVzOiBSZWZlcmVuY2VFbWl0U3RyYXRlZ3lbXSkge31cblxuICBlbWl0KHJlZjogUmVmZXJlbmNlLCBjb250ZXh0OiB0cy5Tb3VyY2VGaWxlLCBpbXBvcnRGbGFnczogSW1wb3J0RmxhZ3MgPSBJbXBvcnRGbGFncy5Ob25lKTpcbiAgICAgIEVtaXR0ZWRSZWZlcmVuY2Uge1xuICAgIGZvciAoY29uc3Qgc3RyYXRlZ3kgb2YgdGhpcy5zdHJhdGVnaWVzKSB7XG4gICAgICBjb25zdCBlbWl0dGVkID0gc3RyYXRlZ3kuZW1pdChyZWYsIGNvbnRleHQsIGltcG9ydEZsYWdzKTtcbiAgICAgIGlmIChlbWl0dGVkICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlbWl0dGVkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB3cml0ZSBhIHJlZmVyZW5jZSB0byAke25vZGVOYW1lRm9yRXJyb3IocmVmLm5vZGUpfSBpbiAke1xuICAgICAgICByZWYubm9kZS5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWV9IGZyb20gJHtjb250ZXh0LmZpbGVOYW1lfWApO1xuICB9XG59XG5cbi8qKlxuICogQSBgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5YCB3aGljaCB3aWxsIHJlZmVyIHRvIGRlY2xhcmF0aW9ucyBieSBhbnkgbG9jYWwgYHRzLklkZW50aWZpZXJgcywgaWZcbiAqIHN1Y2ggaWRlbnRpZmllcnMgYXJlIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIExvY2FsSWRlbnRpZmllclN0cmF0ZWd5IGltcGxlbWVudHMgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5IHtcbiAgZW1pdChyZWY6IFJlZmVyZW5jZSwgY29udGV4dDogdHMuU291cmNlRmlsZSwgaW1wb3J0RmxhZ3M6IEltcG9ydEZsYWdzKTogRW1pdHRlZFJlZmVyZW5jZXxudWxsIHtcbiAgICBjb25zdCByZWZTZiA9IGdldFNvdXJjZUZpbGUocmVmLm5vZGUpO1xuXG4gICAgLy8gSWYgdGhlIGVtaXR0ZXIgaGFzIHNwZWNpZmllZCBGb3JjZU5ld0ltcG9ydCwgdGhlbiBMb2NhbElkZW50aWZpZXJTdHJhdGVneSBzaG91bGQgbm90IHVzZSBhXG4gICAgLy8gbG9jYWwgaWRlbnRpZmllciBhdCBhbGwsICpleGNlcHQqIGluIHRoZSBzb3VyY2UgZmlsZSB3aGVyZSB0aGUgbm9kZSBpcyBhY3R1YWxseSBkZWNsYXJlZC5cbiAgICBpZiAoaW1wb3J0RmxhZ3MgJiBJbXBvcnRGbGFncy5Gb3JjZU5ld0ltcG9ydCAmJiByZWZTZiAhPT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgcmVmZXJlbmNlZCBub2RlIGlzIG5vdCBhbiBhY3R1YWwgVFMgZGVjbGFyYXRpb24gKGUuZy4gYGNsYXNzIEZvb2Agb3IgYGZ1bmN0aW9uIGZvbygpIHt9YCxcbiAgICAvLyBldGMpIGFuZCBpdCBpcyBpbiB0aGUgY3VycmVudCBmaWxlIHRoZW4ganVzdCB1c2UgaXQgZGlyZWN0bHkuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIGNvdWxkIGJlIGEgcHJvcGVydHkgYWNjZXNzIChlLmcuIGBleHBvcnRzLmZvb2ApLiBJblxuICAgIC8vIHN1Y2ggYSBjYXNlLCB0aGUgcmVmZXJlbmNlJ3MgYGlkZW50aXRpZXNgIHByb3BlcnR5IHdvdWxkIGJlIGBbZm9vXWAsIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBhblxuICAgIC8vIGludmFsaWQgZW1pc3Npb24gb2YgYSBmcmVlLXN0YW5kaW5nIGBmb29gIGlkZW50aWZpZXIsIHJhdGhlciB0aGFuIGBleHBvcnRzLmZvb2AuXG4gICAgaWYgKCFpc0RlY2xhcmF0aW9uKHJlZi5ub2RlKSAmJiByZWZTZiA9PT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcmVzc2lvbjogbmV3IFdyYXBwZWROb2RlRXhwcihyZWYubm9kZSksXG4gICAgICAgIGltcG9ydGVkRmlsZTogbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQSBSZWZlcmVuY2UgY2FuIGhhdmUgbXVsdGlwbGUgaWRlbnRpdGllcyBpbiBkaWZmZXJlbnQgZmlsZXMsIHNvIGl0IG1heSBhbHJlYWR5IGhhdmUgYW5cbiAgICAvLyBJZGVudGlmaWVyIGluIHRoZSByZXF1ZXN0ZWQgY29udGV4dCBmaWxlLlxuICAgIGNvbnN0IGlkZW50aWZpZXIgPSByZWYuZ2V0SWRlbnRpdHlJbihjb250ZXh0KTtcbiAgICBpZiAoaWRlbnRpZmllciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcmVzc2lvbjogbmV3IFdyYXBwZWROb2RlRXhwcihpZGVudGlmaWVyKSxcbiAgICAgICAgaW1wb3J0ZWRGaWxlOiBudWxsLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZXhwb3J0ZWQgZGVjbGFyYXRpb25zIGZyb20gYSBtb2R1bGUgc291cmNlIGZpbGUuXG4gKi9cbmludGVyZmFjZSBNb2R1bGVFeHBvcnRzIHtcbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgZmlsZSBvZiB0aGUgbW9kdWxlLlxuICAgKi9cbiAgbW9kdWxlOiB0cy5Tb3VyY2VGaWxlO1xuXG4gIC8qKlxuICAgKiBUaGUgbWFwIG9mIGRlY2xhcmF0aW9ucyB0byB0aGVpciBleHBvcnRlZCBuYW1lLlxuICAgKi9cbiAgZXhwb3J0TWFwOiBNYXA8RGVjbGFyYXRpb25Ob2RlLCBzdHJpbmc+O1xufVxuXG4vKipcbiAqIEEgYFJlZmVyZW5jZUVtaXRTdHJhdGVneWAgd2hpY2ggd2lsbCByZWZlciB0byBkZWNsYXJhdGlvbnMgdGhhdCBjb21lIGZyb20gYG5vZGVfbW9kdWxlc2AgdXNpbmdcbiAqIGFuIGFic29sdXRlIGltcG9ydC5cbiAqXG4gKiBQYXJ0IG9mIHRoaXMgc3RyYXRlZ3kgaW52b2x2ZXMgbG9va2luZyBhdCB0aGUgdGFyZ2V0IGVudHJ5IHBvaW50IGFuZCBpZGVudGlmeWluZyB0aGUgZXhwb3J0ZWRcbiAqIG5hbWUgb2YgdGhlIHRhcmdldGVkIGRlY2xhcmF0aW9uLCBhcyBpdCBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgZGVjbGFyZWQgbmFtZSAoZS5nLiBhXG4gKiBkaXJlY3RpdmUgbWlnaHQgYmUgZGVjbGFyZWQgYXMgRm9vRGlySW1wbCwgYnV0IGV4cG9ydGVkIGFzIEZvb0RpcikuIElmIG5vIGV4cG9ydCBjYW4gYmUgZm91bmRcbiAqIHdoaWNoIG1hcHMgYmFjayB0byB0aGUgb3JpZ2luYWwgZGlyZWN0aXZlLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnNvbHV0ZU1vZHVsZVN0cmF0ZWd5IGltcGxlbWVudHMgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5IHtcbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgdGhlIGV4cG9ydHMgb2Ygc3BlY2lmaWMgbW9kdWxlcywgYmVjYXVzZSByZXNvbHZpbmcgYSBtb2R1bGUgdG8gaXRzIGV4cG9ydHMgaXMgYVxuICAgKiBjb3N0bHkgb3BlcmF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBtb2R1bGVFeHBvcnRzQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgTW9kdWxlRXhwb3J0c3xudWxsPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJvdGVjdGVkIHByb2dyYW06IHRzLlByb2dyYW0sIHByb3RlY3RlZCBjaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICAgIHByb3RlY3RlZCBtb2R1bGVSZXNvbHZlcjogTW9kdWxlUmVzb2x2ZXIsIHByaXZhdGUgcmVmbGVjdGlvbkhvc3Q6IFJlZmxlY3Rpb25Ib3N0KSB7fVxuXG4gIGVtaXQocmVmOiBSZWZlcmVuY2UsIGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUsIGltcG9ydEZsYWdzOiBJbXBvcnRGbGFncyk6IEVtaXR0ZWRSZWZlcmVuY2V8bnVsbCB7XG4gICAgaWYgKHJlZi5iZXN0R3Vlc3NPd25pbmdNb2R1bGUgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIG1vZHVsZSBuYW1lIGF2YWlsYWJsZSBmb3IgdGhpcyBSZWZlcmVuY2UsIG1lYW5pbmcgaXQgd2FzIGFycml2ZWQgYXQgdmlhIGFcbiAgICAgIC8vIHJlbGF0aXZlIHBhdGguXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCFpc0RlY2xhcmF0aW9uKHJlZi5ub2RlKSkge1xuICAgICAgLy8gSXQncyBub3QgcG9zc2libGUgdG8gaW1wb3J0IHNvbWV0aGluZyB3aGljaCBpc24ndCBhIGRlY2xhcmF0aW9uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWJ1ZyBhc3NlcnQ6IHVuYWJsZSB0byBpbXBvcnQgYSBSZWZlcmVuY2UgdG8gbm9uLWRlY2xhcmF0aW9uIG9mIHR5cGUgJHtcbiAgICAgICAgICB0cy5TeW50YXhLaW5kW3JlZi5ub2RlLmtpbmRdfS5gKTtcbiAgICB9IGVsc2UgaWYgKChpbXBvcnRGbGFncyAmIEltcG9ydEZsYWdzLkFsbG93VHlwZUltcG9ydHMpID09PSAwICYmIGlzVHlwZURlY2xhcmF0aW9uKHJlZi5ub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbXBvcnRpbmcgYSB0eXBlLW9ubHkgZGVjbGFyYXRpb24gb2YgdHlwZSAke1xuICAgICAgICAgIHRzLlN5bnRheEtpbmRbcmVmLm5vZGUua2luZF19IGluIGEgdmFsdWUgcG9zaXRpb24gaXMgbm90IGFsbG93ZWQuYCk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGV4cG9ydGVkIG5hbWUgb2YgdGhlIGRlY2xhcmF0aW9uLCBpZiBvbmUgaXMgYXZhaWxhYmxlLlxuICAgIGNvbnN0IHtzcGVjaWZpZXIsIHJlc29sdXRpb25Db250ZXh0fSA9IHJlZi5iZXN0R3Vlc3NPd25pbmdNb2R1bGU7XG4gICAgY29uc3QgZXhwb3J0cyA9IHRoaXMuZ2V0RXhwb3J0c09mTW9kdWxlKHNwZWNpZmllciwgcmVzb2x1dGlvbkNvbnRleHQpO1xuICAgIGlmIChleHBvcnRzID09PSBudWxsIHx8ICFleHBvcnRzLmV4cG9ydE1hcC5oYXMocmVmLm5vZGUpKSB7XG4gICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBlcnJvciBhIHRzLkRpYWdub3N0aWMgcG9pbnRpbmcgYXQgd2hhdGV2ZXIgY2F1c2VkIHRoaXMgaW1wb3J0IHRvIGJlXG4gICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5bWJvbCAke3JlZi5kZWJ1Z05hbWV9IGRlY2xhcmVkIGluICR7XG4gICAgICAgICAgZ2V0U291cmNlRmlsZShyZWYubm9kZSkuZmlsZU5hbWV9IGlzIG5vdCBleHBvcnRlZCBmcm9tICR7c3BlY2lmaWVyfSAoaW1wb3J0IGludG8gJHtcbiAgICAgICAgICBjb250ZXh0LmZpbGVOYW1lfSlgKTtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sTmFtZSA9IGV4cG9ydHMuZXhwb3J0TWFwLmdldChyZWYubm9kZSkhO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cHJlc3Npb246IG5ldyBFeHRlcm5hbEV4cHIobmV3IEV4dGVybmFsUmVmZXJlbmNlKHNwZWNpZmllciwgc3ltYm9sTmFtZSkpLFxuICAgICAgaW1wb3J0ZWRGaWxlOiBleHBvcnRzLm1vZHVsZSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRFeHBvcnRzT2ZNb2R1bGUobW9kdWxlTmFtZTogc3RyaW5nLCBmcm9tRmlsZTogc3RyaW5nKTogTW9kdWxlRXhwb3J0c3xudWxsIHtcbiAgICBpZiAoIXRoaXMubW9kdWxlRXhwb3J0c0NhY2hlLmhhcyhtb2R1bGVOYW1lKSkge1xuICAgICAgdGhpcy5tb2R1bGVFeHBvcnRzQ2FjaGUuc2V0KG1vZHVsZU5hbWUsIHRoaXMuZW51bWVyYXRlRXhwb3J0c09mTW9kdWxlKG1vZHVsZU5hbWUsIGZyb21GaWxlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vZHVsZUV4cG9ydHNDYWNoZS5nZXQobW9kdWxlTmFtZSkhO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVudW1lcmF0ZUV4cG9ydHNPZk1vZHVsZShzcGVjaWZpZXI6IHN0cmluZywgZnJvbUZpbGU6IHN0cmluZyk6IE1vZHVsZUV4cG9ydHN8bnVsbCB7XG4gICAgLy8gRmlyc3QsIHJlc29sdmUgdGhlIG1vZHVsZSBzcGVjaWZpZXIgdG8gaXRzIGVudHJ5IHBvaW50LCBhbmQgZ2V0IHRoZSB0cy5TeW1ib2wgZm9yIGl0LlxuICAgIGNvbnN0IGVudHJ5UG9pbnRGaWxlID0gdGhpcy5tb2R1bGVSZXNvbHZlci5yZXNvbHZlTW9kdWxlKHNwZWNpZmllciwgZnJvbUZpbGUpO1xuICAgIGlmIChlbnRyeVBvaW50RmlsZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwb3J0cyA9IHRoaXMucmVmbGVjdGlvbkhvc3QuZ2V0RXhwb3J0c09mTW9kdWxlKGVudHJ5UG9pbnRGaWxlKTtcbiAgICBpZiAoZXhwb3J0cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4cG9ydE1hcCA9IG5ldyBNYXA8RGVjbGFyYXRpb25Ob2RlLCBzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgZGVjbGFyYXRpb25dIG9mIGV4cG9ydHMpIHtcbiAgICAgIGlmIChleHBvcnRNYXAuaGFzKGRlY2xhcmF0aW9uLm5vZGUpKSB7XG4gICAgICAgIC8vIEFuIGV4cG9ydCBmb3IgdGhpcyBkZWNsYXJhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuIFdlIHByZWZlciBhbiBleHBvcnQgdGhhdFxuICAgICAgICAvLyBoYXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgZGVjbGFyZWQgbmFtZSwgaS5lLiBpcyBub3QgYW4gYWxpYXNlZCBleHBvcnQuIFRoaXMgaXMgcmVsZXZhbnRcbiAgICAgICAgLy8gZm9yIHBhcnRpYWwgY29tcGlsYXRpb25zIHdoZXJlIGVtaXR0ZWQgcmVmZXJlbmNlcyBzaG91bGQgaW1wb3J0IHN5bWJvbHMgdXNpbmcgYSBzdGFibGVcbiAgICAgICAgLy8gbmFtZS4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgcmVsZXZhbnQgZm9yIGRlY2xhcmF0aW9ucyBpbnNpZGUgVkUtZ2VuZXJhdGVkIGxpYnJhcmllcywgYXNcbiAgICAgICAgLy8gc3VjaCBsaWJyYXJpZXMgY29udGFpbiBwcml2YXRlLCB1bnN0YWJsZSByZWV4cG9ydHMgb2Ygc3ltYm9scy5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdFeHBvcnQgPSBleHBvcnRNYXAuZ2V0KGRlY2xhcmF0aW9uLm5vZGUpITtcbiAgICAgICAgaWYgKGlzTmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5ub2RlKSAmJiBkZWNsYXJhdGlvbi5ub2RlLm5hbWUudGV4dCA9PT0gZXhpc3RpbmdFeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXhwb3J0TWFwLnNldChkZWNsYXJhdGlvbi5ub2RlLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHttb2R1bGU6IGVudHJ5UG9pbnRGaWxlLCBleHBvcnRNYXB9O1xuICB9XG59XG5cbi8qKlxuICogQSBgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5YCB3aGljaCB3aWxsIHJlZmVyIHRvIGRlY2xhcmF0aW9ucyB2aWEgcmVsYXRpdmUgcGF0aHMsIHByb3ZpZGVkIHRoZXkncmVcbiAqIGJvdGggaW4gdGhlIGxvZ2ljYWwgcHJvamVjdCBcInNwYWNlXCIgb2YgcGF0aHMuXG4gKlxuICogVGhpcyBpcyB0cmlja2llciB0aGFuIGl0IHNvdW5kcywgYXMgdGhlIHR3byBmaWxlcyBtYXkgYmUgaW4gZGlmZmVyZW50IHJvb3QgZGlyZWN0b3JpZXMgaW4gdGhlXG4gKiBwcm9qZWN0LiBTaW1wbHkgY2FsY3VsYXRpbmcgYSBmaWxlIHN5c3RlbSByZWxhdGl2ZSBwYXRoIGJldHdlZW4gdGhlIHR3byBpcyBub3Qgc3VmZmljaWVudC5cbiAqIEluc3RlYWQsIGBMb2dpY2FsUHJvamVjdFBhdGhgcyBhcmUgdXNlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2ljYWxQcm9qZWN0U3RyYXRlZ3kgaW1wbGVtZW50cyBSZWZlcmVuY2VFbWl0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZmxlY3RvcjogUmVmbGVjdGlvbkhvc3QsIHByaXZhdGUgbG9naWNhbEZzOiBMb2dpY2FsRmlsZVN5c3RlbSkge31cblxuICBlbWl0KHJlZjogUmVmZXJlbmNlLCBjb250ZXh0OiB0cy5Tb3VyY2VGaWxlKTogRW1pdHRlZFJlZmVyZW5jZXxudWxsIHtcbiAgICBjb25zdCBkZXN0U2YgPSBnZXRTb3VyY2VGaWxlKHJlZi5ub2RlKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgaW1wb3J0aW5nIGZpbGUgdG8gdGhlIGZpbGUgYmVpbmcgaW1wb3J0ZWQuIFRoaXMgaXMgZG9uZVxuICAgIC8vIGFzIGEgbG9naWNhbCBwYXRoIGNvbXB1dGF0aW9uLCBiZWNhdXNlIHRoZSB0d28gZmlsZXMgbWlnaHQgYmUgaW4gZGlmZmVyZW50IHJvb3REaXJzLlxuICAgIGNvbnN0IGRlc3RQYXRoID0gdGhpcy5sb2dpY2FsRnMubG9naWNhbFBhdGhPZlNmKGRlc3RTZik7XG4gICAgaWYgKGRlc3RQYXRoID09PSBudWxsKSB7XG4gICAgICAvLyBUaGUgaW1wb3J0ZWQgZmlsZSBpcyBub3Qgd2l0aGluIHRoZSBsb2dpY2FsIHByb2plY3QgZmlsZXN5c3RlbS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpblBhdGggPSB0aGlzLmxvZ2ljYWxGcy5sb2dpY2FsUGF0aE9mU2YoY29udGV4dCk7XG4gICAgaWYgKG9yaWdpblBhdGggPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRGVidWcgYXNzZXJ0OiBhdHRlbXB0IHRvIGltcG9ydCBmcm9tICR7Y29udGV4dC5maWxlTmFtZX0gYnV0IGl0J3Mgb3V0c2lkZSB0aGUgcHJvZ3JhbT9gKTtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSdzIG5vIHdheSB0byBlbWl0IGEgcmVsYXRpdmUgcmVmZXJlbmNlIGZyb20gYSBmaWxlIHRvIGl0c2VsZi5cbiAgICBpZiAoZGVzdFBhdGggPT09IG9yaWdpblBhdGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBmaW5kRXhwb3J0ZWROYW1lT2ZOb2RlKHJlZi5ub2RlLCBkZXN0U2YsIHRoaXMucmVmbGVjdG9yKTtcbiAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlIHRhcmdldCBkZWNsYXJhdGlvbiBpc24ndCBleHBvcnRlZCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVjbGFyZWQgaW4uIFRoaXMgaXMgYW4gaXNzdWUhXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBXaXRoIGJvdGggZmlsZXMgZXhwcmVzc2VkIGFzIExvZ2ljYWxQcm9qZWN0UGF0aHMsIGdldHRpbmcgdGhlIG1vZHVsZSBzcGVjaWZpZXIgYXMgYSByZWxhdGl2ZVxuICAgIC8vIHBhdGggaXMgbm93IHN0cmFpZ2h0Zm9yd2FyZC5cbiAgICBjb25zdCBtb2R1bGVOYW1lID0gTG9naWNhbFByb2plY3RQYXRoLnJlbGF0aXZlUGF0aEJldHdlZW4ob3JpZ2luUGF0aCwgZGVzdFBhdGgpO1xuICAgIHJldHVybiB7XG4gICAgICBleHByZXNzaW9uOiBuZXcgRXh0ZXJuYWxFeHByKHttb2R1bGVOYW1lLCBuYW1lfSksXG4gICAgICBpbXBvcnRlZEZpbGU6IGRlc3RTZixcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQSBgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5YCB3aGljaCBjb25zdHJ1Y3RzIHJlbGF0aXZlcyBwYXRocyBiZXR3ZWVuIGB0cy5Tb3VyY2VGaWxlYHMuXG4gKlxuICogVGhpcyBzdHJhdGVneSBjYW4gYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBgcm9vdERpcmAvYHJvb3REaXJzYCBzdHJ1Y3R1cmUgZm9yIHRoZSBwcm9qZWN0IHdoaWNoXG4gKiBuZWNlc3NpdGF0ZXMgdGhlIHN0cm9uZ2VyIGxvZ2ljIG9mIGBMb2dpY2FsUHJvamVjdFN0cmF0ZWd5YC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbGF0aXZlUGF0aFN0cmF0ZWd5IGltcGxlbWVudHMgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWZsZWN0b3I6IFJlZmxlY3Rpb25Ib3N0KSB7fVxuXG4gIGVtaXQocmVmOiBSZWZlcmVuY2UsIGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUpOiBFbWl0dGVkUmVmZXJlbmNlfG51bGwge1xuICAgIGNvbnN0IGRlc3RTZiA9IGdldFNvdXJjZUZpbGUocmVmLm5vZGUpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9XG4gICAgICAgIHJlbGF0aXZlKGRpcm5hbWUoYWJzb2x1dGVGcm9tU291cmNlRmlsZShjb250ZXh0KSksIGFic29sdXRlRnJvbVNvdXJjZUZpbGUoZGVzdFNmKSk7XG4gICAgY29uc3QgbW9kdWxlTmFtZSA9IHRvUmVsYXRpdmVJbXBvcnQoc3RyaXBFeHRlbnNpb24ocmVsYXRpdmVQYXRoKSk7XG5cbiAgICBjb25zdCBuYW1lID0gZmluZEV4cG9ydGVkTmFtZU9mTm9kZShyZWYubm9kZSwgZGVzdFNmLCB0aGlzLnJlZmxlY3Rvcik7XG4gICAgcmV0dXJuIHtleHByZXNzaW9uOiBuZXcgRXh0ZXJuYWxFeHByKHttb2R1bGVOYW1lLCBuYW1lfSksIGltcG9ydGVkRmlsZTogZGVzdFNmfTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYFJlZmVyZW5jZUVtaXRTdHJhdGVneWAgd2hpY2ggdXNlcyBhIGBVbmlmaWVkTW9kdWxlc0hvc3RgIHRvIGdlbmVyYXRlIGFic29sdXRlIGltcG9ydFxuICogcmVmZXJlbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVuaWZpZWRNb2R1bGVzU3RyYXRlZ3kgaW1wbGVtZW50cyBSZWZlcmVuY2VFbWl0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZmxlY3RvcjogUmVmbGVjdGlvbkhvc3QsIHByaXZhdGUgdW5pZmllZE1vZHVsZXNIb3N0OiBVbmlmaWVkTW9kdWxlc0hvc3QpIHt9XG5cbiAgZW1pdChyZWY6IFJlZmVyZW5jZSwgY29udGV4dDogdHMuU291cmNlRmlsZSk6IEVtaXR0ZWRSZWZlcmVuY2V8bnVsbCB7XG4gICAgY29uc3QgZGVzdFNmID0gZ2V0U291cmNlRmlsZShyZWYubm9kZSk7XG4gICAgY29uc3QgbmFtZSA9IGZpbmRFeHBvcnRlZE5hbWVPZk5vZGUocmVmLm5vZGUsIGRlc3RTZiwgdGhpcy5yZWZsZWN0b3IpO1xuICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtb2R1bGVOYW1lID1cbiAgICAgICAgdGhpcy51bmlmaWVkTW9kdWxlc0hvc3QuZmlsZU5hbWVUb01vZHVsZU5hbWUoZGVzdFNmLmZpbGVOYW1lLCBjb250ZXh0LmZpbGVOYW1lKTtcblxuICAgIHJldHVybiB7XG4gICAgICBleHByZXNzaW9uOiBuZXcgRXh0ZXJuYWxFeHByKHttb2R1bGVOYW1lLCBuYW1lfSksXG4gICAgICBpbXBvcnRlZEZpbGU6IGRlc3RTZixcbiAgICB9O1xuICB9XG59XG4iXX0=