{"version":3,"file":"tooltip.d.ts","sources":["tooltip.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { AnimationEvent } from '@angular/animations';\nimport { AriaDescriber, FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { BooleanInput, NumberInput } from '@angular/cdk/coercion';\nimport { BreakpointObserver, BreakpointState } from '@angular/cdk/layout';\nimport { ConnectedPosition, OriginConnectionPosition, Overlay, OverlayConnectionPosition, OverlayRef, ScrollStrategy } from '@angular/cdk/overlay';\nimport { Platform } from '@angular/cdk/platform';\nimport { ComponentType } from '@angular/cdk/portal';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { ChangeDetectorRef, ElementRef, InjectionToken, NgZone, OnDestroy, ViewContainerRef, AfterViewInit } from '@angular/core';\nimport { Observable } from 'rxjs';\n/** Possible positions for a tooltip. */\nexport declare type TooltipPosition = 'left' | 'right' | 'above' | 'below' | 'before' | 'after';\n/**\n * Options for how the tooltip trigger should handle touch gestures.\n * See `MatTooltip.touchGestures` for more information.\n */\nexport declare type TooltipTouchGestures = 'auto' | 'on' | 'off';\n/** Possible visibility states of a tooltip. */\nexport declare type TooltipVisibility = 'initial' | 'visible' | 'hidden';\n/** Time in ms to throttle repositioning after scroll events. */\nexport declare const SCROLL_THROTTLE_MS = 20;\n/**\n * CSS class that will be attached to the overlay panel.\n * @deprecated\n * @breaking-change 13.0.0 remove this variable\n */\nexport declare const TOOLTIP_PANEL_CLASS = \"mat-tooltip-panel\";\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @docs-private\n */\nexport declare function getMatTooltipInvalidPositionError(position: string): Error;\n/** Injection token that determines the scroll handling while a tooltip is visible. */\nexport declare const MAT_TOOLTIP_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n/** @docs-private */\nexport declare function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\n/** @docs-private */\nexport declare const MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: (typeof Overlay)[];\n    useFactory: typeof MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY;\n};\n/** Default `matTooltip` options that can be overridden. */\nexport interface MatTooltipDefaultOptions {\n    showDelay: number;\n    hideDelay: number;\n    touchendHideDelay: number;\n    touchGestures?: TooltipTouchGestures;\n    position?: TooltipPosition;\n}\n/** Injection token to be used to override the default options for `matTooltip`. */\nexport declare const MAT_TOOLTIP_DEFAULT_OPTIONS: InjectionToken<MatTooltipDefaultOptions>;\n/** @docs-private */\nexport declare function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY(): MatTooltipDefaultOptions;\nexport declare abstract class _MatTooltipBase<T extends _TooltipComponentBase> implements OnDestroy, AfterViewInit {\n    private _overlay;\n    private _elementRef;\n    private _scrollDispatcher;\n    private _viewContainerRef;\n    private _ngZone;\n    private _platform;\n    private _ariaDescriber;\n    private _focusMonitor;\n    protected _dir: Directionality;\n    private _defaultOptions;\n    _overlayRef: OverlayRef | null;\n    _tooltipInstance: T | null;\n    private _portal;\n    private _position;\n    private _disabled;\n    private _tooltipClass;\n    private _scrollStrategy;\n    private _viewInitialized;\n    private _pointerExitEventsInitialized;\n    protected abstract readonly _tooltipComponent: ComponentType<T>;\n    protected _viewportMargin: number;\n    private _currentPosition;\n    protected readonly _cssClassPrefix: string;\n    /** Allows the user to define the position of the tooltip relative to the parent element */\n    get position(): TooltipPosition;\n    set position(value: TooltipPosition);\n    /** Disables the display of the tooltip. */\n    get disabled(): boolean;\n    set disabled(value: boolean);\n    /** The default delay in ms before showing the tooltip after show is called */\n    showDelay: number;\n    /** The default delay in ms before hiding the tooltip after hide is called */\n    hideDelay: number;\n    /**\n     * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive\n     * uses a long press gesture to show and hide, however it can conflict with the native browser\n     * gestures. To work around the conflict, Angular Material disables native gestures on the\n     * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable\n     * elements). The different values for this option configure the touch event handling as follows:\n     * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native\n     *   browser gestures on particular elements. In particular, it allows text selection on inputs\n     *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.\n     * - `on` - Enables touch gestures for all elements and disables native\n     *   browser gestures with no exceptions.\n     * - `off` - Disables touch gestures. Note that this will prevent the tooltip from\n     *   showing on touch devices.\n     */\n    touchGestures: TooltipTouchGestures;\n    /** The message to be displayed in the tooltip */\n    get message(): string;\n    set message(value: string);\n    private _message;\n    /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\n    get tooltipClass(): string | string[] | Set<string> | {\n        [key: string]: any;\n    };\n    set tooltipClass(value: string | string[] | Set<string> | {\n        [key: string]: any;\n    });\n    /** Manually-bound passive event listeners. */\n    private readonly _passiveListeners;\n    /** Reference to the current document. */\n    private _document;\n    /** Timer started at the last `touchstart` event. */\n    private _touchstartTimeout;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    constructor(_overlay: Overlay, _elementRef: ElementRef<HTMLElement>, _scrollDispatcher: ScrollDispatcher, _viewContainerRef: ViewContainerRef, _ngZone: NgZone, _platform: Platform, _ariaDescriber: AriaDescriber, _focusMonitor: FocusMonitor, scrollStrategy: any, _dir: Directionality, _defaultOptions: MatTooltipDefaultOptions, _document: any);\n    ngAfterViewInit(): void;\n    /**\n     * Dispose the tooltip when destroyed.\n     */\n    ngOnDestroy(): void;\n    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n    show(delay?: number): void;\n    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n    hide(delay?: number): void;\n    /** Shows/hides the tooltip */\n    toggle(): void;\n    /** Returns true if the tooltip is currently visible to the user */\n    _isTooltipVisible(): boolean;\n    /**\n     * Handles the keydown events on the host element.\n     * Needs to be an arrow function so that we can use it in addEventListener.\n     */\n    private _handleKeydown;\n    /** Create the overlay config and position strategy */\n    private _createOverlay;\n    /** Detaches the currently-attached tooltip. */\n    private _detach;\n    /** Updates the position of the current tooltip. */\n    private _updatePosition;\n    /** Adds the configured offset to a position. Used as a hook for child classes. */\n    protected _addOffset(position: ConnectedPosition): ConnectedPosition;\n    /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n     */\n    _getOrigin(): {\n        main: OriginConnectionPosition;\n        fallback: OriginConnectionPosition;\n    };\n    /** Returns the overlay position and a fallback position based on the user's preference */\n    _getOverlayPosition(): {\n        main: OverlayConnectionPosition;\n        fallback: OverlayConnectionPosition;\n    };\n    /** Updates the tooltip message and repositions the overlay according to the new message length */\n    private _updateTooltipMessage;\n    /** Updates the tooltip class */\n    private _setTooltipClass;\n    /** Inverts an overlay position. */\n    private _invertPosition;\n    /** Updates the class on the overlay panel based on the current position of the tooltip. */\n    private _updateCurrentPositionClass;\n    /** Binds the pointer events to the tooltip trigger. */\n    private _setupPointerEnterEventsIfNeeded;\n    private _setupPointerExitEventsIfNeeded;\n    private _addListeners;\n    private _platformSupportsMouseEvents;\n    /** Listener for the `wheel` event on the element. */\n    private _wheelListener;\n    /** Disables the native browser gestures, based on how the tooltip has been configured. */\n    private _disableNativeGesturesIfNecessary;\n    static ngAcceptInputType_disabled: BooleanInput;\n    static ngAcceptInputType_hideDelay: NumberInput;\n    static ngAcceptInputType_showDelay: NumberInput;\n}\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.io/design/components/tooltips.html\n */\nexport declare class MatTooltip extends _MatTooltipBase<TooltipComponent> {\n    protected readonly _tooltipComponent: typeof TooltipComponent;\n    constructor(overlay: Overlay, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, viewContainerRef: ViewContainerRef, ngZone: NgZone, platform: Platform, ariaDescriber: AriaDescriber, focusMonitor: FocusMonitor, scrollStrategy: any, dir: Directionality, defaultOptions: MatTooltipDefaultOptions, _document: any);\n}\nexport declare abstract class _TooltipComponentBase implements OnDestroy {\n    private _changeDetectorRef;\n    /** Message to display in the tooltip */\n    message: string;\n    /** Classes to be added to the tooltip. Supports the same syntax as `ngClass`. */\n    tooltipClass: string | string[] | Set<string> | {\n        [key: string]: any;\n    };\n    /** The timeout ID of any current timer set to show the tooltip */\n    _showTimeoutId: number | undefined;\n    /** The timeout ID of any current timer set to hide the tooltip */\n    _hideTimeoutId: number | undefined;\n    /** Property watched by the animation framework to show or hide the tooltip */\n    _visibility: TooltipVisibility;\n    /** Whether interactions on the page should close the tooltip */\n    private _closeOnInteraction;\n    /** Subject for notifying that the tooltip has been hidden from the view */\n    private readonly _onHide;\n    constructor(_changeDetectorRef: ChangeDetectorRef);\n    /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param delay Amount of milliseconds to the delay showing the tooltip.\n     */\n    show(delay: number): void;\n    /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param delay Amount of milliseconds to delay showing the tooltip.\n     */\n    hide(delay: number): void;\n    /** Returns an observable that notifies when the tooltip has been hidden from view. */\n    afterHidden(): Observable<void>;\n    /** Whether the tooltip is being displayed. */\n    isVisible(): boolean;\n    ngOnDestroy(): void;\n    _animationStart(): void;\n    _animationDone(event: AnimationEvent): void;\n    /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.io/design/components/tooltips.html#behavior\n     */\n    _handleBodyInteraction(): void;\n    /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     */\n    _markForCheck(): void;\n}\n/**\n * Internal component that wraps the tooltip's content.\n * @docs-private\n */\nexport declare class TooltipComponent extends _TooltipComponentBase {\n    private _breakpointObserver;\n    /** Stream that emits whether the user has a handset-sized display.  */\n    _isHandset: Observable<BreakpointState>;\n    constructor(changeDetectorRef: ChangeDetectorRef, _breakpointObserver: BreakpointObserver);\n}\n"]}