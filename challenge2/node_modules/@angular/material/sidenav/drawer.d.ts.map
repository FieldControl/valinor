{"version":3,"file":"drawer.d.ts","sources":["drawer.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { AnimationEvent } from '@angular/animations';\nimport { FocusMonitor, FocusOrigin, FocusTrapFactory } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { CdkScrollable, ScrollDispatcher, ViewportRuler } from '@angular/cdk/scrolling';\nimport { AfterContentChecked, AfterContentInit, ChangeDetectorRef, DoCheck, ElementRef, EventEmitter, InjectionToken, NgZone, OnDestroy, QueryList } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nexport declare function throwMatDuplicatedDrawerError(position: string): void;\n/** Result of the toggle promise that indicates the state of the drawer. */\nexport declare type MatDrawerToggleResult = 'open' | 'close';\n/** Drawer and SideNav display modes. */\nexport declare type MatDrawerMode = 'over' | 'push' | 'side';\n/** Configures whether drawers should use auto sizing by default. */\nexport declare const MAT_DRAWER_DEFAULT_AUTOSIZE: InjectionToken<boolean>;\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\nexport declare const MAT_DRAWER_CONTAINER: InjectionToken<unknown>;\n/** @docs-private */\nexport declare function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY(): boolean;\nexport declare class MatDrawerContent extends CdkScrollable implements AfterContentInit {\n    private _changeDetectorRef;\n    _container: MatDrawerContainer;\n    constructor(_changeDetectorRef: ChangeDetectorRef, _container: MatDrawerContainer, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone);\n    ngAfterContentInit(): void;\n}\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nexport declare class MatDrawer implements AfterContentInit, AfterContentChecked, OnDestroy {\n    private _elementRef;\n    private _focusTrapFactory;\n    private _focusMonitor;\n    private _platform;\n    private _ngZone;\n    private _doc;\n    _container?: MatDrawerContainer | undefined;\n    private _focusTrap;\n    private _elementFocusedBeforeDrawerWasOpened;\n    /** Whether the drawer is initialized. Used for disabling the initial animation. */\n    private _enableAnimations;\n    /** The side that the drawer is attached to. */\n    get position(): 'start' | 'end';\n    set position(value: 'start' | 'end');\n    private _position;\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n    get mode(): MatDrawerMode;\n    set mode(value: MatDrawerMode);\n    private _mode;\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n    get disableClose(): boolean;\n    set disableClose(value: boolean);\n    private _disableClose;\n    /**\n     * Whether the drawer should focus the first focusable element automatically when opened.\n     * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n     * enabled, focus will be moved into the sidenav in `side` mode as well.\n     */\n    get autoFocus(): boolean;\n    set autoFocus(value: boolean);\n    private _autoFocus;\n    /**\n     * Whether the drawer is opened. We overload this because we trigger an event when it\n     * starts or end.\n     */\n    get opened(): boolean;\n    set opened(value: boolean);\n    private _opened;\n    /** How the sidenav was opened (keypress, mouse click etc.) */\n    private _openedVia;\n    /** Emits whenever the drawer has started animating. */\n    readonly _animationStarted: Subject<AnimationEvent>;\n    /** Emits whenever the drawer is done animating. */\n    readonly _animationEnd: Subject<AnimationEvent>;\n    /** Current state of the sidenav animation. */\n    _animationState: 'open-instant' | 'open' | 'void';\n    /** Event emitted when the drawer open state is changed. */\n    readonly openedChange: EventEmitter<boolean>;\n    /** Event emitted when the drawer has been opened. */\n    readonly _openedStream: Observable<void>;\n    /** Event emitted when the drawer has started opening. */\n    readonly openedStart: Observable<void>;\n    /** Event emitted when the drawer has been closed. */\n    readonly _closedStream: Observable<void>;\n    /** Event emitted when the drawer has started closing. */\n    readonly closedStart: Observable<void>;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    /** Event emitted when the drawer's position changes. */\n    readonly onPositionChanged: EventEmitter<void>;\n    /**\n     * An observable that emits when the drawer mode changes. This is used by the drawer container to\n     * to know when to when the mode changes so it can adapt the margins on the content.\n     */\n    readonly _modeChanged: Subject<void>;\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusTrapFactory: FocusTrapFactory, _focusMonitor: FocusMonitor, _platform: Platform, _ngZone: NgZone, _doc: any, _container?: MatDrawerContainer | undefined);\n    /**\n     * Moves focus into the drawer. Note that this works even if\n     * the focus trap is disabled in `side` mode.\n     */\n    private _takeFocus;\n    /**\n     * Restores focus to the element that was originally focused when the drawer opened.\n     * If no element was focused at that time, the focus will be restored to the drawer.\n     */\n    private _restoreFocus;\n    /** Whether focus is currently within the drawer. */\n    private _isFocusWithinDrawer;\n    ngAfterContentInit(): void;\n    ngAfterContentChecked(): void;\n    ngOnDestroy(): void;\n    /**\n     * Open the drawer.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    open(openedVia?: FocusOrigin): Promise<MatDrawerToggleResult>;\n    /** Close the drawer. */\n    close(): Promise<MatDrawerToggleResult>;\n    /** Closes the drawer with context that the backdrop was clicked. */\n    _closeViaBackdropClick(): Promise<MatDrawerToggleResult>;\n    /**\n     * Toggle this drawer.\n     * @param isOpen Whether the drawer should be open.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    toggle(isOpen?: boolean, openedVia?: FocusOrigin): Promise<MatDrawerToggleResult>;\n    /**\n     * Toggles the opened state of the drawer.\n     * @param isOpen Whether the drawer should open or close.\n     * @param restoreFocus Whether focus should be restored on close.\n     * @param openedVia Focus origin that can be optionally set when opening a drawer. The\n     *   origin will be used later when focus is restored on drawer close.\n     */\n    private _setOpen;\n    _getWidth(): number;\n    /** Updates the enabled state of the focus trap. */\n    private _updateFocusTrapState;\n    _animationStartListener(event: AnimationEvent): void;\n    _animationDoneListener(event: AnimationEvent): void;\n    static ngAcceptInputType_disableClose: BooleanInput;\n    static ngAcceptInputType_autoFocus: BooleanInput;\n    static ngAcceptInputType_opened: BooleanInput;\n}\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nexport declare class MatDrawerContainer implements AfterContentInit, DoCheck, OnDestroy {\n    private _dir;\n    private _element;\n    private _ngZone;\n    private _changeDetectorRef;\n    private _animationMode?;\n    /** All drawers in the container. Includes drawers from inside nested containers. */\n    _allDrawers: QueryList<MatDrawer>;\n    /** Drawers that belong to this container. */\n    _drawers: QueryList<MatDrawer>;\n    _content: MatDrawerContent;\n    _userContent: MatDrawerContent;\n    /** The drawer child with the `start` position. */\n    get start(): MatDrawer | null;\n    /** The drawer child with the `end` position. */\n    get end(): MatDrawer | null;\n    /**\n     * Whether to automatically resize the container whenever\n     * the size of any of its drawers changes.\n     *\n     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n     * the drawers on every change detection cycle. Can be configured globally via the\n     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n     */\n    get autosize(): boolean;\n    set autosize(value: boolean);\n    private _autosize;\n    /**\n     * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n     * mode as well.\n     */\n    get hasBackdrop(): any;\n    set hasBackdrop(value: any);\n    _backdropOverride: boolean | null;\n    /** Event emitted when the drawer backdrop is clicked. */\n    readonly backdropClick: EventEmitter<void>;\n    /** The drawer at the start/end position, independent of direction. */\n    private _start;\n    private _end;\n    /**\n     * The drawer at the left/right. When direction changes, these will change as well.\n     * They're used as aliases for the above to set the left/right style properly.\n     * In LTR, _left == _start and _right == _end.\n     * In RTL, _left == _end and _right == _start.\n     */\n    private _left;\n    private _right;\n    /** Emits when the component is destroyed. */\n    private readonly _destroyed;\n    /** Emits on every ngDoCheck. Used for debouncing reflows. */\n    private readonly _doCheckSubject;\n    /**\n     * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n     * drawer is open. We use margin rather than transform even for push mode because transform breaks\n     * fixed position elements inside of the transformed element.\n     */\n    _contentMargins: {\n        left: number | null;\n        right: number | null;\n    };\n    readonly _contentMarginChanges: Subject<{\n        left: number | null;\n        right: number | null;\n    }>;\n    /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n    get scrollable(): CdkScrollable;\n    constructor(_dir: Directionality, _element: ElementRef<HTMLElement>, _ngZone: NgZone, _changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, defaultAutosize?: boolean, _animationMode?: string | undefined);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Calls `open` of both start and end drawers */\n    open(): void;\n    /** Calls `close` of both start and end drawers */\n    close(): void;\n    /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     */\n    updateContentMargins(): void;\n    ngDoCheck(): void;\n    /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     */\n    private _watchDrawerToggle;\n    /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     */\n    private _watchDrawerPosition;\n    /** Subscribes to changes in drawer mode so we can run change detection. */\n    private _watchDrawerMode;\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n    private _setContainerClass;\n    /** Validate the state of the drawer children components. */\n    private _validateDrawers;\n    /** Whether the container is being pushed to the side by one of the drawers. */\n    private _isPushed;\n    _onBackdropClicked(): void;\n    _closeModalDrawersViaBackdrop(): void;\n    _isShowingBackdrop(): boolean;\n    private _canHaveBackdrop;\n    private _isDrawerOpen;\n    static ngAcceptInputType_autosize: BooleanInput;\n    static ngAcceptInputType_hasBackdrop: BooleanInput;\n}\n"]}