{"version":3,"file":"pagination-controls.directive.d.ts","sources":["pagination-controls.directive.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ChangeDetectorRef, EventEmitter } from '@angular/core';\r\nimport { PaginationService } from './pagination.service';\r\nexport interface Page {\r\n    label: string;\r\n    value: any;\r\n}\r\n/**\r\n * This directive is what powers all pagination controls components, including the default one.\r\n * It exposes an API which is hooked up to the PaginationService to keep the PaginatePipe in sync\r\n * with the pagination controls.\r\n */\r\nexport declare class PaginationControlsDirective {\r\n    private service;\r\n    private changeDetectorRef;\r\n    id: string;\r\n    maxSize: number;\r\n    pageChange: EventEmitter<number>;\r\n    pageBoundsCorrection: EventEmitter<number>;\r\n    pages: Page[];\r\n    private changeSub;\r\n    constructor(service: PaginationService, changeDetectorRef: ChangeDetectorRef);\r\n    ngOnInit(): void;\r\n    ngOnChanges(changes: any): void;\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Go to the previous page\r\n     */\r\n    previous(): void;\r\n    /**\r\n     * Go to the next page\r\n     */\r\n    next(): void;\r\n    /**\r\n     * Returns true if current page is first page\r\n     */\r\n    isFirstPage(): boolean;\r\n    /**\r\n     * Returns true if current page is last page\r\n     */\r\n    isLastPage(): boolean;\r\n    /**\r\n     * Set the current page number.\r\n     */\r\n    setCurrent(page: number): void;\r\n    /**\r\n     * Get the current page number.\r\n     */\r\n    getCurrent(): number;\r\n    /**\r\n     * Returns the last page number\r\n     */\r\n    getLastPage(): number;\r\n    getTotalItems(): number;\r\n    private checkValidId;\r\n    /**\r\n     * Updates the page links and checks that the current page is valid. Should run whenever the\r\n     * PaginationService.change stream emits a value matching the current ID, or when any of the\r\n     * input values changes.\r\n     */\r\n    private updatePageLinks;\r\n    /**\r\n     * Checks that the instance.currentPage property is within bounds for the current page range.\r\n     * If not, return a correct value for currentPage, or the current value if OK.\r\n     */\r\n    private outOfBoundCorrection;\r\n    /**\r\n     * Returns an array of Page objects to use in the pagination controls.\r\n     */\r\n    private createPageArray;\r\n    /**\r\n     * Given the position in the sequence of pagination links [i],\r\n     * figure out what page number corresponds to that position.\r\n     */\r\n    private calculatePageNumber;\r\n}\r\n"]}