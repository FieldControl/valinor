{"version":3,"file":"paginate.pipe.d.ts","sources":["paginate.pipe.d.ts"],"names":[],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { PaginationService } from \"./pagination.service\";\r\nexport declare type Collection<T> = T[] | ReadonlyArray<T>;\r\nexport interface PaginatePipeArgs {\r\n    id?: string;\r\n    itemsPerPage?: string | number;\r\n    currentPage?: string | number;\r\n    totalItems?: string | number;\r\n}\r\nexport interface PipeState {\r\n    collection: any[];\r\n    size: number;\r\n    start: number;\r\n    end: number;\r\n    slice: any[];\r\n}\r\nexport declare class PaginatePipe {\r\n    private service;\r\n    private state;\r\n    constructor(service: PaginationService);\r\n    transform<T, U extends Collection<T>>(collection: U, args: PaginatePipeArgs): U;\r\n    /**\r\n     * Create an PaginationInstance object, using defaults for any optional properties not supplied.\r\n     */\r\n    private createInstance;\r\n    /**\r\n     * Ensure the argument passed to the filter contains the required properties.\r\n     */\r\n    private checkConfig;\r\n    /**\r\n     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced\r\n     * array for a given id. This means that the next time the pipe is run on this collection & id, we just\r\n     * need to check that the collection, start and end points are all identical, and if so, return the\r\n     * last sliced array.\r\n     */\r\n    private saveState;\r\n    /**\r\n     * For a given id, returns true if the collection, size, start and end values are identical.\r\n     */\r\n    private stateIsIdentical;\r\n}\r\n"]}