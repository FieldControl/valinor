{"version":3,"file":"ast-utils.js","sourceRoot":"","sources":["../../../../../modules/operators/schematics-core/utility/ast-utils.ts"],"names":[],"mappings":"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","sourcesContent":["/* istanbul ignore file */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {\n  Change,\n  InsertChange,\n  NoopChange,\n  createReplaceChange,\n  ReplaceChange,\n  RemoveChange,\n  createRemoveChange,\n} from './change';\nimport { Path } from '@angular-devkit/core';\n\n/**\n * Find all nodes from the AST in the subtree of node of SyntaxKind kind.\n * @param node\n * @param kind\n * @param max The maximum number of items to return.\n * @return all nodes of kind, or [] if none is found\n */\nexport function findNodes(\n  node: ts.Node,\n  kind: ts.SyntaxKind,\n  max = Infinity\n): ts.Node[] {\n  if (!node || max == 0) {\n    return [];\n  }\n\n  const arr: ts.Node[] = [];\n  if (node.kind === kind) {\n    arr.push(node);\n    max--;\n  }\n  if (max > 0) {\n    for (const child of node.getChildren()) {\n      findNodes(child, kind, max).forEach((node) => {\n        if (max > 0) {\n          arr.push(node);\n        }\n        max--;\n      });\n\n      if (max <= 0) {\n        break;\n      }\n    }\n  }\n\n  return arr;\n}\n\n/**\n * Get all the nodes from a source.\n * @param sourceFile The source file object.\n * @returns {Observable<ts.Node>} An observable of all the nodes in the source.\n */\nexport function getSourceNodes(sourceFile: ts.SourceFile): ts.Node[] {\n  const nodes: ts.Node[] = [sourceFile];\n  const result = [];\n\n  while (nodes.length > 0) {\n    const node = nodes.shift();\n\n    if (node) {\n      result.push(node);\n      if (node.getChildCount(sourceFile) >= 0) {\n        nodes.unshift(...node.getChildren());\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Helper for sorting nodes.\n * @return function to sort nodes in increasing order of position in sourceFile\n */\nfunction nodesByPosition(first: ts.Node, second: ts.Node): number {\n  return first.pos - second.pos;\n}\n\n/**\n * Insert `toInsert` after the last occurence of `ts.SyntaxKind[nodes[i].kind]`\n * or after the last of occurence of `syntaxKind` if the last occurence is a sub child\n * of ts.SyntaxKind[nodes[i].kind] and save the changes in file.\n *\n * @param nodes insert after the last occurence of nodes\n * @param toInsert string to insert\n * @param file file to insert changes into\n * @param fallbackPos position to insert if toInsert happens to be the first occurence\n * @param syntaxKind the ts.SyntaxKind of the subchildren to insert after\n * @return Change instance\n * @throw Error if toInsert is first occurence but fall back is not set\n */\nexport function insertAfterLastOccurrence(\n  nodes: ts.Node[],\n  toInsert: string,\n  file: string,\n  fallbackPos: number,\n  syntaxKind?: ts.SyntaxKind\n): Change {\n  let lastItem = nodes.sort(nodesByPosition).pop();\n  if (!lastItem) {\n    throw new Error();\n  }\n  if (syntaxKind) {\n    lastItem = findNodes(lastItem, syntaxKind).sort(nodesByPosition).pop();\n  }\n  if (!lastItem && fallbackPos == undefined) {\n    throw new Error(\n      `tried to insert ${toInsert} as first occurence with no fallback position`\n    );\n  }\n  const lastItemPosition: number = lastItem ? lastItem.end : fallbackPos;\n\n  return new InsertChange(file, lastItemPosition, toInsert);\n}\n\nexport function getContentOfKeyLiteral(\n  _source: ts.SourceFile,\n  node: ts.Node\n): string | null {\n  if (node.kind == ts.SyntaxKind.Identifier) {\n    return (node as ts.Identifier).text;\n  } else if (node.kind == ts.SyntaxKind.StringLiteral) {\n    return (node as ts.StringLiteral).text;\n  } else {\n    return null;\n  }\n}\n\nfunction _angularImportsFromNode(\n  node: ts.ImportDeclaration,\n  _sourceFile: ts.SourceFile\n): { [name: string]: string } {\n  const ms = node.moduleSpecifier;\n  let modulePath: string;\n  switch (ms.kind) {\n    case ts.SyntaxKind.StringLiteral:\n      modulePath = (ms as ts.StringLiteral).text;\n      break;\n    default:\n      return {};\n  }\n\n  if (!modulePath.startsWith('@angular/')) {\n    return {};\n  }\n\n  if (node.importClause) {\n    if (node.importClause.name) {\n      // This is of the form `import Name from 'path'`. Ignore.\n      return {};\n    } else if (node.importClause.namedBindings) {\n      const nb = node.importClause.namedBindings;\n      if (nb.kind == ts.SyntaxKind.NamespaceImport) {\n        // This is of the form `import * as name from 'path'`. Return `name.`.\n        return {\n          [(nb as ts.NamespaceImport).name.text + '.']: modulePath,\n        };\n      } else {\n        // This is of the form `import {a,b,c} from 'path'`\n        const namedImports = nb as ts.NamedImports;\n\n        return namedImports.elements\n          .map((is: ts.ImportSpecifier) =>\n            is.propertyName ? is.propertyName.text : is.name.text\n          )\n          .reduce((acc: { [name: string]: string }, curr: string) => {\n            acc[curr] = modulePath;\n\n            return acc;\n          }, {});\n      }\n    }\n\n    return {};\n  } else {\n    // This is of the form `import 'path';`. Nothing to do.\n    return {};\n  }\n}\n\nexport function getDecoratorMetadata(\n  source: ts.SourceFile,\n  identifier: string,\n  module: string\n): ts.Node[] {\n  const angularImports: { [name: string]: string } = findNodes(\n    source,\n    ts.SyntaxKind.ImportDeclaration\n  )\n    .map((node) =>\n      _angularImportsFromNode(node as ts.ImportDeclaration, source)\n    )\n    .reduce(\n      (\n        acc: { [name: string]: string },\n        current: { [name: string]: string }\n      ) => {\n        for (const key of Object.keys(current)) {\n          acc[key] = current[key];\n        }\n\n        return acc;\n      },\n      {}\n    );\n\n  return getSourceNodes(source)\n    .filter((node) => {\n      return (\n        node.kind == ts.SyntaxKind.Decorator &&\n        (node as ts.Decorator).expression.kind == ts.SyntaxKind.CallExpression\n      );\n    })\n    .map((node) => (node as ts.Decorator).expression as ts.CallExpression)\n    .filter((expr) => {\n      if (expr.expression.kind == ts.SyntaxKind.Identifier) {\n        const id = expr.expression as ts.Identifier;\n\n        return (\n          id.getFullText(source) == identifier &&\n          angularImports[id.getFullText(source)] === module\n        );\n      } else if (\n        expr.expression.kind == ts.SyntaxKind.PropertyAccessExpression\n      ) {\n        // This covers foo.NgModule when importing * as foo.\n        const paExpr = expr.expression as ts.PropertyAccessExpression;\n        // If the left expression is not an identifier, just give up at that point.\n        if (paExpr.expression.kind !== ts.SyntaxKind.Identifier) {\n          return false;\n        }\n\n        const id = paExpr.name.text;\n        const moduleId = (paExpr.expression as ts.Identifier).getText(source);\n\n        return id === identifier && angularImports[moduleId + '.'] === module;\n      }\n\n      return false;\n    })\n    .filter(\n      (expr) =>\n        expr.arguments[0] &&\n        expr.arguments[0].kind == ts.SyntaxKind.ObjectLiteralExpression\n    )\n    .map((expr) => expr.arguments[0] as ts.ObjectLiteralExpression);\n}\n\nfunction _addSymbolToNgModuleMetadata(\n  source: ts.SourceFile,\n  ngModulePath: string,\n  metadataField: string,\n  symbolName: string,\n  importPath: string\n): Change[] {\n  const nodes = getDecoratorMetadata(source, 'NgModule', '@angular/core');\n  let node: any = nodes[0]; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  // Find the decorator declaration.\n  if (!node) {\n    return [];\n  }\n\n  // Get all the children property assignment of object literals.\n  const matchingProperties: ts.ObjectLiteralElement[] = (\n    node as ts.ObjectLiteralExpression\n  ).properties\n    .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)\n    // Filter out every fields that's not \"metadataField\". Also handles string literals\n    // (but not expressions).\n    .filter((prop: any) => {\n      const name = prop.name;\n      switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n          return (name as ts.Identifier).getText(source) == metadataField;\n        case ts.SyntaxKind.StringLiteral:\n          return (name as ts.StringLiteral).text == metadataField;\n      }\n\n      return false;\n    });\n\n  // Get the last node of the array literal.\n  if (!matchingProperties) {\n    return [];\n  }\n  if (matchingProperties.length == 0) {\n    // We haven't found the field in the metadata declaration. Insert a new field.\n    const expr = node as ts.ObjectLiteralExpression;\n    let position: number;\n    let toInsert: string;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      const matches = text.match(/^\\r?\\n\\s*/);\n      if (matches.length > 0) {\n        toInsert = `,${matches[0]}${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n    const newMetadataProperty = new InsertChange(\n      ngModulePath,\n      position,\n      toInsert\n    );\n    const newMetadataImport = insertImport(\n      source,\n      ngModulePath,\n      symbolName.replace(/\\..*$/, ''),\n      importPath\n    );\n\n    return [newMetadataProperty, newMetadataImport];\n  }\n\n  const assignment = matchingProperties[0] as ts.PropertyAssignment;\n\n  // If it's not an array, nothing we can do really.\n  if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n    return [];\n  }\n\n  const arrLiteral = assignment.initializer as ts.ArrayLiteralExpression;\n  if (arrLiteral.elements.length == 0) {\n    // Forward the property.\n    node = arrLiteral;\n  } else {\n    node = arrLiteral.elements;\n  }\n\n  if (!node) {\n    console.log(\n      'No app module found. Please add your new class to your component.'\n    );\n\n    return [];\n  }\n\n  if (Array.isArray(node)) {\n    const nodeArray = node as {} as Array<ts.Node>;\n    const symbolsArray = nodeArray.map((node) => node.getText());\n    if (symbolsArray.includes(symbolName)) {\n      return [];\n    }\n\n    node = node[node.length - 1];\n\n    const effectsModule = nodeArray.find(\n      (node) =>\n        (node.getText().includes('EffectsModule.forRoot') &&\n          symbolName.includes('EffectsModule.forRoot')) ||\n        (node.getText().includes('EffectsModule.forFeature') &&\n          symbolName.includes('EffectsModule.forFeature'))\n    );\n\n    if (effectsModule && symbolName.includes('EffectsModule')) {\n      const effectsArgs = (effectsModule as any).arguments.shift();\n\n      if (\n        effectsArgs &&\n        effectsArgs.kind === ts.SyntaxKind.ArrayLiteralExpression\n      ) {\n        const effectsElements = (effectsArgs as ts.ArrayLiteralExpression)\n          .elements;\n        const [, effectsSymbol] = (<any>symbolName).match(/\\[(.*)\\]/);\n\n        let epos;\n        if (effectsElements.length === 0) {\n          epos = effectsArgs.getStart() + 1;\n          return [new InsertChange(ngModulePath, epos, effectsSymbol)];\n        } else {\n          const lastEffect = effectsElements[\n            effectsElements.length - 1\n          ] as ts.Expression;\n          epos = lastEffect.getEnd();\n          // Get the indentation of the last element, if any.\n          const text: any = lastEffect.getFullText(source);\n\n          let effectInsert: string;\n          if (text.match('^\\r?\\r?\\n')) {\n            effectInsert = `,${text.match(/^\\r?\\n\\s+/)[0]}${effectsSymbol}`;\n          } else {\n            effectInsert = `, ${effectsSymbol}`;\n          }\n\n          return [new InsertChange(ngModulePath, epos, effectInsert)];\n        }\n      } else {\n        return [];\n      }\n    }\n  }\n\n  let toInsert: string;\n  let position = node.getEnd();\n  if (node.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n    // We haven't found the field in the metadata declaration. Insert a new\n    // field.\n    const expr = node as ts.ObjectLiteralExpression;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${\n          text.match(/^\\r?\\n\\s+/)[0]\n        }${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n  } else if (node.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n    // We found the field but it's empty. Insert it just before the `]`.\n    position--;\n    toInsert = `${symbolName}`;\n  } else {\n    // Get the indentation of the last element, if any.\n    const text = node.getFullText(source);\n    if (text.match(/^\\r?\\n/)) {\n      toInsert = `,${text.match(/^\\r?\\n(\\r?)\\s+/)[0]}${symbolName}`;\n    } else {\n      toInsert = `, ${symbolName}`;\n    }\n  }\n  const insert = new InsertChange(ngModulePath, position, toInsert);\n  const importInsert: Change = insertImport(\n    source,\n    ngModulePath,\n    symbolName.replace(/\\..*$/, ''),\n    importPath\n  );\n\n  return [insert, importInsert];\n}\n\nfunction _addSymbolToComponentMetadata(\n  source: ts.SourceFile,\n  componentPath: string,\n  metadataField: string,\n  symbolName: string,\n  importPath: string\n): Change[] {\n  const nodes = getDecoratorMetadata(source, 'Component', '@angular/core');\n  let node: any = nodes[0]; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  // Find the decorator declaration.\n  if (!node) {\n    return [];\n  }\n\n  // Get all the children property assignment of object literals.\n  const matchingProperties: ts.ObjectLiteralElement[] = (\n    node as ts.ObjectLiteralExpression\n  ).properties\n    .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)\n    // Filter out every fields that's not \"metadataField\". Also handles string literals\n    // (but not expressions).\n    .filter((prop: any) => {\n      const name = prop.name;\n      switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n          return (name as ts.Identifier).getText(source) == metadataField;\n        case ts.SyntaxKind.StringLiteral:\n          return (name as ts.StringLiteral).text == metadataField;\n      }\n\n      return false;\n    });\n\n  // Get the last node of the array literal.\n  if (!matchingProperties) {\n    return [];\n  }\n  if (matchingProperties.length == 0) {\n    // We haven't found the field in the metadata declaration. Insert a new field.\n    const expr = node as ts.ObjectLiteralExpression;\n    let position: number;\n    let toInsert: string;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      const matches = text.match(/^\\r?\\n\\s*/);\n      if (matches.length > 0) {\n        toInsert = `,${matches[0]}${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n    const newMetadataProperty = new InsertChange(\n      componentPath,\n      position,\n      toInsert\n    );\n    const newMetadataImport = insertImport(\n      source,\n      componentPath,\n      symbolName.replace(/\\..*$/, ''),\n      importPath\n    );\n\n    return [newMetadataProperty, newMetadataImport];\n  }\n\n  const assignment = matchingProperties[0] as ts.PropertyAssignment;\n\n  // If it's not an array, nothing we can do really.\n  if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n    return [];\n  }\n\n  const arrLiteral = assignment.initializer as ts.ArrayLiteralExpression;\n  if (arrLiteral.elements.length == 0) {\n    // Forward the property.\n    node = arrLiteral;\n  } else {\n    node = arrLiteral.elements;\n  }\n\n  if (!node) {\n    console.log(\n      'No component found. Please add your new class to your component.'\n    );\n\n    return [];\n  }\n\n  if (Array.isArray(node)) {\n    const nodeArray = node as {} as Array<ts.Node>;\n    const symbolsArray = nodeArray.map((node) => node.getText());\n    if (symbolsArray.includes(symbolName)) {\n      return [];\n    }\n\n    node = node[node.length - 1];\n  }\n\n  let toInsert: string;\n  let position = node.getEnd();\n  if (node.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n    // We haven't found the field in the metadata declaration. Insert a new\n    // field.\n    const expr = node as ts.ObjectLiteralExpression;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${symbolName}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${\n          text.match(/^\\r?\\n\\s+/)[0]\n        }${metadataField}: [${symbolName}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${symbolName}]`;\n      }\n    }\n  } else if (node.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n    // We found the field but it's empty. Insert it just before the `]`.\n    position--;\n    toInsert = `${symbolName}`;\n  } else {\n    // Get the indentation of the last element, if any.\n    const text = node.getFullText(source);\n    if (text.match(/^\\r?\\n/)) {\n      toInsert = `,${text.match(/^\\r?\\n(\\r?)\\s+/)[0]}${symbolName}`;\n    } else {\n      toInsert = `, ${symbolName}`;\n    }\n  }\n  const insert = new InsertChange(componentPath, position, toInsert);\n  const importInsert: Change = insertImport(\n    source,\n    componentPath,\n    symbolName.replace(/\\..*$/, ''),\n    importPath\n  );\n\n  return [insert, importInsert];\n}\n\n/**\n * Custom function to insert a declaration (component, pipe, directive)\n * into NgModule declarations. It also imports the component.\n */\nexport function addDeclarationToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'declarations',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert a declaration (component, pipe, directive)\n * into NgModule declarations. It also imports the component.\n */\nexport function addImportToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'imports',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert a provider into NgModule. It also imports it.\n */\nexport function addProviderToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'providers',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert a provider into Component. It also imports it.\n */\nexport function addProviderToComponent(\n  source: ts.SourceFile,\n  componentPath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToComponentMetadata(\n    source,\n    componentPath,\n    'providers',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert an export into NgModule. It also imports it.\n */\nexport function addExportToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'exports',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Custom function to insert an export into NgModule. It also imports it.\n */\nexport function addBootstrapToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  classifiedName: string,\n  importPath: string\n): Change[] {\n  return _addSymbolToNgModuleMetadata(\n    source,\n    modulePath,\n    'bootstrap',\n    classifiedName,\n    importPath\n  );\n}\n\n/**\n * Add Import `import { symbolName } from fileName` if the import doesn't exit\n * already. Assumes fileToEdit can be resolved and accessed.\n * @param fileToEdit (file we want to add import to)\n * @param symbolName (item to import)\n * @param fileName (path to the file)\n * @param isDefault (if true, import follows style for importing default exports)\n * @return Change\n */\n\nexport function insertImport(\n  source: ts.SourceFile,\n  fileToEdit: string,\n  symbolName: string,\n  fileName: string,\n  isDefault = false\n): Change {\n  const rootNode = source;\n  const allImports = findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);\n\n  // get nodes that map to import statements from the file fileName\n  const relevantImports = allImports.filter((node) => {\n    // StringLiteral of the ImportDeclaration is the import file (fileName in this case).\n    const importFiles = node\n      .getChildren()\n      .filter((child) => child.kind === ts.SyntaxKind.StringLiteral)\n      .map((n) => (n as ts.StringLiteral).text);\n\n    return importFiles.filter((file) => file === fileName).length === 1;\n  });\n\n  if (relevantImports.length > 0) {\n    let importsAsterisk = false;\n    // imports from import file\n    const imports: ts.Node[] = [];\n    relevantImports.forEach((n) => {\n      Array.prototype.push.apply(\n        imports,\n        findNodes(n, ts.SyntaxKind.Identifier)\n      );\n      if (findNodes(n, ts.SyntaxKind.AsteriskToken).length > 0) {\n        importsAsterisk = true;\n      }\n    });\n\n    // if imports * from fileName, don't add symbolName\n    if (importsAsterisk) {\n      return new NoopChange();\n    }\n\n    const importTextNodes = imports.filter(\n      (n) => (n as ts.Identifier).text === symbolName\n    );\n\n    // insert import if it's not there\n    if (importTextNodes.length === 0) {\n      const fallbackPos =\n        findNodes(\n          relevantImports[0],\n          ts.SyntaxKind.CloseBraceToken\n        )[0].getStart() ||\n        findNodes(relevantImports[0], ts.SyntaxKind.FromKeyword)[0].getStart();\n\n      return insertAfterLastOccurrence(\n        imports,\n        `, ${symbolName}`,\n        fileToEdit,\n        fallbackPos\n      );\n    }\n\n    return new NoopChange();\n  }\n\n  // no such import declaration exists\n  const useStrict = findNodes(rootNode, ts.SyntaxKind.StringLiteral).filter(\n    (n) => n.getText() === 'use strict'\n  );\n  let fallbackPos = 0;\n  if (useStrict.length > 0) {\n    fallbackPos = useStrict[0].end;\n  }\n  const open = isDefault ? '' : '{ ';\n  const close = isDefault ? '' : ' }';\n  // if there are no imports or 'use strict' statement, insert import at beginning of file\n  const insertAtBeginning = allImports.length === 0 && useStrict.length === 0;\n  const separator = insertAtBeginning ? '' : ';\\n';\n  const toInsert =\n    `${separator}import ${open}${symbolName}${close}` +\n    ` from '${fileName}'${insertAtBeginning ? ';\\n' : ''}`;\n\n  return insertAfterLastOccurrence(\n    allImports,\n    toInsert,\n    fileToEdit,\n    fallbackPos,\n    ts.SyntaxKind.StringLiteral\n  );\n}\n\nexport function replaceImport(\n  sourceFile: ts.SourceFile,\n  path: Path,\n  importFrom: string,\n  importAsIs: string,\n  importToBe: string\n): (ReplaceChange | RemoveChange)[] {\n  const imports = sourceFile.statements\n    .filter(ts.isImportDeclaration)\n    .filter(\n      ({ moduleSpecifier }) =>\n        moduleSpecifier.getText(sourceFile) === `'${importFrom}'` ||\n        moduleSpecifier.getText(sourceFile) === `\"${importFrom}\"`\n    );\n\n  if (imports.length === 0) {\n    return [];\n  }\n\n  const importText = (specifier: ts.ImportSpecifier) => {\n    if (specifier.name.text) {\n      return specifier.name.text;\n    }\n\n    // if import is renamed\n    if (specifier.propertyName && specifier.propertyName.text) {\n      return specifier.propertyName.text;\n    }\n\n    return '';\n  };\n\n  const changes = imports.map((p) => {\n    const namedImports = p?.importClause?.namedBindings as ts.NamedImports;\n    if (!namedImports) {\n      return [];\n    }\n\n    const importSpecifiers = namedImports.elements;\n    const isAlreadyImported = importSpecifiers\n      .map(importText)\n      .includes(importToBe);\n\n    const importChanges = importSpecifiers.map((specifier, index) => {\n      const text = importText(specifier);\n\n      // import is not the one we're looking for, can be skipped\n      if (text !== importAsIs) {\n        return undefined;\n      }\n\n      // identifier has not been imported, simply replace the old text with the new text\n      if (!isAlreadyImported) {\n        return createReplaceChange(\n          sourceFile,\n          specifier,\n          importAsIs,\n          importToBe\n        );\n      }\n\n      const nextIdentifier = importSpecifiers[index + 1];\n      // identifer is not the last, also clean up the comma\n      if (nextIdentifier) {\n        return createRemoveChange(\n          sourceFile,\n          specifier,\n          specifier.getStart(sourceFile),\n          nextIdentifier.getStart(sourceFile)\n        );\n      }\n\n      // there are no imports following, just remove it\n      return createRemoveChange(\n        sourceFile,\n        specifier,\n        specifier.getStart(sourceFile),\n        specifier.getEnd()\n      );\n    });\n\n    return importChanges.filter(Boolean) as (ReplaceChange | RemoveChange)[];\n  });\n\n  return changes.reduce((imports, curr) => imports.concat(curr), []);\n}\n\nexport function containsProperty(\n  objectLiteral: ts.ObjectLiteralExpression,\n  propertyName: string\n) {\n  return (\n    objectLiteral &&\n    objectLiteral.properties.some(\n      (prop) =>\n        ts.isPropertyAssignment(prop) &&\n        ts.isIdentifier(prop.name) &&\n        prop.name.text === propertyName\n    )\n  );\n}\n"]}