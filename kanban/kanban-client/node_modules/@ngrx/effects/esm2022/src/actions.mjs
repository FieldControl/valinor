import { Inject, Injectable } from '@angular/core';
import { ScannedActionsSubject, } from '@ngrx/store';
import { Observable } from 'rxjs';
import { filter } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "rxjs";
export class Actions extends Observable {
    constructor(source) {
        super();
        if (source) {
            this.source = source;
        }
    }
    lift(operator) {
        const observable = new Actions();
        observable.source = this;
        observable.operator = operator;
        return observable;
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: Actions, deps: [{ token: ScannedActionsSubject }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: Actions, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: Actions, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.Observable, decorators: [{
                    type: Inject,
                    args: [ScannedActionsSubject]
                }] }] });
/**
 * `ofType` filters an Observable of `Actions` into an Observable of the actions
 * whose type strings are passed to it.
 *
 * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and
 * the type of the `Addition` action is `add`, then
 * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.
 *
 * Properly typing this function is hard and requires some advanced TS tricks
 * below.
 *
 * Type narrowing automatically works, as long as your `actions` object
 * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.
 *
 * For backwards compatibility, when one passes a single type argument
 * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`
 * completely overrides any possible inference from 'something'.
 *
 * Unfortunately, for unknown 'actions: Actions' these types will produce
 * 'Observable<never>'. In such cases one has to manually set the generic type
 * like `actions.ofType<AdditionAction>('add')`.
 *
 * @usageNotes
 *
 * Filter the Actions stream on the "customers page loaded" action
 *
 * ```ts
 * import { ofType } from '@ngrx/effects';
 * import * fromCustomers from '../customers';
 *
 * this.actions$.pipe(
 *  ofType(fromCustomers.pageLoaded)
 * )
 * ```
 */
export function ofType(...allowedTypes) {
    return filter((action) => allowedTypes.some((typeOrActionCreator) => {
        if (typeof typeOrActionCreator === 'string') {
            // Comparing the string to type
            return typeOrActionCreator === action.type;
        }
        // We are filtering by ActionCreator
        return typeOrActionCreator.type === action.type;
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL21vZHVsZXMvZWZmZWN0cy9zcmMvYWN0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBSUwscUJBQXFCLEdBQ3RCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxVQUFVLEVBQThCLE1BQU0sTUFBTSxDQUFDO0FBQzlELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBR3hDLE1BQU0sT0FBTyxPQUFvQixTQUFRLFVBQWE7SUFDcEQsWUFBMkMsTUFBc0I7UUFDL0QsS0FBSyxFQUFFLENBQUM7UUFFUixJQUFJLE1BQU0sRUFBRSxDQUFDO1lBQ1gsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDdkIsQ0FBQztJQUNILENBQUM7SUFFUSxJQUFJLENBQUksUUFBd0I7UUFDdkMsTUFBTSxVQUFVLEdBQUcsSUFBSSxPQUFPLEVBQUssQ0FBQztRQUNwQyxVQUFVLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztRQUN6QixVQUFVLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUMvQixPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO2lJQWRVLE9BQU8sa0JBQ0UscUJBQXFCO3FJQUQ5QixPQUFPLGNBRE0sTUFBTTs7MkZBQ25CLE9BQU87a0JBRG5CLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzswQkFFbkIsTUFBTTsyQkFBQyxxQkFBcUI7O0FBcUYzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtDRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQ3BCLEdBQUcsWUFBNEQ7SUFFL0QsT0FBTyxNQUFNLENBQUMsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUMvQixZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsbUJBQW1CLEVBQUUsRUFBRTtRQUN4QyxJQUFJLE9BQU8sbUJBQW1CLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDNUMsK0JBQStCO1lBQy9CLE9BQU8sbUJBQW1CLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQztRQUM3QyxDQUFDO1FBRUQsb0NBQW9DO1FBQ3BDLE9BQU8sbUJBQW1CLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUM7SUFDbEQsQ0FBQyxDQUFDLENBQ0gsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEFjdGlvbixcbiAgQWN0aW9uQ3JlYXRvcixcbiAgQ3JlYXRvcixcbiAgU2Nhbm5lZEFjdGlvbnNTdWJqZWN0LFxufSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPcGVyYXRvckZ1bmN0aW9uLCBPcGVyYXRvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEFjdGlvbnM8ViA9IEFjdGlvbj4gZXh0ZW5kcyBPYnNlcnZhYmxlPFY+IHtcbiAgY29uc3RydWN0b3IoQEluamVjdChTY2FubmVkQWN0aW9uc1N1YmplY3QpIHNvdXJjZT86IE9ic2VydmFibGU8Vj4pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICB9XG5cbiAgb3ZlcnJpZGUgbGlmdDxSPihvcGVyYXRvcjogT3BlcmF0b3I8ViwgUj4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgICBjb25zdCBvYnNlcnZhYmxlID0gbmV3IEFjdGlvbnM8Uj4oKTtcbiAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICB9XG59XG5cbi8vIE1vZHVsZS1wcml2YXRlIGhlbHBlciB0eXBlXG50eXBlIEFjdGlvbkV4dHJhY3RvcjxcbiAgVCBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgRVxuPiA9IFQgZXh0ZW5kcyBzdHJpbmcgPyBFIDogUmV0dXJuVHlwZTxFeHRyYWN0PFQsIEFDPj47XG5cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8XG4gIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+W10sXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBSZXR1cm5UeXBlPEFDW251bWJlcl0+XG4+KC4uLmFsbG93ZWRUeXBlczogQUMpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuXG5leHBvcnQgZnVuY3Rpb24gb2ZUeXBlPFxuICBFIGV4dGVuZHMgRXh0cmFjdDxVLCB7IHR5cGU6IFQxIH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IFQxIGV4dGVuZHMgc3RyaW5nID8gRSA6IFJldHVyblR5cGU8RXh0cmFjdDxUMSwgQUM+PlxuPih0MTogVDEpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyLCBBQywgRT5cbj4odDE6IFQxLCB0MjogVDIpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIHwgVDMgfT4sXG4gIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LFxuICBUMSBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUMiBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBUMyBleHRlbmRzIHN0cmluZyB8IEFDLFxuICBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLFxuICBWID0gQWN0aW9uRXh0cmFjdG9yPFQxIHwgVDIgfCBUMywgQUMsIEU+XG4+KHQxOiBUMSwgdDI6IFQyLCB0MzogVDMpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIHwgVDMgfCBUNCB9PixcbiAgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sXG4gIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQyIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQzIGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFQ0IGV4dGVuZHMgc3RyaW5nIHwgQUMsXG4gIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sXG4gIFYgPSBBY3Rpb25FeHRyYWN0b3I8VDEgfCBUMiB8IFQzIHwgVDQsIEFDLCBFPlxuPih0MTogVDEsIHQyOiBUMiwgdDM6IFQzLCB0NDogVDQpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9mVHlwZTxcbiAgRSBleHRlbmRzIEV4dHJhY3Q8VSwgeyB0eXBlOiBUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1IH0+LFxuICBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPixcbiAgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDMgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDQgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVDUgZXh0ZW5kcyBzdHJpbmcgfCBBQyxcbiAgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbixcbiAgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1LCBBQywgRT5cbj4odDE6IFQxLCB0MjogVDIsIHQzOiBUMywgdDQ6IFQ0LCB0NTogVDUpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuLyoqXG4gKiBGYWxsYmFjayBmb3IgbW9yZSB0aGFuIDUgYXJndW1lbnRzLlxuICogVGhlcmUgaXMgbm8gaW5mZXJlbmNlLCBzbyB0aGUgcmV0dXJuIHR5cGUgaXMgdGhlIHNhbWUgYXMgdGhlIGlucHV0IC1cbiAqIE9ic2VydmFibGU8QWN0aW9uPi5cbiAqXG4gKiBXZSBwcm92aWRlIGEgdHlwZSBwYXJhbWV0ZXIsIGV2ZW4gdGhvdWdoIFRTIHdpbGwgbm90IGluZmVyIGl0IGZyb20gdGhlXG4gKiBhcmd1bWVudHMsIHRvIHByZXNlcnZlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIHZlcnNpb25zIG9mIG5ncnguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGU8ViBleHRlbmRzIEFjdGlvbj4oXG4gIC4uLmFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nIHwgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+PlxuKTogT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIFY+O1xuLyoqXG4gKiBgb2ZUeXBlYCBmaWx0ZXJzIGFuIE9ic2VydmFibGUgb2YgYEFjdGlvbnNgIGludG8gYW4gT2JzZXJ2YWJsZSBvZiB0aGUgYWN0aW9uc1xuICogd2hvc2UgdHlwZSBzdHJpbmdzIGFyZSBwYXNzZWQgdG8gaXQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBhY3Rpb25zYCBoYXMgdHlwZSBgQWN0aW9uczxBZGRpdGlvbkFjdGlvbnxTdWJzdHJhY3Rpb25BY3Rpb24+YCwgYW5kXG4gKiB0aGUgdHlwZSBvZiB0aGUgYEFkZGl0aW9uYCBhY3Rpb24gaXMgYGFkZGAsIHRoZW5cbiAqIGBhY3Rpb25zLnBpcGUob2ZUeXBlKCdhZGQnKSlgIHJldHVybnMgYW4gYE9ic2VydmFibGU8QWRkaXRpb25BY3Rpb24+YC5cbiAqXG4gKiBQcm9wZXJseSB0eXBpbmcgdGhpcyBmdW5jdGlvbiBpcyBoYXJkIGFuZCByZXF1aXJlcyBzb21lIGFkdmFuY2VkIFRTIHRyaWNrc1xuICogYmVsb3cuXG4gKlxuICogVHlwZSBuYXJyb3dpbmcgYXV0b21hdGljYWxseSB3b3JrcywgYXMgbG9uZyBhcyB5b3VyIGBhY3Rpb25zYCBvYmplY3RcbiAqIHN0YXJ0cyB3aXRoIGEgYEFjdGlvbnM8U29tZVVuaW9uT2ZBY3Rpb25zPmAgaW5zdGVhZCBvZiBnZW5lcmljIGBBY3Rpb25zYC5cbiAqXG4gKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdoZW4gb25lIHBhc3NlcyBhIHNpbmdsZSB0eXBlIGFyZ3VtZW50XG4gKiBgb2ZUeXBlPFQ+KCdzb21ldGhpbmcnKWAgdGhlIHJlc3VsdCBpcyBhbiBgT2JzZXJ2YWJsZTxUPmAuIE5vdGUsIHRoYXQgYFRgXG4gKiBjb21wbGV0ZWx5IG92ZXJyaWRlcyBhbnkgcG9zc2libGUgaW5mZXJlbmNlIGZyb20gJ3NvbWV0aGluZycuXG4gKlxuICogVW5mb3J0dW5hdGVseSwgZm9yIHVua25vd24gJ2FjdGlvbnM6IEFjdGlvbnMnIHRoZXNlIHR5cGVzIHdpbGwgcHJvZHVjZVxuICogJ09ic2VydmFibGU8bmV2ZXI+Jy4gSW4gc3VjaCBjYXNlcyBvbmUgaGFzIHRvIG1hbnVhbGx5IHNldCB0aGUgZ2VuZXJpYyB0eXBlXG4gKiBsaWtlIGBhY3Rpb25zLm9mVHlwZTxBZGRpdGlvbkFjdGlvbj4oJ2FkZCcpYC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIEZpbHRlciB0aGUgQWN0aW9ucyBzdHJlYW0gb24gdGhlIFwiY3VzdG9tZXJzIHBhZ2UgbG9hZGVkXCIgYWN0aW9uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuICogaW1wb3J0ICogZnJvbUN1c3RvbWVycyBmcm9tICcuLi9jdXN0b21lcnMnO1xuICpcbiAqIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICBvZlR5cGUoZnJvbUN1c3RvbWVycy5wYWdlTG9hZGVkKVxuICogKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZlR5cGUoXG4gIC4uLmFsbG93ZWRUeXBlczogQXJyYXk8c3RyaW5nIHwgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+PlxuKTogT3BlcmF0b3JGdW5jdGlvbjxBY3Rpb24sIEFjdGlvbj4ge1xuICByZXR1cm4gZmlsdGVyKChhY3Rpb246IEFjdGlvbikgPT5cbiAgICBhbGxvd2VkVHlwZXMuc29tZSgodHlwZU9yQWN0aW9uQ3JlYXRvcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBDb21wYXJpbmcgdGhlIHN0cmluZyB0byB0eXBlXG4gICAgICAgIHJldHVybiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBhY3Rpb24udHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXJlIGZpbHRlcmluZyBieSBBY3Rpb25DcmVhdG9yXG4gICAgICByZXR1cm4gdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlID09PSBhY3Rpb24udHlwZTtcbiAgICB9KVxuICApO1xufVxuIl19