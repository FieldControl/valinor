{
  "version": 3,
  "sources": ["../../../../../../../../packages/core/schematics/migrations/http-providers/index.ts", "../../../../../../../../packages/core/schematics/utils/project_tsconfig_paths.ts", "../../../../../../../../packages/core/schematics/utils/typescript/compiler_host.ts", "../../../../../../../../packages/core/schematics/utils/typescript/parse_tsconfig.ts", "../../../../../../../../packages/core/schematics/migrations/http-providers/utils.ts", "../../../../../../../../packages/core/schematics/utils/change_tracker.ts", "../../../../../../../../packages/core/schematics/utils/import_manager.ts", "../../../../../../../../packages/core/schematics/utils/typescript/decorators.ts", "../../../../../../../../packages/core/schematics/utils/typescript/imports.ts", "../../../../../../../../packages/core/schematics/utils/ng_decorators.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Rule, SchematicsException, Tree, UpdateRecorder} from '@angular-devkit/schematics';\nimport {relative} from 'path';\n\nimport {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\nimport {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n\nimport {migrateFile} from './utils';\n\nexport default function (): Rule {\n  return async (tree: Tree) => {\n    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n    const basePath = process.cwd();\n    const allPaths = [...buildPaths, ...testPaths];\n\n    if (!allPaths.length) {\n      throw new SchematicsException(\n        'Could not find any tsconfig file. Cannot run the http providers migration.',\n      );\n    }\n\n    for (const tsconfigPath of allPaths) {\n      runMigration(tree, tsconfigPath, basePath);\n    }\n  };\n}\n\nfunction runMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n  const program = createMigrationProgram(tree, tsconfigPath, basePath);\n  const sourceFiles = program\n    .getSourceFiles()\n    .filter((sourceFile) => canMigrateFile(basePath, sourceFile, program));\n\n  for (const sourceFile of sourceFiles) {\n    let update: UpdateRecorder | null = null;\n\n    const rewriter = (startPos: number, width: number, text: string | null) => {\n      if (update === null) {\n        // Lazily initialize update, because most files will not require migration.\n        update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n      }\n      update.remove(startPos, width);\n      if (text !== null) {\n        update.insertLeft(startPos, text);\n      }\n    };\n    migrateFile(sourceFile, program.getTypeChecker(), rewriter);\n\n    if (update !== null) {\n      tree.commitUpdate(update);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {json, normalize, virtualFs, workspaces} from '@angular-devkit/core';\nimport {Tree} from '@angular-devkit/schematics';\n\n/**\n * Gets all tsconfig paths from a CLI project by reading the workspace configuration\n * and looking for common tsconfig locations.\n */\nexport async function getProjectTsConfigPaths(\n  tree: Tree,\n): Promise<{buildPaths: string[]; testPaths: string[]}> {\n  // Start with some tsconfig paths that are generally used within CLI projects. Note\n  // that we are not interested in IDE-specific tsconfig files (e.g. /tsconfig.json)\n  const buildPaths = new Set<string>();\n  const testPaths = new Set<string>();\n\n  const workspace = await getWorkspace(tree);\n  for (const [, project] of workspace.projects) {\n    for (const [name, target] of project.targets) {\n      if (name !== 'build' && name !== 'test') {\n        continue;\n      }\n\n      for (const [, options] of allTargetOptions(target)) {\n        const tsConfig = options['tsConfig'];\n        // Filter out tsconfig files that don't exist in the CLI project.\n        if (typeof tsConfig !== 'string' || !tree.exists(tsConfig)) {\n          continue;\n        }\n\n        if (name === 'build') {\n          buildPaths.add(normalize(tsConfig));\n        } else {\n          testPaths.add(normalize(tsConfig));\n        }\n      }\n    }\n  }\n\n  return {\n    buildPaths: [...buildPaths],\n    testPaths: [...testPaths],\n  };\n}\n\n/** Get options for all configurations for the passed builder target. */\nfunction* allTargetOptions(\n  target: workspaces.TargetDefinition,\n): Iterable<[string | undefined, Record<string, json.JsonValue | undefined>]> {\n  if (target.options) {\n    yield [undefined, target.options];\n  }\n\n  if (!target.configurations) {\n    return;\n  }\n\n  for (const [name, options] of Object.entries(target.configurations)) {\n    if (options) {\n      yield [name, options];\n    }\n  }\n}\n\nfunction createHost(tree: Tree): workspaces.WorkspaceHost {\n  return {\n    async readFile(path: string): Promise<string> {\n      const data = tree.read(path);\n      if (!data) {\n        throw new Error('File not found.');\n      }\n\n      return virtualFs.fileBufferToString(data);\n    },\n    async writeFile(path: string, data: string): Promise<void> {\n      return tree.overwrite(path, data);\n    },\n    async isDirectory(path: string): Promise<boolean> {\n      // Approximate a directory check.\n      // We don't need to consider empty directories and hence this is a good enough approach.\n      // This is also per documentation, see:\n      // https://angular.dev/tools/cli/schematics-for-libraries#get-the-project-configuration\n      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;\n    },\n    async isFile(path: string): Promise<boolean> {\n      return tree.exists(path);\n    },\n  };\n}\n\nasync function getWorkspace(tree: Tree): Promise<workspaces.WorkspaceDefinition> {\n  const host = createHost(tree);\n  const {workspace} = await workspaces.readWorkspace('/', host);\n\n  return workspace;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Tree} from '@angular-devkit/schematics';\nimport {dirname, relative, resolve} from 'path';\nimport ts from 'typescript';\n\nimport {parseTsconfigFile} from './parse_tsconfig';\n\ntype FakeReadFileFn = (fileName: string) => string | undefined;\n\n/**\n * Creates a TypeScript program instance for a TypeScript project within\n * the virtual file system tree.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n */\nexport function createMigrationProgram(\n  tree: Tree,\n  tsconfigPath: string,\n  basePath: string,\n  fakeFileRead?: FakeReadFileFn,\n  additionalFiles?: string[],\n) {\n  const {rootNames, options, host} = createProgramOptions(\n    tree,\n    tsconfigPath,\n    basePath,\n    fakeFileRead,\n    additionalFiles,\n  );\n  return ts.createProgram(rootNames, options, host);\n}\n\n/**\n * Creates the options necessary to instantiate a TypeScript program.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n * @param optionOverrides Overrides of the parsed compiler options.\n */\nexport function createProgramOptions(\n  tree: Tree,\n  tsconfigPath: string,\n  basePath: string,\n  fakeFileRead?: FakeReadFileFn,\n  additionalFiles?: string[],\n  optionOverrides?: ts.CompilerOptions,\n) {\n  // Resolve the tsconfig path to an absolute path. This is needed as TypeScript otherwise\n  // is not able to resolve root directories in the given tsconfig. More details can be found\n  // in the following issue: https://github.com/microsoft/TypeScript/issues/37731.\n  tsconfigPath = resolve(basePath, tsconfigPath);\n  const parsed = parseTsconfigFile(tsconfigPath, dirname(tsconfigPath));\n  const options = optionOverrides ? {...parsed.options, ...optionOverrides} : parsed.options;\n  const host = createMigrationCompilerHost(tree, options, basePath, fakeFileRead);\n  return {rootNames: parsed.fileNames.concat(additionalFiles || []), options, host};\n}\n\nfunction createMigrationCompilerHost(\n  tree: Tree,\n  options: ts.CompilerOptions,\n  basePath: string,\n  fakeRead?: FakeReadFileFn,\n): ts.CompilerHost {\n  const host = ts.createCompilerHost(options, true);\n  const defaultReadFile = host.readFile;\n\n  // We need to overwrite the host \"readFile\" method, as we want the TypeScript\n  // program to be based on the file contents in the virtual file tree. Otherwise\n  // if we run multiple migrations we might have intersecting changes and\n  // source files.\n  host.readFile = (fileName) => {\n    const treeRelativePath = relative(basePath, fileName);\n    let result: string | undefined = fakeRead?.(treeRelativePath);\n\n    if (typeof result !== 'string') {\n      // If the relative path resolved to somewhere outside of the tree, fall back to\n      // TypeScript's default file reading function since the `tree` will throw an error.\n      result = treeRelativePath.startsWith('..')\n        ? defaultReadFile.call(host, fileName)\n        : tree.read(treeRelativePath)?.toString();\n    }\n\n    // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset,\n    // which breaks the CLI UpdateRecorder.\n    // See: https://github.com/angular/angular/pull/30719\n    return typeof result === 'string' ? result.replace(/^\\uFEFF/, '') : undefined;\n  };\n\n  return host;\n}\n\n/**\n * Checks whether a file can be migrate by our automated migrations.\n * @param basePath Absolute path to the project.\n * @param sourceFile File being checked.\n * @param program Program that includes the source file.\n */\nexport function canMigrateFile(\n  basePath: string,\n  sourceFile: ts.SourceFile,\n  program: ts.Program,\n): boolean {\n  // We shouldn't migrate .d.ts files, files from an external library or type checking files.\n  if (\n    sourceFile.fileName.endsWith('.ngtypecheck.ts') ||\n    sourceFile.isDeclarationFile ||\n    program.isSourceFileFromExternalLibrary(sourceFile)\n  ) {\n    return false;\n  }\n\n  // Our migrations are set up to create a `Program` from the project's tsconfig and to migrate all\n  // the files within the program. This can include files that are outside of the Angular CLI\n  // project. We can't migrate files outside of the project, because our file system interactions\n  // go through the CLI's `Tree` which assumes that all files are within the project. See:\n  // https://github.com/angular/angular-cli/blob/0b0961c9c233a825b6e4bb59ab7f0790f9b14676/packages/angular_devkit/schematics/src/tree/host-tree.ts#L131\n  return !relative(basePath, sourceFile.fileName).startsWith('..');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport ts from 'typescript';\n\nexport function parseTsconfigFile(tsconfigPath: string, basePath: string): ts.ParsedCommandLine {\n  const {config} = ts.readConfigFile(tsconfigPath, ts.sys.readFile);\n  const parseConfigHost = {\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n    fileExists: ts.sys.fileExists,\n    readDirectory: ts.sys.readDirectory,\n    readFile: ts.sys.readFile,\n  };\n\n  // Throw if incorrect arguments are passed to this function. Passing relative base paths\n  // results in root directories not being resolved and in later type checking runtime errors.\n  // More details can be found here: https://github.com/microsoft/TypeScript/issues/37731.\n  if (!path.isAbsolute(basePath)) {\n    throw Error('Unexpected relative base path has been specified.');\n  }\n\n  return ts.parseJsonConfigFileContent(config, parseConfigHost, basePath, {});\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ChangeTracker} from '../../utils/change_tracker';\nimport {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\nimport {getImportSpecifiers, getNamedImports} from '../../utils/typescript/imports';\n\nconst HTTP_CLIENT_MODULE = 'HttpClientModule';\nconst HTTP_CLIENT_XSRF_MODULE = 'HttpClientXsrfModule';\nconst HTTP_CLIENT_JSONP_MODULE = 'HttpClientJsonpModule';\nconst HTTP_CLIENT_TESTING_MODULE = 'HttpClientTestingModule';\nconst WITH_INTERCEPTORS_FROM_DI = 'withInterceptorsFromDi';\nconst WITH_JSONP_SUPPORT = 'withJsonpSupport';\nconst WITH_NOXSRF_PROTECTION = 'withNoXsrfProtection';\nconst WITH_XSRF_CONFIGURATION = 'withXsrfConfiguration';\nconst PROVIDE_HTTP_CLIENT = 'provideHttpClient';\nconst PROVIDE_HTTP_CLIENT_TESTING = 'provideHttpClientTesting';\n\nconst COMMON_HTTP = '@angular/common/http';\nconst COMMON_HTTP_TESTING = '@angular/common/http/testing';\n\nconst HTTP_MODULES = new Set([\n  HTTP_CLIENT_MODULE,\n  HTTP_CLIENT_XSRF_MODULE,\n  HTTP_CLIENT_JSONP_MODULE,\n]);\nconst HTTP_TESTING_MODULES = new Set([HTTP_CLIENT_TESTING_MODULE]);\n\nexport type RewriteFn = (startPos: number, width: number, text: string) => void;\n\nexport function migrateFile(\n  sourceFile: ts.SourceFile,\n  typeChecker: ts.TypeChecker,\n  rewriteFn: RewriteFn,\n) {\n  const changeTracker = new ChangeTracker(ts.createPrinter());\n  const addedImports = new Map<string, Set<string>>([\n    [COMMON_HTTP, new Set()],\n    [COMMON_HTTP_TESTING, new Set()],\n  ]);\n\n  const commonHttpIdentifiers = new Set(\n    getImportSpecifiers(sourceFile, COMMON_HTTP, [...HTTP_MODULES]).map((specifier) =>\n      specifier.getText(),\n    ),\n  );\n  const commonHttpTestingIdentifiers = new Set(\n    getImportSpecifiers(sourceFile, COMMON_HTTP_TESTING, [...HTTP_TESTING_MODULES]).map(\n      (specifier) => specifier.getText(),\n    ),\n  );\n\n  ts.forEachChild(sourceFile, function visit(node: ts.Node) {\n    ts.forEachChild(node, visit);\n\n    if (ts.isClassDeclaration(node)) {\n      const decorators = getAngularDecorators(typeChecker, ts.getDecorators(node) || []);\n      decorators.forEach((decorator) => {\n        migrateDecorator(\n          decorator,\n          commonHttpIdentifiers,\n          commonHttpTestingIdentifiers,\n          addedImports,\n          changeTracker,\n          sourceFile,\n        );\n      });\n    }\n\n    migrateTestingModuleImports(\n      node,\n      commonHttpIdentifiers,\n      commonHttpTestingIdentifiers,\n      addedImports,\n      changeTracker,\n    );\n  });\n\n  // Imports are for the whole file\n  // We handle them separately\n\n  // Remove the HttpModules imports from common/http\n  const commonHttpImports = getNamedImports(sourceFile, COMMON_HTTP);\n  if (commonHttpImports) {\n    const symbolImportsToRemove = getImportSpecifiers(sourceFile, COMMON_HTTP, [...HTTP_MODULES]);\n\n    const newImports = ts.factory.updateNamedImports(commonHttpImports, [\n      ...commonHttpImports.elements.filter((current) => !symbolImportsToRemove.includes(current)),\n      ...[...(addedImports.get(COMMON_HTTP) ?? [])].map((entry) => {\n        return ts.factory.createImportSpecifier(\n          false,\n          undefined,\n          ts.factory.createIdentifier(entry),\n        );\n      }),\n    ]);\n    changeTracker.replaceNode(commonHttpImports, newImports);\n  }\n  // If there are no imports for common/http, and we need to add some\n  else if (addedImports.get(COMMON_HTTP)?.size) {\n    // Then we add a new import statement for common/http\n    addedImports.get(COMMON_HTTP)?.forEach((entry) => {\n      changeTracker.addImport(sourceFile, entry, COMMON_HTTP);\n    });\n  }\n\n  // Remove the HttpModules imports from common/http/testing\n  const commonHttpTestingImports = getNamedImports(sourceFile, COMMON_HTTP_TESTING);\n  if (commonHttpTestingImports) {\n    const symbolImportsToRemove = getImportSpecifiers(sourceFile, COMMON_HTTP_TESTING, [\n      ...HTTP_TESTING_MODULES,\n    ]);\n\n    const newHttpTestingImports = ts.factory.updateNamedImports(commonHttpTestingImports, [\n      ...commonHttpTestingImports.elements.filter(\n        (current) => !symbolImportsToRemove.includes(current),\n      ),\n      ...[...(addedImports.get(COMMON_HTTP_TESTING) ?? [])].map((entry) => {\n        return ts.factory.createImportSpecifier(\n          false,\n          undefined,\n          ts.factory.createIdentifier(entry),\n        );\n      }),\n    ]);\n    changeTracker.replaceNode(commonHttpTestingImports, newHttpTestingImports);\n  }\n\n  // Writing the changes\n  for (const changesInFile of changeTracker.recordChanges().values()) {\n    for (const change of changesInFile) {\n      rewriteFn(change.start, change.removeLength ?? 0, change.text);\n    }\n  }\n}\n\nfunction migrateDecorator(\n  decorator: NgDecorator,\n  commonHttpIdentifiers: Set<string>,\n  commonHttpTestingIdentifiers: Set<string>,\n  addedImports: Map<string, Set<string>>,\n  changeTracker: ChangeTracker,\n  sourceFile: ts.SourceFile,\n) {\n  // Only @NgModule and @Component support `imports`.\n  // Also skip decorators with no arguments.\n  if (\n    (decorator.name !== 'NgModule' && decorator.name !== 'Component') ||\n    decorator.node.expression.arguments.length < 1\n  ) {\n    return;\n  }\n\n  // Does the decorator have any imports?\n  const metadata = decorator.node.expression.arguments[0];\n  if (!ts.isObjectLiteralExpression(metadata)) {\n    return;\n  }\n\n  const moduleImports = getImportsProp(metadata);\n  if (!moduleImports) {\n    return;\n  }\n\n  // Does the decorator import any of the HTTP modules?\n  const importedModules = getImportedHttpModules(\n    moduleImports,\n    commonHttpIdentifiers,\n    commonHttpTestingIdentifiers,\n  );\n  if (!importedModules) {\n    return;\n  }\n\n  // HttpClient imported in component is actually a mistake\n  // Schematics will be no-op but add a TODO\n  const isComponent = decorator.name === 'Component';\n  if (isComponent && importedModules.client) {\n    const httpClientModuleIdentifier = importedModules.client;\n    const commentText =\n      '\\n// TODO: `HttpClientModule` should not be imported into a component directly.\\n' +\n      '// Please refactor the code to add `provideHttpClient()` call to the provider list in the\\n' +\n      '// application bootstrap logic and remove the `HttpClientModule` import from this component.\\n';\n    ts.addSyntheticLeadingComment(\n      httpClientModuleIdentifier,\n      ts.SyntaxKind.SingleLineCommentTrivia,\n      commentText,\n      true,\n    );\n    changeTracker.insertText(sourceFile, httpClientModuleIdentifier.getStart(), commentText);\n    return;\n  }\n\n  const addedProviders = new Set<ts.CallExpression>();\n\n  // Handle the different imported Http modules\n  const commonHttpAddedImports = addedImports.get(COMMON_HTTP);\n  commonHttpAddedImports?.add(PROVIDE_HTTP_CLIENT);\n  if (importedModules.client || importedModules.clientTesting) {\n    commonHttpAddedImports?.add(WITH_INTERCEPTORS_FROM_DI);\n    addedProviders.add(createCallExpression(WITH_INTERCEPTORS_FROM_DI));\n  }\n  if (importedModules.clientJsonp) {\n    commonHttpAddedImports?.add(WITH_JSONP_SUPPORT);\n    addedProviders.add(createCallExpression(WITH_JSONP_SUPPORT));\n  }\n  if (importedModules.xsrf) {\n    // HttpClientXsrfModule is the only module with Class methods.\n    // They correspond to different provider functions\n    if (importedModules.xsrfOptions === 'disable') {\n      commonHttpAddedImports?.add(WITH_NOXSRF_PROTECTION);\n      addedProviders.add(createCallExpression(WITH_NOXSRF_PROTECTION));\n    } else {\n      commonHttpAddedImports?.add(WITH_XSRF_CONFIGURATION);\n      addedProviders.add(\n        createCallExpression(\n          WITH_XSRF_CONFIGURATION,\n          importedModules.xsrfOptions?.options ? [importedModules.xsrfOptions.options] : [],\n        ),\n      );\n    }\n  }\n\n  // Removing the imported Http modules from the imports list\n  const newImports = ts.factory.createArrayLiteralExpression([\n    ...moduleImports.elements.filter(\n      (item) =>\n        item !== importedModules.client &&\n        item !== importedModules.clientJsonp &&\n        item !== importedModules.xsrf &&\n        item !== importedModules.clientTesting,\n    ),\n  ]);\n\n  // Adding the new providers\n  const providers = getProvidersFromLiteralExpr(metadata);\n\n  // handle the HttpClientTestingModule\n  let provideHttpClientTestingExpr: ts.CallExpression | undefined;\n  if (importedModules.clientTesting) {\n    const commonHttpTestingAddedImports = addedImports.get(COMMON_HTTP_TESTING);\n    commonHttpTestingAddedImports?.add(PROVIDE_HTTP_CLIENT_TESTING);\n    provideHttpClientTestingExpr = createCallExpression(PROVIDE_HTTP_CLIENT_TESTING);\n  }\n  const provideHttpExpr = createCallExpression(PROVIDE_HTTP_CLIENT, [...addedProviders]);\n  const providersToAppend = provideHttpClientTestingExpr\n    ? [provideHttpExpr, provideHttpClientTestingExpr]\n    : [provideHttpExpr];\n\n  let newProviders: ts.ArrayLiteralExpression;\n  if (!providers) {\n    // No existing providers, we add a property to the literal\n    newProviders = ts.factory.createArrayLiteralExpression(providersToAppend);\n  } else {\n    // We add the provider to the existing provider array\n    newProviders = ts.factory.updateArrayLiteralExpression(\n      providers,\n      ts.factory.createNodeArray(\n        [...providers.elements, ...providersToAppend],\n        providers.elements.hasTrailingComma,\n      ),\n    );\n  }\n\n  // Replacing the existing decorator with the new one (with the new imports and providers)\n  const newDecoratorArgs = ts.factory.createObjectLiteralExpression([\n    ...metadata.properties.filter(\n      (property) =>\n        property.name?.getText() !== 'imports' && property.name?.getText() !== 'providers',\n    ),\n    ts.factory.createPropertyAssignment('imports', newImports),\n    ts.factory.createPropertyAssignment('providers', newProviders),\n  ]);\n  changeTracker.replaceNode(metadata, newDecoratorArgs);\n}\n\nfunction migrateTestingModuleImports(\n  node: ts.Node,\n  commonHttpIdentifiers: Set<string>,\n  commonHttpTestingIdentifiers: Set<string>,\n  addedImports: Map<string, Set<string>>,\n  changeTracker: ChangeTracker,\n) {\n  // Look for calls to `TestBed.configureTestingModule` with at least one argument.\n  // TODO: this won't work if `TestBed` is aliased or type cast.\n  if (\n    !ts.isCallExpression(node) ||\n    node.arguments.length < 1 ||\n    !ts.isPropertyAccessExpression(node.expression) ||\n    !ts.isIdentifier(node.expression.expression) ||\n    node.expression.expression.text !== 'TestBed' ||\n    node.expression.name.text !== 'configureTestingModule'\n  ) {\n    return;\n  }\n\n  // Do we have any arguments for configureTestingModule ?\n  const configureTestingModuleArgs = node.arguments[0];\n  if (!ts.isObjectLiteralExpression(configureTestingModuleArgs)) {\n    return;\n  }\n\n  // Do we have an imports property with an array ?\n  const importsArray = getImportsProp(configureTestingModuleArgs);\n  if (!importsArray) {\n    return;\n  }\n\n  const commonHttpAddedImports = addedImports.get(COMMON_HTTP);\n\n  // Does the imports array contain the HttpClientModule?\n  const httpClient = importsArray.elements.find((elt) => elt.getText() === HTTP_CLIENT_MODULE);\n  if (httpClient && commonHttpIdentifiers.has(HTTP_CLIENT_MODULE)) {\n    // We add the imports for provideHttpClient(withInterceptorsFromDi())\n    commonHttpAddedImports?.add(PROVIDE_HTTP_CLIENT);\n    commonHttpAddedImports?.add(WITH_INTERCEPTORS_FROM_DI);\n\n    const newImports = ts.factory.createArrayLiteralExpression([\n      ...importsArray.elements.filter((item) => item !== httpClient),\n    ]);\n\n    const provideHttpClient = createCallExpression(PROVIDE_HTTP_CLIENT, [\n      createCallExpression(WITH_INTERCEPTORS_FROM_DI),\n    ]);\n\n    // Adding the new provider\n    const providers = getProvidersFromLiteralExpr(configureTestingModuleArgs);\n\n    let newProviders: ts.ArrayLiteralExpression;\n    if (!providers) {\n      // No existing providers, we add a property to the literal\n      newProviders = ts.factory.createArrayLiteralExpression([provideHttpClient]);\n    } else {\n      // We add the provider to the existing provider array\n      newProviders = ts.factory.updateArrayLiteralExpression(\n        providers,\n        ts.factory.createNodeArray(\n          [...providers.elements, provideHttpClient],\n          providers.elements.hasTrailingComma,\n        ),\n      );\n    }\n\n    // Replacing the existing configuration with the new one (with the new imports and providers)\n    const newTestingModuleArgs = updateTestBedConfiguration(\n      configureTestingModuleArgs,\n      newImports,\n      newProviders,\n    );\n    changeTracker.replaceNode(configureTestingModuleArgs, newTestingModuleArgs);\n  }\n\n  // Does the imports array contain the HttpClientTestingModule?\n  const httpClientTesting = importsArray.elements.find(\n    (elt) => elt.getText() === HTTP_CLIENT_TESTING_MODULE,\n  );\n  if (httpClientTesting && commonHttpTestingIdentifiers.has(HTTP_CLIENT_TESTING_MODULE)) {\n    // We add the imports for provideHttpClient(withInterceptorsFromDi()) and provideHttpClientTesting()\n    commonHttpAddedImports?.add(PROVIDE_HTTP_CLIENT);\n    commonHttpAddedImports?.add(WITH_INTERCEPTORS_FROM_DI);\n    addedImports.get(COMMON_HTTP_TESTING)?.add(PROVIDE_HTTP_CLIENT_TESTING);\n\n    const newImports = ts.factory.createArrayLiteralExpression([\n      ...importsArray.elements.filter((item) => item !== httpClientTesting),\n    ]);\n\n    const provideHttpClient = createCallExpression(PROVIDE_HTTP_CLIENT, [\n      createCallExpression(WITH_INTERCEPTORS_FROM_DI),\n    ]);\n    const provideHttpClientTesting = createCallExpression(PROVIDE_HTTP_CLIENT_TESTING);\n\n    // Adding the new providers\n    const providers = getProvidersFromLiteralExpr(configureTestingModuleArgs);\n\n    let newProviders: ts.ArrayLiteralExpression;\n    if (!providers) {\n      // No existing providers, we add a property to the literal\n      newProviders = ts.factory.createArrayLiteralExpression([\n        provideHttpClient,\n        provideHttpClientTesting,\n      ]);\n    } else {\n      // We add the provider to the existing provider array\n      newProviders = ts.factory.updateArrayLiteralExpression(\n        providers,\n        ts.factory.createNodeArray(\n          [...providers.elements, provideHttpClient, provideHttpClientTesting],\n          providers.elements.hasTrailingComma,\n        ),\n      );\n    }\n\n    // Replacing the existing configuration with the new one (with the new imports and providers)\n    const newTestingModuleArgs = updateTestBedConfiguration(\n      configureTestingModuleArgs,\n      newImports,\n      newProviders,\n    );\n    changeTracker.replaceNode(configureTestingModuleArgs, newTestingModuleArgs);\n  }\n}\n\nfunction getImportsProp(literal: ts.ObjectLiteralExpression) {\n  const properties = literal.properties;\n  const importProp = properties.find((property) => property.name?.getText() === 'imports');\n  if (!importProp || !ts.hasOnlyExpressionInitializer(importProp)) {\n    return null;\n  }\n\n  if (ts.isArrayLiteralExpression(importProp.initializer)) {\n    return importProp.initializer;\n  }\n\n  return null;\n}\n\nfunction getProvidersFromLiteralExpr(literal: ts.ObjectLiteralExpression) {\n  const properties = literal.properties;\n  const providersProp = properties.find((property) => property.name?.getText() === 'providers');\n  if (!providersProp || !ts.hasOnlyExpressionInitializer(providersProp)) {\n    return null;\n  }\n\n  if (ts.isArrayLiteralExpression(providersProp.initializer)) {\n    return providersProp.initializer;\n  }\n\n  return null;\n}\n\nfunction getImportedHttpModules(\n  imports: ts.ArrayLiteralExpression,\n  commonHttpIdentifiers: Set<string>,\n  commonHttpTestingIdentifiers: Set<string>,\n) {\n  let client: ts.Identifier | ts.CallExpression | null = null;\n  let clientJsonp: ts.Identifier | ts.CallExpression | null = null;\n  let xsrf: ts.Identifier | ts.CallExpression | null = null;\n  let clientTesting: ts.Identifier | ts.CallExpression | null = null;\n\n  // represents respectively:\n  // HttpClientXsrfModule.disable()\n  // HttpClientXsrfModule.withOptions(options)\n  // base HttpClientXsrfModule\n  let xsrfOptions: 'disable' | {options: ts.Expression} | null = null;\n\n  // Handling the http modules from @angular/common/http and the http testing module from @angular/common/http/testing\n  // and skipping the rest\n  for (const item of imports.elements) {\n    if (ts.isIdentifier(item)) {\n      const moduleName = item.getText();\n\n      // We only care about the modules from @angular/common/http and @angular/common/http/testing\n      if (!commonHttpIdentifiers.has(moduleName) && !commonHttpTestingIdentifiers.has(moduleName)) {\n        continue;\n      }\n\n      if (moduleName === HTTP_CLIENT_MODULE) {\n        client = item;\n      } else if (moduleName === HTTP_CLIENT_JSONP_MODULE) {\n        clientJsonp = item;\n      } else if (moduleName === HTTP_CLIENT_XSRF_MODULE) {\n        xsrf = item;\n      } else if (moduleName === HTTP_CLIENT_TESTING_MODULE) {\n        clientTesting = item;\n      }\n    } else if (ts.isCallExpression(item) && ts.isPropertyAccessExpression(item.expression)) {\n      const moduleName = item.expression.expression.getText();\n\n      // We only care about the modules from @angular/common/http\n      if (!commonHttpIdentifiers.has(moduleName)) {\n        continue;\n      }\n\n      if (moduleName === HTTP_CLIENT_XSRF_MODULE) {\n        xsrf = item;\n        if (item.expression.getText().includes('withOptions') && item.arguments.length === 1) {\n          xsrfOptions = {options: item.arguments[0]};\n        } else if (item.expression.getText().includes('disable')) {\n          xsrfOptions = 'disable';\n        }\n      }\n    }\n  }\n\n  if (client !== null || clientJsonp !== null || xsrf !== null || clientTesting !== null) {\n    return {client, clientJsonp, xsrf, xsrfOptions, clientTesting};\n  }\n\n  return null;\n}\n\nfunction createCallExpression(functionName: string, args: ts.Expression[] = []) {\n  return ts.factory.createCallExpression(\n    ts.factory.createIdentifier(functionName),\n    undefined,\n    args,\n  );\n}\n\nfunction updateTestBedConfiguration(\n  configureTestingModuleArgs: ts.ObjectLiteralExpression,\n  newImports: ts.ArrayLiteralExpression,\n  newProviders: ts.ArrayLiteralExpression,\n): ts.ObjectLiteralExpression {\n  return ts.factory.updateObjectLiteralExpression(configureTestingModuleArgs, [\n    ...configureTestingModuleArgs.properties.filter(\n      (property) =>\n        property.name?.getText() !== 'imports' && property.name?.getText() !== 'providers',\n    ),\n    ts.factory.createPropertyAssignment('imports', newImports),\n    ts.factory.createPropertyAssignment('providers', newProviders),\n  ]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {ImportManager} from './import_manager';\n\n/** Function that can be used to remap a generated import. */\nexport type ImportRemapper = (moduleName: string, inFile: string) => string;\n\n/** Mapping between a source file and the changes that have to be applied to it. */\nexport type ChangesByFile = ReadonlyMap<ts.SourceFile, PendingChange[]>;\n\n/** Change that needs to be applied to a file. */\nexport interface PendingChange {\n  /** Index at which to start changing the file. */\n  start: number;\n  /**\n   * Amount of text that should be removed after the `start`.\n   * No text will be removed if omitted.\n   */\n  removeLength?: number;\n  /** New text that should be inserted. */\n  text: string;\n}\n\n/** Tracks changes that have to be made for specific files. */\nexport class ChangeTracker {\n  private readonly _changes = new Map<ts.SourceFile, PendingChange[]>();\n  private readonly _importManager: ImportManager;\n\n  constructor(\n    private _printer: ts.Printer,\n    private _importRemapper?: ImportRemapper,\n  ) {\n    this._importManager = new ImportManager(\n      (currentFile) => ({\n        addNewImport: (start, text) => this.insertText(currentFile, start, text),\n        updateExistingImport: (namedBindings, text) =>\n          this.replaceText(currentFile, namedBindings.getStart(), namedBindings.getWidth(), text),\n      }),\n      this._printer,\n    );\n  }\n\n  /**\n   * Tracks the insertion of some text.\n   * @param sourceFile File in which the text is being inserted.\n   * @param start Index at which the text is insert.\n   * @param text Text to be inserted.\n   */\n  insertText(sourceFile: ts.SourceFile, index: number, text: string): void {\n    this._trackChange(sourceFile, {start: index, text});\n  }\n\n  /**\n   * Replaces text within a file.\n   * @param sourceFile File in which to replace the text.\n   * @param start Index from which to replace the text.\n   * @param removeLength Length of the text being replaced.\n   * @param text Text to be inserted instead of the old one.\n   */\n  replaceText(sourceFile: ts.SourceFile, start: number, removeLength: number, text: string): void {\n    this._trackChange(sourceFile, {start, removeLength, text});\n  }\n\n  /**\n   * Replaces the text of an AST node with a new one.\n   * @param oldNode Node to be replaced.\n   * @param newNode New node to be inserted.\n   * @param emitHint Hint when formatting the text of the new node.\n   * @param sourceFileWhenPrinting File to use when printing out the new node. This is important\n   * when copying nodes from one file to another, because TypeScript might not output literal nodes\n   * without it.\n   */\n  replaceNode(\n    oldNode: ts.Node,\n    newNode: ts.Node,\n    emitHint = ts.EmitHint.Unspecified,\n    sourceFileWhenPrinting?: ts.SourceFile,\n  ): void {\n    const sourceFile = oldNode.getSourceFile();\n    this.replaceText(\n      sourceFile,\n      oldNode.getStart(),\n      oldNode.getWidth(),\n      this._printer.printNode(emitHint, newNode, sourceFileWhenPrinting || sourceFile),\n    );\n  }\n\n  /**\n   * Removes the text of an AST node from a file.\n   * @param node Node whose text should be removed.\n   */\n  removeNode(node: ts.Node): void {\n    this._trackChange(node.getSourceFile(), {\n      start: node.getStart(),\n      removeLength: node.getWidth(),\n      text: '',\n    });\n  }\n\n  /**\n   * Adds an import to a file.\n   * @param sourceFile File to which to add the import.\n   * @param symbolName Symbol being imported.\n   * @param moduleName Module from which the symbol is imported.\n   * @param alias Alias to use for the import.\n   * @param keepSymbolName Whether to keep the symbol name in the import.\n   */\n  addImport(\n    sourceFile: ts.SourceFile,\n    symbolName: string,\n    moduleName: string,\n    alias: string | null = null,\n    keepSymbolName = false,\n  ): ts.Expression {\n    if (this._importRemapper) {\n      moduleName = this._importRemapper(moduleName, sourceFile.fileName);\n    }\n\n    // It's common for paths to be manipulated with Node's `path` utilties which\n    // can yield a path with back slashes. Normalize them since outputting such\n    // paths will also cause TS to escape the forward slashes.\n    moduleName = normalizePath(moduleName);\n\n    return this._importManager.addImportToSourceFile(\n      sourceFile,\n      symbolName,\n      moduleName,\n      alias,\n      false,\n      keepSymbolName,\n    );\n  }\n\n  /**\n   * Gets the changes that should be applied to all the files in the migration.\n   * The changes are sorted in the order in which they should be applied.\n   */\n  recordChanges(): ChangesByFile {\n    this._importManager.recordChanges();\n    return this._changes;\n  }\n\n  /**\n   * Clear the tracked changes\n   */\n  clearChanges(): void {\n    this._changes.clear();\n  }\n\n  /**\n   * Adds a change to a `ChangesByFile` map.\n   * @param file File that the change is associated with.\n   * @param change Change to be added.\n   */\n  private _trackChange(file: ts.SourceFile, change: PendingChange): void {\n    const changes = this._changes.get(file);\n\n    if (changes) {\n      // Insert the changes in reverse so that they're applied in reverse order.\n      // This ensures that the offsets of subsequent changes aren't affected by\n      // previous changes changing the file's text.\n      const insertIndex = changes.findIndex((current) => current.start <= change.start);\n\n      if (insertIndex === -1) {\n        changes.push(change);\n      } else {\n        changes.splice(insertIndex, 0, change);\n      }\n    } else {\n      this._changes.set(file, [change]);\n    }\n  }\n}\n\n/** Normalizes a path to use posix separators. */\nexport function normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {dirname, resolve} from 'path';\nimport ts from 'typescript';\n\n/** Update recorder for managing imports. */\nexport interface ImportManagerUpdateRecorder {\n  addNewImport(start: number, importText: string): void;\n  updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string): void;\n}\n\n/** Possible types of quotes for imports. */\nconst enum QuoteStyle {\n  Single,\n  Double,\n}\n\n/**\n * Import manager that can be used to add TypeScript imports to given source\n * files. The manager ensures that multiple transformations are applied properly\n * without shifted offsets and that similar existing import declarations are re-used.\n */\nexport class ImportManager {\n  /** Map of import declarations that need to be updated to include the given symbols. */\n  private updatedImports = new Map<\n    ts.ImportDeclaration,\n    {propertyName?: ts.Identifier; importName: ts.Identifier}[]\n  >();\n  /** Map of source-files and their previously used identifier names. */\n  private usedIdentifierNames = new Map<ts.SourceFile, string[]>();\n  /** Map of source files and the new imports that have to be added to them. */\n  private newImports: Map<\n    ts.SourceFile,\n    {\n      importStartIndex: number;\n      defaultImports: Map<string, ts.Identifier>;\n      namedImports: Map<string, ts.ImportSpecifier[]>;\n    }\n  > = new Map();\n  /** Map between a file and the implied quote style for imports. */\n  private quoteStyles: Record<string, QuoteStyle> = {};\n\n  /**\n   * Array of previously resolved symbol imports. Cache can be re-used to return\n   * the same identifier without checking the source-file again.\n   */\n  private importCache: {\n    sourceFile: ts.SourceFile;\n    symbolName: string | null;\n    alias: string | null;\n    moduleName: string;\n    identifier: ts.Identifier;\n  }[] = [];\n\n  constructor(\n    private getUpdateRecorder: (sf: ts.SourceFile) => ImportManagerUpdateRecorder,\n    private printer: ts.Printer,\n  ) {}\n\n  /**\n   * Adds an import to the given source-file and returns the TypeScript\n   * identifier that can be used to access the newly imported symbol.\n   */\n  addImportToSourceFile(\n    sourceFile: ts.SourceFile,\n    symbolName: string | null,\n    moduleName: string,\n    alias: string | null = null,\n    typeImport = false,\n    keepSymbolName = false,\n  ): ts.Expression {\n    const sourceDir = dirname(sourceFile.fileName);\n    let importStartIndex = 0;\n    let existingImport: ts.ImportDeclaration | null = null;\n\n    // In case the given import has been already generated previously, we just return\n    // the previous generated identifier in order to avoid duplicate generated imports.\n    const cachedImport = this.importCache.find(\n      (c) =>\n        c.sourceFile === sourceFile &&\n        c.symbolName === symbolName &&\n        c.moduleName === moduleName &&\n        c.alias === alias,\n    );\n    if (cachedImport) {\n      return cachedImport.identifier;\n    }\n\n    // Walk through all source-file top-level statements and search for import declarations\n    // that already match the specified \"moduleName\" and can be updated to import the\n    // given symbol. If no matching import can be found, the last import in the source-file\n    // will be used as starting point for a new import that will be generated.\n    for (let i = sourceFile.statements.length - 1; i >= 0; i--) {\n      const statement = sourceFile.statements[i];\n\n      if (\n        !ts.isImportDeclaration(statement) ||\n        !ts.isStringLiteral(statement.moduleSpecifier) ||\n        !statement.importClause\n      ) {\n        continue;\n      }\n\n      if (importStartIndex === 0) {\n        importStartIndex = this._getEndPositionOfNode(statement);\n      }\n\n      const moduleSpecifier = statement.moduleSpecifier.text;\n\n      if (\n        (moduleSpecifier.startsWith('.') &&\n          resolve(sourceDir, moduleSpecifier) !== resolve(sourceDir, moduleName)) ||\n        moduleSpecifier !== moduleName\n      ) {\n        continue;\n      }\n\n      if (statement.importClause.namedBindings) {\n        const namedBindings = statement.importClause.namedBindings;\n\n        // In case a \"Type\" symbol is imported, we can't use namespace imports\n        // because these only export symbols available at runtime (no types)\n        if (ts.isNamespaceImport(namedBindings) && !typeImport) {\n          return ts.factory.createPropertyAccessExpression(\n            ts.factory.createIdentifier(namedBindings.name.text),\n            ts.factory.createIdentifier(alias || symbolName || 'default'),\n          );\n        } else if (ts.isNamedImports(namedBindings) && symbolName) {\n          const existingElement = namedBindings.elements.find((e) => {\n            // TODO(crisbeto): if an alias conflicts with an existing import, it may cause invalid\n            // code to be generated. This is unlikely, but we may want to revisit it in the future.\n            if (alias) {\n              return e.propertyName && e.name.text === alias && e.propertyName.text === symbolName;\n            }\n            return e.propertyName ? e.propertyName.text === symbolName : e.name.text === symbolName;\n          });\n\n          if (existingElement) {\n            return ts.factory.createIdentifier(existingElement.name.text);\n          }\n\n          // In case the symbol could not be found in an existing import, we\n          // keep track of the import declaration as it can be updated to include\n          // the specified symbol name without having to create a new import.\n          existingImport = statement;\n        }\n      } else if (statement.importClause.name && !symbolName) {\n        return ts.factory.createIdentifier(statement.importClause.name.text);\n      }\n    }\n\n    if (existingImport) {\n      const {propertyName, name} = this._getImportParts(\n        sourceFile,\n        symbolName!,\n        alias,\n        keepSymbolName,\n      );\n\n      // Since it can happen that multiple classes need to be imported within the\n      // specified source file and we want to add the identifiers to the existing\n      // import declaration, we need to keep track of the updated import declarations.\n      // We can't directly update the import declaration for each identifier as this\n      // would throw off the recorder offsets. We need to keep track of the new identifiers\n      // for the import and perform the import transformation as batches per source-file.\n      this.updatedImports.set(\n        existingImport,\n        (this.updatedImports.get(existingImport) || []).concat({propertyName, importName: name}),\n      );\n\n      // Keep track of all updated imports so that we don't generate duplicate\n      // similar imports as these can't be statically analyzed in the source-file yet.\n      this.importCache.push({sourceFile, moduleName, symbolName, alias, identifier: name});\n\n      return name;\n    }\n\n    let identifier: ts.Identifier | null = null;\n\n    if (!this.newImports.has(sourceFile)) {\n      this.newImports.set(sourceFile, {\n        importStartIndex,\n        defaultImports: new Map(),\n        namedImports: new Map(),\n      });\n    }\n\n    if (symbolName) {\n      const {propertyName, name} = this._getImportParts(\n        sourceFile,\n        symbolName,\n        alias,\n        keepSymbolName,\n      );\n      const importMap = this.newImports.get(sourceFile)!.namedImports;\n      identifier = name;\n\n      if (!importMap.has(moduleName)) {\n        importMap.set(moduleName, []);\n      }\n\n      importMap.get(moduleName)!.push(ts.factory.createImportSpecifier(false, propertyName, name));\n    } else {\n      const importMap = this.newImports.get(sourceFile)!.defaultImports;\n      identifier = this._getUniqueIdentifier(sourceFile, 'defaultExport');\n      importMap.set(moduleName, identifier);\n    }\n\n    // Keep track of all generated imports so that we don't generate duplicate\n    // similar imports as these can't be statically analyzed in the source-file yet.\n    this.importCache.push({sourceFile, symbolName, moduleName, alias, identifier});\n\n    return identifier;\n  }\n\n  /**\n   * Stores the collected import changes within the appropriate update recorders. The\n   * updated imports can only be updated *once* per source-file because previous updates\n   * could otherwise shift the source-file offsets.\n   */\n  recordChanges() {\n    this.updatedImports.forEach((expressions, importDecl) => {\n      const sourceFile = importDecl.getSourceFile();\n      const recorder = this.getUpdateRecorder(sourceFile);\n      const namedBindings = importDecl.importClause!.namedBindings as ts.NamedImports;\n      const newNamedBindings = ts.factory.updateNamedImports(\n        namedBindings,\n        namedBindings.elements.concat(\n          expressions.map(({propertyName, importName}) =>\n            ts.factory.createImportSpecifier(false, propertyName, importName),\n          ),\n        ),\n      );\n\n      const newNamedBindingsText = this.printer.printNode(\n        ts.EmitHint.Unspecified,\n        newNamedBindings,\n        sourceFile,\n      );\n      recorder.updateExistingImport(namedBindings, newNamedBindingsText);\n    });\n\n    this.newImports.forEach(({importStartIndex, defaultImports, namedImports}, sourceFile) => {\n      const recorder = this.getUpdateRecorder(sourceFile);\n      const useSingleQuotes = this._getQuoteStyle(sourceFile) === QuoteStyle.Single;\n\n      defaultImports.forEach((identifier, moduleName) => {\n        const newImport = ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(false, identifier, undefined),\n          ts.factory.createStringLiteral(moduleName, useSingleQuotes),\n        );\n\n        recorder.addNewImport(\n          importStartIndex,\n          this._getNewImportText(importStartIndex, newImport, sourceFile),\n        );\n      });\n\n      namedImports.forEach((specifiers, moduleName) => {\n        const newImport = ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(\n            false,\n            undefined,\n            ts.factory.createNamedImports(specifiers),\n          ),\n          ts.factory.createStringLiteral(moduleName, useSingleQuotes),\n        );\n\n        recorder.addNewImport(\n          importStartIndex,\n          this._getNewImportText(importStartIndex, newImport, sourceFile),\n        );\n      });\n    });\n  }\n\n  /** Gets an unique identifier with a base name for the given source file. */\n  private _getUniqueIdentifier(sourceFile: ts.SourceFile, baseName: string): ts.Identifier {\n    if (this.isUniqueIdentifierName(sourceFile, baseName)) {\n      this._recordUsedIdentifier(sourceFile, baseName);\n      return ts.factory.createIdentifier(baseName);\n    }\n\n    let name = null;\n    let counter = 1;\n    do {\n      name = `${baseName}_${counter++}`;\n    } while (!this.isUniqueIdentifierName(sourceFile, name));\n\n    this._recordUsedIdentifier(sourceFile, name!);\n    return ts.factory.createIdentifier(name!);\n  }\n\n  /**\n   * Checks whether the specified identifier name is used within the given\n   * source file.\n   */\n  private isUniqueIdentifierName(sourceFile: ts.SourceFile, name: string) {\n    if (\n      this.usedIdentifierNames.has(sourceFile) &&\n      this.usedIdentifierNames.get(sourceFile)!.indexOf(name) !== -1\n    ) {\n      return false;\n    }\n\n    // Walk through the source file and search for an identifier matching\n    // the given name. In that case, it's not guaranteed that this name\n    // is unique in the given declaration scope and we just return false.\n    const nodeQueue: ts.Node[] = [sourceFile];\n    while (nodeQueue.length) {\n      const node = nodeQueue.shift()!;\n      if (\n        ts.isIdentifier(node) &&\n        node.text === name &&\n        // Identifiers that are aliased in an import aren't\n        // problematic since they're used under a different name.\n        (!ts.isImportSpecifier(node.parent) || node.parent.propertyName !== node)\n      ) {\n        return false;\n      }\n      nodeQueue.push(...node.getChildren());\n    }\n    return true;\n  }\n\n  private _recordUsedIdentifier(sourceFile: ts.SourceFile, identifierName: string) {\n    this.usedIdentifierNames.set(\n      sourceFile,\n      (this.usedIdentifierNames.get(sourceFile) || []).concat(identifierName),\n    );\n  }\n\n  /**\n   * Determines the full end of a given node. By default the end position of a node is\n   * before all trailing comments. This could mean that generated imports shift comments.\n   */\n  private _getEndPositionOfNode(node: ts.Node) {\n    const nodeEndPos = node.getEnd();\n    const commentRanges = ts.getTrailingCommentRanges(node.getSourceFile().text, nodeEndPos);\n    if (!commentRanges || !commentRanges.length) {\n      return nodeEndPos;\n    }\n    return commentRanges[commentRanges.length - 1]!.end;\n  }\n\n  /** Gets the text that should be added to the file for a newly-created import declaration. */\n  private _getNewImportText(\n    importStartIndex: number,\n    newImport: ts.ImportDeclaration,\n    sourceFile: ts.SourceFile,\n  ): string {\n    const text = this.printer.printNode(ts.EmitHint.Unspecified, newImport, sourceFile);\n\n    // If the import is generated at the start of the source file, we want to add\n    // a new-line after the import. Otherwise if the import is generated after an\n    // existing import, we need to prepend a new-line so that the import is not on\n    // the same line as the existing import anchor\n    return importStartIndex === 0 ? `${text}\\n` : `\\n${text}`;\n  }\n\n  /**\n   * Gets the different parts necessary to construct an import specifier.\n   * @param sourceFile File in which the import is being inserted.\n   * @param symbolName Name of the symbol.\n   * @param alias Alias that the symbol may be available under.\n   * @returns Object containing the different parts. E.g. `{name: 'alias', propertyName: 'name'}`\n   * would correspond to `import {name as alias}` while `{name: 'name', propertyName: undefined}`\n   * corresponds to `import {name}`.\n   */\n  private _getImportParts(\n    sourceFile: ts.SourceFile,\n    symbolName: string,\n    alias: string | null,\n    keepSymbolName: boolean,\n  ) {\n    const symbolIdentifier = ts.factory.createIdentifier(symbolName);\n    const aliasIdentifier = alias ? ts.factory.createIdentifier(alias) : null;\n    const generatedUniqueIdentifier = this._getUniqueIdentifier(sourceFile, alias || symbolName);\n    const needsGeneratedUniqueName = generatedUniqueIdentifier.text !== (alias || symbolName);\n    let propertyName: ts.Identifier | undefined;\n    let name: ts.Identifier;\n\n    if (needsGeneratedUniqueName && !keepSymbolName) {\n      propertyName = symbolIdentifier;\n      name = generatedUniqueIdentifier;\n    } else if (aliasIdentifier) {\n      propertyName = symbolIdentifier;\n      name = aliasIdentifier;\n    } else {\n      name = symbolIdentifier;\n    }\n\n    return {propertyName, name};\n  }\n\n  /** Gets the quote style that is used for a file's imports. */\n  private _getQuoteStyle(sourceFile: ts.SourceFile): QuoteStyle {\n    if (!this.quoteStyles.hasOwnProperty(sourceFile.fileName)) {\n      let quoteStyle: QuoteStyle | undefined;\n\n      // Walk through the top-level imports and try to infer the quotes.\n      for (const statement of sourceFile.statements) {\n        if (\n          ts.isImportDeclaration(statement) &&\n          ts.isStringLiteralLike(statement.moduleSpecifier)\n        ) {\n          // Use `getText` instead of the actual text since it includes the quotes.\n          quoteStyle = statement.moduleSpecifier.getText().trim().startsWith('\"')\n            ? QuoteStyle.Double\n            : QuoteStyle.Single;\n          break;\n        }\n      }\n\n      // Otherwise fall back to single quotes.\n      this.quoteStyles[sourceFile.fileName] = quoteStyle ?? QuoteStyle.Single;\n    }\n\n    return this.quoteStyles[sourceFile.fileName];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {getImportOfIdentifier, Import} from './imports';\n\nexport function getCallDecoratorImport(\n  typeChecker: ts.TypeChecker,\n  decorator: ts.Decorator,\n): Import | null {\n  // Note that this does not cover the edge case where decorators are called from\n  // a namespace import: e.g. \"@core.Component()\". This is not handled by Ngtsc either.\n  if (\n    !ts.isCallExpression(decorator.expression) ||\n    !ts.isIdentifier(decorator.expression.expression)\n  ) {\n    return null;\n  }\n\n  const identifier = decorator.expression.expression;\n  return getImportOfIdentifier(typeChecker, identifier);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nexport type Import = {\n  name: string;\n  importModule: string;\n  node: ts.ImportDeclaration;\n};\n\n/** Gets import information about the specified identifier by using the Type checker. */\nexport function getImportOfIdentifier(\n  typeChecker: ts.TypeChecker,\n  node: ts.Identifier,\n): Import | null {\n  const symbol = typeChecker.getSymbolAtLocation(node);\n\n  if (!symbol || symbol.declarations === undefined || !symbol.declarations.length) {\n    return null;\n  }\n\n  const decl = symbol.declarations[0];\n\n  if (!ts.isImportSpecifier(decl)) {\n    return null;\n  }\n\n  const importDecl = decl.parent.parent.parent;\n\n  if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n    return null;\n  }\n\n  return {\n    // Handles aliased imports: e.g. \"import {Component as myComp} from ...\";\n    name: decl.propertyName ? decl.propertyName.text : decl.name.text,\n    importModule: importDecl.moduleSpecifier.text,\n    node: importDecl,\n  };\n}\n\n/**\n * Gets a top-level import specifier with a specific name that is imported from a particular module.\n * E.g. given a file that looks like:\n *\n * ```\n * import { Component, Directive } from '@angular/core';\n * import { Foo } from './foo';\n * ```\n *\n * Calling `getImportSpecifier(sourceFile, '@angular/core', 'Directive')` will yield the node\n * referring to `Directive` in the top import.\n *\n * @param sourceFile File in which to look for imports.\n * @param moduleName Name of the import's module.\n * @param specifierName Original name of the specifier to look for. Aliases will be resolved to\n *    their original name.\n */\nexport function getImportSpecifier(\n  sourceFile: ts.SourceFile,\n  moduleName: string | RegExp,\n  specifierName: string,\n): ts.ImportSpecifier | null {\n  return getImportSpecifiers(sourceFile, moduleName, [specifierName])[0] ?? null;\n}\n\nexport function getImportSpecifiers(\n  sourceFile: ts.SourceFile,\n  moduleName: string | RegExp,\n  specifierNames: string[],\n): ts.ImportSpecifier[] {\n  const matches: ts.ImportSpecifier[] = [];\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const isMatch =\n        typeof moduleName === 'string'\n          ? node.moduleSpecifier.text === moduleName\n          : moduleName.test(node.moduleSpecifier.text);\n      const namedBindings = node.importClause?.namedBindings;\n      if (isMatch && namedBindings && ts.isNamedImports(namedBindings)) {\n        for (const specifierName of specifierNames) {\n          const match = findImportSpecifier(namedBindings.elements, specifierName);\n          if (match) {\n            matches.push(match);\n          }\n        }\n      }\n    }\n  }\n  return matches;\n}\n\nexport function getNamedImports(\n  sourceFile: ts.SourceFile,\n  moduleName: string | RegExp,\n): ts.NamedImports | null {\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const isMatch =\n        typeof moduleName === 'string'\n          ? node.moduleSpecifier.text === moduleName\n          : moduleName.test(node.moduleSpecifier.text);\n      const namedBindings = node.importClause?.namedBindings;\n      if (isMatch && namedBindings && ts.isNamedImports(namedBindings)) {\n        return namedBindings;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Replaces an import inside a named imports node with a different one.\n *\n * @param node Node that contains the imports.\n * @param existingImport Import that should be replaced.\n * @param newImportName Import that should be inserted.\n */\nexport function replaceImport(\n  node: ts.NamedImports,\n  existingImport: string,\n  newImportName: string,\n) {\n  const isAlreadyImported = findImportSpecifier(node.elements, newImportName);\n  if (isAlreadyImported) {\n    return node;\n  }\n\n  const existingImportNode = findImportSpecifier(node.elements, existingImport);\n  if (!existingImportNode) {\n    return node;\n  }\n\n  const importPropertyName = existingImportNode.propertyName\n    ? ts.factory.createIdentifier(newImportName)\n    : undefined;\n  const importName = existingImportNode.propertyName\n    ? existingImportNode.name\n    : ts.factory.createIdentifier(newImportName);\n\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter((current) => current !== existingImportNode),\n    // Create a new import while trying to preserve the alias of the old one.\n    ts.factory.createImportSpecifier(false, importPropertyName, importName),\n  ]);\n}\n\n/**\n * Removes a symbol from the named imports and updates a node\n * that represents a given named imports.\n *\n * @param node Node that contains the imports.\n * @param symbol Symbol that should be removed.\n * @returns An updated node (ts.NamedImports).\n */\nexport function removeSymbolFromNamedImports(node: ts.NamedImports, symbol: ts.ImportSpecifier) {\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter((current) => current !== symbol),\n  ]);\n}\n\n/** Finds an import specifier with a particular name. */\nexport function findImportSpecifier(\n  nodes: ts.NodeArray<ts.ImportSpecifier>,\n  specifierName: string,\n): ts.ImportSpecifier | undefined {\n  return nodes.find((element) => {\n    const {name, propertyName} = element;\n    return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {getCallDecoratorImport} from './typescript/decorators';\n\nexport type CallExpressionDecorator = ts.Decorator & {\n  expression: ts.CallExpression;\n};\n\nexport interface NgDecorator {\n  name: string;\n  moduleName: string;\n  node: CallExpressionDecorator;\n  importNode: ts.ImportDeclaration;\n}\n\n/**\n * Gets all decorators which are imported from an Angular package (e.g. \"@angular/core\")\n * from a list of decorators.\n */\nexport function getAngularDecorators(\n  typeChecker: ts.TypeChecker,\n  decorators: ReadonlyArray<ts.Decorator>,\n): NgDecorator[] {\n  return decorators\n    .map((node) => ({node, importData: getCallDecoratorImport(typeChecker, node)}))\n    .filter(({importData}) => importData && importData.importModule.startsWith('@angular/'))\n    .map(({node, importData}) => ({\n      node: node as CallExpressionDecorator,\n      name: importData!.name,\n      moduleName: importData!.importModule,\n      importNode: importData!.node,\n    }));\n}\n"],
  "mappings": "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",
  "names": ["import_path", "path", "import_typescript", "ts", "ts", "import_typescript", "import_typescript", "import_path", "import_typescript", "ts", "ts", "path", "import_typescript", "import_typescript", "ts", "ts", "ts", "ts", "_a"]
}
