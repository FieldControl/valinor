/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { EnvironmentInjector } from '../../di/r3_injector';
import { assertDefined, throwError } from '../../util/assert';
import { assertTNodeForLView } from '../assert';
import { getComponentDef } from '../definition';
import { getNodeInjectorLView, getNodeInjectorTNode, NodeInjector } from '../di';
import { setInjectorProfiler, } from './injector_profiler';
/**
 * These are the data structures that our framework injector profiler will fill with data in order
 * to support DI debugging APIs.
 *
 * resolverToTokenToDependencies: Maps an injector to a Map of tokens to an Array of
 * dependencies. Injector -> Token -> Dependencies This is used to support the
 * getDependenciesFromInjectable API, which takes in an injector and a token and returns it's
 * dependencies.
 *
 * resolverToProviders: Maps a DI resolver (an Injector or a TNode) to the providers configured
 * within it This is used to support the getInjectorProviders API, which takes in an injector and
 * returns the providers that it was configured with. Note that for the element injector case we
 * use the TNode instead of the LView as the DI resolver. This is because the registration of
 * providers happens only once per type of TNode. If an injector is created with an identical TNode,
 * the providers for that injector will not be reconfigured.
 *
 * standaloneInjectorToComponent: Maps the injector of a standalone component to the standalone
 * component that it is associated with. Used in the getInjectorProviders API, specificially in the
 * discovery of import paths for each provider. This is necessary because the imports array of a
 * standalone component is processed and configured in its standalone injector, but exists within
 * the component's definition. Because getInjectorProviders takes in an injector, if that injector
 * is the injector of a standalone component, we need to be able to discover the place where the
 * imports array is located (the component) in order to flatten the imports array within it to
 * discover all of it's providers.
 *
 *
 * All of these data structures are instantiated with WeakMaps. This will ensure that the presence
 * of any object in the keys of these maps does not prevent the garbage collector from collecting
 * those objects. Because of this property of WeakMaps, these data structures will never be the
 * source of a memory leak.
 *
 * An example of this advantage: When components are destroyed, we don't need to do
 * any additional work to remove that component from our mappings.
 *
 */
class DIDebugData {
    constructor() {
        this.resolverToTokenToDependencies = new WeakMap();
        this.resolverToProviders = new WeakMap();
        this.standaloneInjectorToComponent = new WeakMap();
    }
    reset() {
        this.resolverToTokenToDependencies = new WeakMap();
        this.resolverToProviders = new WeakMap();
        this.standaloneInjectorToComponent = new WeakMap();
    }
}
let frameworkDIDebugData = new DIDebugData();
export function getFrameworkDIDebugData() {
    return frameworkDIDebugData;
}
/**
 * Initalize default handling of injector events. This handling parses events
 * as they are emitted and constructs the data structures necessary to support
 * some of debug APIs.
 *
 * See handleInjectEvent, handleCreateEvent and handleProviderConfiguredEvent
 * for descriptions of each handler
 *
 * Supported APIs:
 *               - getDependenciesFromInjectable
 *               - getInjectorProviders
 */
export function setupFrameworkInjectorProfiler() {
    frameworkDIDebugData.reset();
    setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));
}
function handleInjectorProfilerEvent(injectorProfilerEvent) {
    const { context, type } = injectorProfilerEvent;
    if (type === 0 /* InjectorProfilerEventType.Inject */) {
        handleInjectEvent(context, injectorProfilerEvent.service);
    }
    else if (type === 1 /* InjectorProfilerEventType.InstanceCreatedByInjector */) {
        handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);
    }
    else if (type === 2 /* InjectorProfilerEventType.ProviderConfigured */) {
        handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);
    }
}
/**
 *
 * Stores the injected service in frameworkDIDebugData.resolverToTokenToDependencies
 * based on it's injector and token.
 *
 * @param context InjectorProfilerContext the injection context that this event occurred in.
 * @param data InjectedService the service associated with this inject event.
 *
 */
function handleInjectEvent(context, data) {
    const diResolver = getDIResolver(context.injector);
    if (diResolver === null) {
        throwError('An Inject event must be run within an injection context.');
    }
    const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
    if (!diResolverToInstantiatedToken.has(diResolver)) {
        diResolverToInstantiatedToken.set(diResolver, new WeakMap());
    }
    // if token is a primitive type, ignore this event. We do this because we cannot keep track of
    // non-primitive tokens in WeakMaps since they are not garbage collectable.
    if (!canBeHeldWeakly(context.token)) {
        return;
    }
    const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
    if (!instantiatedTokenToDependencies.has(context.token)) {
        instantiatedTokenToDependencies.set(context.token, []);
    }
    const { token, value, flags } = data;
    assertDefined(context.token, 'Injector profiler context token is undefined.');
    const dependencies = instantiatedTokenToDependencies.get(context.token);
    assertDefined(dependencies, 'Could not resolve dependencies for token.');
    if (context.injector instanceof NodeInjector) {
        dependencies.push({ token, value, flags, injectedIn: getNodeInjectorContext(context.injector) });
    }
    else {
        dependencies.push({ token, value, flags });
    }
}
/**
 *
 * Returns the LView and TNode associated with a NodeInjector. Returns undefined if the injector
 * is not a NodeInjector.
 *
 * @param injector
 * @returns {lView: LView, tNode: TNode}|undefined
 */
function getNodeInjectorContext(injector) {
    if (!(injector instanceof NodeInjector)) {
        throwError('getNodeInjectorContext must be called with a NodeInjector');
    }
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    if (tNode === null) {
        return;
    }
    assertTNodeForLView(tNode, lView);
    return { lView, tNode };
}
/**
 *
 * If the created instance is an instance of a standalone component, maps the injector to that
 * standalone component in frameworkDIDebugData.standaloneInjectorToComponent
 *
 * @param context InjectorProfilerContext the injection context that this event occurred in.
 * @param data InjectorCreatedInstance an object containing the instance that was just created
 *
 */
function handleInstanceCreatedByInjectorEvent(context, data) {
    const { value } = data;
    if (getDIResolver(context.injector) === null) {
        throwError('An InjectorCreatedInstance event must be run within an injection context.');
    }
    // if our value is an instance of a standalone component, map the injector of that standalone
    // component to the component class. Otherwise, this event is a noop.
    let standaloneComponent = undefined;
    if (typeof value === 'object') {
        standaloneComponent = value?.constructor;
    }
    if (standaloneComponent === undefined || !isStandaloneComponent(standaloneComponent)) {
        return;
    }
    const environmentInjector = context.injector.get(EnvironmentInjector, null, { optional: true });
    // Standalone components should have an environment injector. If one cannot be
    // found we may be in a test case for low level functionality that did not explicitly
    // setup this injector. In those cases, we simply ignore this event.
    if (environmentInjector === null) {
        return;
    }
    const { standaloneInjectorToComponent } = frameworkDIDebugData;
    // If our injector has already been mapped, as is the case
    // when a standalone component imports another standalone component,
    // we consider the original component (the component doing the importing)
    // as the component connected to our injector.
    if (standaloneInjectorToComponent.has(environmentInjector)) {
        return;
    }
    // If our injector hasn't been mapped, then we map it to the standalone component
    standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value) {
    const def = getComponentDef(value);
    return !!def?.standalone;
}
/**
 *
 * Stores the emitted ProviderRecords from the InjectorProfilerEventType.ProviderConfigured
 * event in frameworkDIDebugData.resolverToProviders
 *
 * @param context InjectorProfilerContext the injection context that this event occurred in.
 * @param data ProviderRecord an object containing the instance that was just created
 *
 */
function handleProviderConfiguredEvent(context, data) {
    const { resolverToProviders } = frameworkDIDebugData;
    let diResolver;
    if (context?.injector instanceof NodeInjector) {
        diResolver = getNodeInjectorTNode(context.injector);
    }
    else {
        diResolver = context.injector;
    }
    if (diResolver === null) {
        throwError('A ProviderConfigured event must be run within an injection context.');
    }
    if (!resolverToProviders.has(diResolver)) {
        resolverToProviders.set(diResolver, []);
    }
    resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
    let diResolver = null;
    if (injector === undefined) {
        return diResolver;
    }
    // We use the LView as the diResolver for NodeInjectors because they
    // do not persist anywhere in the framework. They are simply wrappers around an LView and a TNode
    // that do persist. Because of this, we rely on the LView of the NodeInjector in order to use
    // as a concrete key to represent this injector. If we get the same LView back later, we know
    // we're looking at the same injector.
    if (injector instanceof NodeInjector) {
        diResolver = getNodeInjectorLView(injector);
    }
    // Other injectors can be used a keys for a map because their instances
    // persist
    else {
        diResolver = injector;
    }
    return diResolver;
}
// inspired by
// https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-canbeheldweakly
function canBeHeldWeakly(value) {
    // we check for value !== null here because typeof null === 'object
    return (value !== null &&
        (typeof value === 'object' || typeof value === 'function' || typeof value === 'symbol'));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWV3b3JrX2luamVjdG9yX3Byb2ZpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9kZWJ1Zy9mcmFtZXdvcmtfaW5qZWN0b3JfcHJvZmlsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBR0gsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFekQsT0FBTyxFQUFDLGFBQWEsRUFBRSxVQUFVLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM1RCxPQUFPLEVBQWMsbUJBQW1CLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDM0QsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5QyxPQUFPLEVBQUMsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsWUFBWSxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBSS9FLE9BQU8sRUFPTCxtQkFBbUIsR0FDcEIsTUFBTSxxQkFBcUIsQ0FBQztBQUU3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtDRztBQUNILE1BQU0sV0FBVztJQUFqQjtRQUNFLGtDQUE2QixHQUFHLElBQUksT0FBTyxFQUd4QyxDQUFDO1FBQ0osd0JBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQXNDLENBQUM7UUFDeEUsa0NBQTZCLEdBQUcsSUFBSSxPQUFPLEVBQTJCLENBQUM7SUFVekUsQ0FBQztJQVJDLEtBQUs7UUFDSCxJQUFJLENBQUMsNkJBQTZCLEdBQUcsSUFBSSxPQUFPLEVBRzdDLENBQUM7UUFDSixJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxPQUFPLEVBQXNDLENBQUM7UUFDN0UsSUFBSSxDQUFDLDZCQUE2QixHQUFHLElBQUksT0FBTyxFQUEyQixDQUFDO0lBQzlFLENBQUM7Q0FDRjtBQUVELElBQUksb0JBQW9CLEdBQUcsSUFBSSxXQUFXLEVBQUUs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Q0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztRQUN6QyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxRQUE4QjtJQUNuRCxJQUFJLFVBQVUsR0FBNEIsSUFBSSxDQUFDO0lBRS9DLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRSxDQUFDO1FBQzNCLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxvRUFBb0U7SUFDcEUsaUdBQWlHO0lBQ2pHLDZGQUE2RjtJQUM3Riw2RkFBNkY7SUFDN0Ysc0NBQXNDO0lBQ3RDLElBQUksUUFBUSxZQUFZLFlBQVksRUFBRSxDQUFDO1FBQ3JDLFVBQVUsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBQ0QsdUVBQXVFO0lBQ3ZFLFVBQVU7U0FDTCxDQUFDO1FBQ0osVUFBVSxHQUFHLFFBQVEsQ0FBQztJQUN4QixDQUFDO0lBRUQsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVELGNBQWM7QUFDZCxvR0FBb0c7QUFDcEcsU0FBUyxlQUFlLENBQUMsS0FBVTtJQUNqQyxtRUFBbUU7SUFDbkUsT0FBTyxDQUNMLEtBQUssS0FBSyxJQUFJO1FBQ2QsQ0FBQyxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksT0FBTyxLQUFLLEtBQUssVUFBVSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUN4RixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0luamVjdG9yfSBmcm9tICcuLi8uLi9kaS9pbmplY3Rvcic7XG5pbXBvcnQge0Vudmlyb25tZW50SW5qZWN0b3J9IGZyb20gJy4uLy4uL2RpL3IzX2luamVjdG9yJztcbmltcG9ydCB7VHlwZX0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlL3R5cGUnO1xuaW1wb3J0IHthc3NlcnREZWZpbmVkLCB0aHJvd0Vycm9yfSBmcm9tICcuLi8uLi91dGlsL2Fzc2VydCc7XG5pbXBvcnQge2Fzc2VydFROb2RlLCBhc3NlcnRUTm9kZUZvckxWaWV3fSBmcm9tICcuLi9hc3NlcnQnO1xuaW1wb3J0IHtnZXRDb21wb25lbnREZWZ9IGZyb20gJy4uL2RlZmluaXRpb24nO1xuaW1wb3J0IHtnZXROb2RlSW5qZWN0b3JMVmlldywgZ2V0Tm9kZUluamVjdG9yVE5vZGUsIE5vZGVJbmplY3Rvcn0gZnJvbSAnLi4vZGknO1xuaW1wb3J0IHtUTm9kZX0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ub2RlJztcbmltcG9ydCB7TFZpZXd9IGZyb20gJy4uL2ludGVyZmFjZXMvdmlldyc7XG5cbmltcG9ydCB7XG4gIEluamVjdGVkU2VydmljZSxcbiAgSW5qZWN0b3JDcmVhdGVkSW5zdGFuY2UsXG4gIEluamVjdG9yUHJvZmlsZXJDb250ZXh0LFxuICBJbmplY3RvclByb2ZpbGVyRXZlbnQsXG4gIEluamVjdG9yUHJvZmlsZXJFdmVudFR5cGUsXG4gIFByb3ZpZGVyUmVjb3JkLFxuICBzZXRJbmplY3RvclByb2ZpbGVyLFxufSBmcm9tICcuL2luamVjdG9yX3Byb2ZpbGVyJztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIGRhdGEgc3RydWN0dXJlcyB0aGF0IG91ciBmcmFtZXdvcmsgaW5qZWN0b3IgcHJvZmlsZXIgd2lsbCBmaWxsIHdpdGggZGF0YSBpbiBvcmRlclxuICogdG8gc3VwcG9ydCBESSBkZWJ1Z2dpbmcgQVBJcy5cbiAqXG4gKiByZXNvbHZlclRvVG9rZW5Ub0RlcGVuZGVuY2llczogTWFwcyBhbiBpbmplY3RvciB0byBhIE1hcCBvZiB0b2tlbnMgdG8gYW4gQXJyYXkgb2ZcbiAqIGRlcGVuZGVuY2llcy4gSW5qZWN0b3IgLT4gVG9rZW4gLT4gRGVwZW5kZW5jaWVzIFRoaXMgaXMgdXNlZCB0byBzdXBwb3J0IHRoZVxuICogZ2V0RGVwZW5kZW5jaWVzRnJvbUluamVjdGFibGUgQVBJLCB3aGljaCB0YWtlcyBpbiBhbiBpbmplY3RvciBhbmQgYSB0b2tlbiBhbmQgcmV0dXJucyBpdCdzXG4gKiBkZXBlbmRlbmNpZXMuXG4gKlxuICogcmVzb2x2ZXJUb1Byb3ZpZGVyczogTWFwcyBhIERJIHJlc29sdmVyIChhbiBJbmplY3RvciBvciBhIFROb2RlKSB0byB0aGUgcHJvdmlkZXJzIGNvbmZpZ3VyZWRcbiAqIHdpdGhpbiBpdCBUaGlzIGlzIHVzZWQgdG8gc3VwcG9ydCB0aGUgZ2V0SW5qZWN0b3JQcm92aWRlcnMgQVBJLCB3aGljaCB0YWtlcyBpbiBhbiBpbmplY3RvciBhbmRcbiAqIHJldHVybnMgdGhlIHByb3ZpZGVycyB0aGF0IGl0IHdhcyBjb25maWd1cmVkIHdpdGguIE5vdGUgdGhhdCBmb3IgdGhlIGVsZW1lbnQgaW5qZWN0b3IgY2FzZSB3ZVxuICogdXNlIHRoZSBUTm9kZSBpbnN0ZWFkIG9mIHRoZSBMVmlldyBhcyB0aGUgREkgcmVzb2x2ZXIuIFRoaXMgaXMgYmVjYXVzZSB0aGUgcmVnaXN0cmF0aW9uIG9mXG4gKiBwcm92aWRlcnMgaGFwcGVucyBvbmx5IG9uY2UgcGVyIHR5cGUgb2YgVE5vZGUuIElmIGFuIGluamVjdG9yIGlzIGNyZWF0ZWQgd2l0aCBhbiBpZGVudGljYWwgVE5vZGUsXG4gKiB0aGUgcHJvdmlkZXJzIGZvciB0aGF0IGluamVjdG9yIHdpbGwgbm90IGJlIHJlY29uZmlndXJlZC5cbiAqXG4gKiBzdGFuZGFsb25lSW5qZWN0b3JUb0NvbXBvbmVudDogTWFwcyB0aGUgaW5qZWN0b3Igb2YgYSBzdGFuZGFsb25lIGNvbXBvbmVudCB0byB0aGUgc3RhbmRhbG9uZVxuICogY29tcG9uZW50IHRoYXQgaXQgaXMgYXNzb2NpYXRlZCB3aXRoLiBVc2VkIGluIHRoZSBnZXRJbmplY3RvclByb3ZpZGVycyBBUEksIHNwZWNpZmljaWFsbHkgaW4gdGhlXG4gKiBkaXNjb3Zlcnkgb2YgaW1wb3J0IHBhdGhzIGZvciBlYWNoIHByb3ZpZGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBpbXBvcnRzIGFycmF5IG9mIGFcbiAqIHN0YW5kYWxvbmUgY29tcG9uZW50IGlzIHByb2Nlc3NlZCBhbmQgY29uZmlndXJlZCBpbiBpdHMgc3RhbmRhbG9uZSBpbmplY3RvciwgYnV0IGV4aXN0cyB3aXRoaW5cbiAqIHRoZSBjb21wb25lbnQncyBkZWZpbml0aW9uLiBCZWNhdXNlIGdldEluamVjdG9yUHJvdmlkZXJzIHRha2VzIGluIGFuIGluamVjdG9yLCBpZiB0aGF0IGluamVjdG9yXG4gKiBpcyB0aGUgaW5qZWN0b3Igb2YgYSBzdGFuZGFsb25lIGNvbXBvbmVudCwgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc2NvdmVyIHRoZSBwbGFjZSB3aGVyZSB0aGVcbiAqIGltcG9ydHMgYXJyYXkgaXMgbG9jYXRlZCAodGhlIGNvbXBvbmVudCkgaW4gb3JkZXIgdG8gZmxhdHRlbiB0aGUgaW1wb3J0cyBhcnJheSB3aXRoaW4gaXQgdG9cbiAqIGRpc2NvdmVyIGFsbCBvZiBpdCdzIHByb3ZpZGVycy5cbiAqXG4gKlxuICogQWxsIG9mIHRoZXNlIGRhdGEgc3RydWN0dXJlcyBhcmUgaW5zdGFudGlhdGVkIHdpdGggV2Vha01hcHMuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgcHJlc2VuY2VcbiAqIG9mIGFueSBvYmplY3QgaW4gdGhlIGtleXMgb2YgdGhlc2UgbWFwcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBnYXJiYWdlIGNvbGxlY3RvciBmcm9tIGNvbGxlY3RpbmdcbiAqIHRob3NlIG9iamVjdHMuIEJlY2F1c2Ugb2YgdGhpcyBwcm9wZXJ0eSBvZiBXZWFrTWFwcywgdGhlc2UgZGF0YSBzdHJ1Y3R1cmVzIHdpbGwgbmV2ZXIgYmUgdGhlXG4gKiBzb3VyY2Ugb2YgYSBtZW1vcnkgbGVhay5cbiAqXG4gKiBBbiBleGFtcGxlIG9mIHRoaXMgYWR2YW50YWdlOiBXaGVuIGNvbXBvbmVudHMgYXJlIGRlc3Ryb3llZCwgd2UgZG9uJ3QgbmVlZCB0byBkb1xuICogYW55IGFkZGl0aW9uYWwgd29yayB0byByZW1vdmUgdGhhdCBjb21wb25lbnQgZnJvbSBvdXIgbWFwcGluZ3MuXG4gKlxuICovXG5jbGFzcyBESURlYnVnRGF0YSB7XG4gIHJlc29sdmVyVG9Ub2tlblRvRGVwZW5kZW5jaWVzID0gbmV3IFdlYWtNYXA8XG4gICAgSW5qZWN0b3IgfCBMVmlldyxcbiAgICBXZWFrTWFwPFR5cGU8dW5rbm93bj4sIEluamVjdGVkU2VydmljZVtdPlxuICA+KCk7XG4gIHJlc29sdmVyVG9Qcm92aWRlcnMgPSBuZXcgV2Vha01hcDxJbmplY3RvciB8IFROb2RlLCBQcm92aWRlclJlY29yZFtdPigpO1xuICBzdGFuZGFsb25lSW5qZWN0b3JUb0NvbXBvbmVudCA9IG5ldyBXZWFrTWFwPEluamVjdG9yLCBUeXBlPHVua25vd24+PigpO1xuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmVzb2x2ZXJUb1Rva2VuVG9EZXBlbmRlbmNpZXMgPSBuZXcgV2Vha01hcDxcbiAgICAgIEluamVjdG9yIHwgTFZpZXcsXG4gICAgICBXZWFrTWFwPFR5cGU8dW5rbm93bj4sIEluamVjdGVkU2VydmljZVtdPlxuICAgID4oKTtcbiAgICB0aGlzLnJlc29sdmVyVG9Qcm92aWRlcnMgPSBuZXcgV2Vha01hcDxJbmplY3RvciB8IFROb2RlLCBQcm92aWRlclJlY29yZFtdPigpO1xuICAgIHRoaXMuc3RhbmRhbG9uZUluamVjdG9yVG9Db21wb25lbnQgPSBuZXcgV2Vha01hcDxJbmplY3RvciwgVHlwZTx1bmtub3duPj4oKTtcbiAgfVxufVxuXG5sZXQgZnJhbWV3b3JrRElEZWJ1Z0RhdGEgPSBuZXcgRElEZWJ1Z0RhdGEoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYW1ld29ya0RJRGVidWdEYXRhKCk6IERJRGVidWdEYXRhIHtcbiAgcmV0dXJuIGZyYW1ld29ya0RJRGVidWdEYXRhO1xufVxuXG4vKipcbiAqIEluaXRhbGl6ZSBkZWZhdWx0IGhhbmRsaW5nIG9mIGluamVjdG9yIGV2ZW50cy4gVGhpcyBoYW5kbGluZyBwYXJzZXMgZXZlbnRzXG4gKiBhcyB0aGV5IGFyZSBlbWl0dGVkIGFuZCBjb25zdHJ1Y3RzIHRoZSBkYXRhIHN0cnVjdHVyZXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcbiAqIHNvbWUgb2YgZGVidWcgQVBJcy5cbiAqXG4gKiBTZWUgaGFuZGxlSW5qZWN0RXZlbnQsIGhhbmRsZUNyZWF0ZUV2ZW50IGFuZCBoYW5kbGVQcm92aWRlckNvbmZpZ3VyZWRFdmVudFxuICogZm9yIGRlc2NyaXB0aW9ucyBvZiBlYWNoIGhhbmRsZXJcbiAqXG4gKiBTdXBwb3J0ZWQgQVBJczpcbiAqICAgICAgICAgICAgICAgLSBnZXREZXBlbmRlbmNpZXNGcm9tSW5qZWN0YWJsZVxuICogICAgICAgICAgICAgICAtIGdldEluamVjdG9yUHJvdmlkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cEZyYW1ld29ya0luamVjdG9yUHJvZmlsZXIoKTogdm9pZCB7XG4gIGZyYW1ld29ya0RJRGVidWdEYXRhLnJlc2V0KCk7XG4gIHNldEluamVjdG9yUHJvZmlsZXIoKGluamVjdG9yUHJvZmlsZXJFdmVudCkgPT5cbiAgICBoYW5kbGVJbmplY3RvclByb2ZpbGVyRXZlbnQoaW5qZWN0b3JQcm9maWxlckV2ZW50KSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlSW5qZWN0b3JQcm9maWxlckV2ZW50KGluamVjdG9yUHJvZmlsZXJFdmVudDogSW5qZWN0b3JQcm9maWxlckV2ZW50KTogdm9pZCB7XG4gIGNvbnN0IHtjb250ZXh0LCB0eXBlfSA9IGluamVjdG9yUHJvZmlsZXJFdmVudDtcblxuICBpZiAodHlwZSA9PT0gSW5qZWN0b3JQcm9maWxlckV2ZW50VHlwZS5JbmplY3QpIHtcbiAgICBoYW5kbGVJbmplY3RFdmVudChjb250ZXh0LCBpbmplY3RvclByb2ZpbGVyRXZlbnQuc2VydmljZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gSW5qZWN0b3JQcm9maWxlckV2ZW50VHlwZS5JbnN0YW5jZUNyZWF0ZWRCeUluamVjdG9yKSB7XG4gICAgaGFuZGxlSW5zdGFuY2VDcmVhdGVkQnlJbmplY3RvckV2ZW50KGNvbnRleHQsIGluamVjdG9yUHJvZmlsZXJFdmVudC5pbnN0YW5jZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gSW5qZWN0b3JQcm9maWxlckV2ZW50VHlwZS5Qcm92aWRlckNvbmZpZ3VyZWQpIHtcbiAgICBoYW5kbGVQcm92aWRlckNvbmZpZ3VyZWRFdmVudChjb250ZXh0LCBpbmplY3RvclByb2ZpbGVyRXZlbnQucHJvdmlkZXJSZWNvcmQpO1xuICB9XG59XG5cbi8qKlxuICpcbiAqIFN0b3JlcyB0aGUgaW5qZWN0ZWQgc2VydmljZSBpbiBmcmFtZXdvcmtESURlYnVnRGF0YS5yZXNvbHZlclRvVG9rZW5Ub0RlcGVuZGVuY2llc1xuICogYmFzZWQgb24gaXQncyBpbmplY3RvciBhbmQgdG9rZW4uXG4gKlxuICogQHBhcmFtIGNvbnRleHQgSW5qZWN0b3JQcm9maWxlckNvbnRleHQgdGhlIGluamVjdGlvbiBjb250ZXh0IHRoYXQgdGhpcyBldmVudCBvY2N1cnJlZCBpbi5cbiAqIEBwYXJhbSBkYXRhIEluamVjdGVkU2VydmljZSB0aGUgc2VydmljZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmplY3QgZXZlbnQuXG4gKlxuICovXG5mdW5jdGlvbiBoYW5kbGVJbmplY3RFdmVudChjb250ZXh0OiBJbmplY3RvclByb2ZpbGVyQ29udGV4dCwgZGF0YTogSW5qZWN0ZWRTZXJ2aWNlKSB7XG4gIGNvbnN0IGRpUmVzb2x2ZXIgPSBnZXRESVJlc29sdmVyKGNvbnRleHQuaW5qZWN0b3IpO1xuICBpZiAoZGlSZXNvbHZlciA9PT0gbnVsbCkge1xuICAgIHRocm93RXJyb3IoJ0FuIEluamVjdCBldmVudCBtdXN0IGJlIHJ1biB3aXRoaW4gYW4gaW5qZWN0aW9uIGNvbnRleHQuJyk7XG4gIH1cblxuICBjb25zdCBkaVJlc29sdmVyVG9JbnN0YW50aWF0ZWRUb2tlbiA9IGZyYW1ld29ya0RJRGVidWdEYXRhLnJlc29sdmVyVG9Ub2tlblRvRGVwZW5kZW5jaWVzO1xuXG4gIGlmICghZGlSZXNvbHZlclRvSW5zdGFudGlhdGVkVG9rZW4uaGFzKGRpUmVzb2x2ZXIpKSB7XG4gICAgZGlSZXNvbHZlclRvSW5zdGFudGlhdGVkVG9rZW4uc2V0KGRpUmVzb2x2ZXIsIG5ldyBXZWFrTWFwPFR5cGU8dW5rbm93bj4sIEluamVjdGVkU2VydmljZVtdPigpKTtcbiAgfVxuXG4gIC8vIGlmIHRva2VuIGlzIGEgcHJpbWl0aXZlIHR5cGUsIGlnbm9yZSB0aGlzIGV2ZW50LiBXZSBkbyB0aGlzIGJlY2F1c2Ugd2UgY2Fubm90IGtlZXAgdHJhY2sgb2ZcbiAgLy8gbm9uLXByaW1pdGl2ZSB0b2tlbnMgaW4gV2Vha01hcHMgc2luY2UgdGhleSBhcmUgbm90IGdhcmJhZ2UgY29sbGVjdGFibGUuXG4gIGlmICghY2FuQmVIZWxkV2Vha2x5KGNvbnRleHQudG9rZW4pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaW5zdGFudGlhdGVkVG9rZW5Ub0RlcGVuZGVuY2llcyA9IGRpUmVzb2x2ZXJUb0luc3RhbnRpYXRlZFRva2VuLmdldChkaVJlc29sdmVyKSE7XG4gIGlmICghaW5zdGFudGlhdGVkVG9rZW5Ub0RlcGVuZGVuY2llcy5oYXMoY29udGV4dC50b2tlbiEpKSB7XG4gICAgaW5zdGFudGlhdGVkVG9rZW5Ub0RlcGVuZGVuY2llcy5zZXQoY29udGV4dC50b2tlbiEsIFtdKTtcbiAgfVxuXG4gIGNvbnN0IHt0b2tlbiwgdmFsdWUsIGZsYWdzfSA9IGRhdGE7XG5cbiAgYXNzZXJ0RGVmaW5lZChjb250ZXh0LnRva2VuLCAnSW5qZWN0b3IgcHJvZmlsZXIgY29udGV4dCB0b2tlbiBpcyB1bmRlZmluZWQuJyk7XG5cbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gaW5zdGFudGlhdGVkVG9rZW5Ub0RlcGVuZGVuY2llcy5nZXQoY29udGV4dC50b2tlbik7XG4gIGFzc2VydERlZmluZWQoZGVwZW5kZW5jaWVzLCAnQ291bGQgbm90IHJlc29sdmUgZGVwZW5kZW5jaWVzIGZvciB0b2tlbi4nKTtcblxuICBpZiAoY29udGV4dC5pbmplY3RvciBpbnN0YW5jZW9mIE5vZGVJbmplY3Rvcikge1xuICAgIGRlcGVuZGVuY2llcy5wdXNoKHt0b2tlbiwgdmFsdWUsIGZsYWdzLCBpbmplY3RlZEluOiBnZXROb2RlSW5qZWN0b3JDb250ZXh0KGNvbnRleHQuaW5qZWN0b3IpfSk7XG4gIH0gZWxzZSB7XG4gICAgZGVwZW5kZW5jaWVzLnB1c2goe3Rva2VuLCB2YWx1ZSwgZmxhZ3N9KTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBSZXR1cm5zIHRoZSBMVmlldyBhbmQgVE5vZGUgYXNzb2NpYXRlZCB3aXRoIGEgTm9kZUluamVjdG9yLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgaW5qZWN0b3JcbiAqIGlzIG5vdCBhIE5vZGVJbmplY3Rvci5cbiAqXG4gKiBAcGFyYW0gaW5qZWN0b3JcbiAqIEByZXR1cm5zIHtsVmlldzogTFZpZXcsIHROb2RlOiBUTm9kZX18dW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVJbmplY3RvckNvbnRleHQoaW5qZWN0b3I6IEluamVjdG9yKToge2xWaWV3OiBMVmlldzsgdE5vZGU6IFROb2RlfSB8IHVuZGVmaW5lZCB7XG4gIGlmICghKGluamVjdG9yIGluc3RhbmNlb2YgTm9kZUluamVjdG9yKSkge1xuICAgIHRocm93RXJyb3IoJ2dldE5vZGVJbmplY3RvckNvbnRleHQgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIE5vZGVJbmplY3RvcicpO1xuICB9XG5cbiAgY29uc3QgbFZpZXcgPSBnZXROb2RlSW5qZWN0b3JMVmlldyhpbmplY3Rvcik7XG4gIGNvbnN0IHROb2RlID0gZ2V0Tm9kZUluamVjdG9yVE5vZGUoaW5qZWN0b3IpO1xuICBpZiAodE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3NlcnRUTm9kZUZvckxWaWV3KHROb2RlLCBsVmlldyk7XG5cbiAgcmV0dXJuIHtsVmlldywgdE5vZGV9O1xufVxuXG4vKipcbiAqXG4gKiBJZiB0aGUgY3JlYXRlZCBpbnN0YW5jZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHN0YW5kYWxvbmUgY29tcG9uZW50LCBtYXBzIHRoZSBpbmplY3RvciB0byB0aGF0XG4gKiBzdGFuZGFsb25lIGNvbXBvbmVudCBpbiBmcmFtZXdvcmtESURlYnVnRGF0YS5zdGFuZGFsb25lSW5qZWN0b3JUb0NvbXBvbmVudFxuICpcbiAqIEBwYXJhbSBjb250ZXh0IEluamVjdG9yUHJvZmlsZXJDb250ZXh0IHRoZSBpbmplY3Rpb24gY29udGV4dCB0aGF0IHRoaXMgZXZlbnQgb2NjdXJyZWQgaW4uXG4gKiBAcGFyYW0gZGF0YSBJbmplY3RvckNyZWF0ZWRJbnN0YW5jZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgaW5zdGFuY2UgdGhhdCB3YXMganVzdCBjcmVhdGVkXG4gKlxuICovXG5mdW5jdGlvbiBoYW5kbGVJbnN0YW5jZUNyZWF0ZWRCeUluamVjdG9yRXZlbnQoXG4gIGNvbnRleHQ6IEluamVjdG9yUHJvZmlsZXJDb250ZXh0LFxuICBkYXRhOiBJbmplY3RvckNyZWF0ZWRJbnN0YW5jZSxcbik6IHZvaWQge1xuICBjb25zdCB7dmFsdWV9ID0gZGF0YTtcblxuICBpZiAoZ2V0RElSZXNvbHZlcihjb250ZXh0LmluamVjdG9yKSA9PT0gbnVsbCkge1xuICAgIHRocm93RXJyb3IoJ0FuIEluamVjdG9yQ3JlYXRlZEluc3RhbmNlIGV2ZW50IG11c3QgYmUgcnVuIHdpdGhpbiBhbiBpbmplY3Rpb24gY29udGV4dC4nKTtcbiAgfVxuXG4gIC8vIGlmIG91ciB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHN0YW5kYWxvbmUgY29tcG9uZW50LCBtYXAgdGhlIGluamVjdG9yIG9mIHRoYXQgc3RhbmRhbG9uZVxuICAvLyBjb21wb25lbnQgdG8gdGhlIGNvbXBvbmVudCBjbGFzcy4gT3RoZXJ3aXNlLCB0aGlzIGV2ZW50IGlzIGEgbm9vcC5cbiAgbGV0IHN0YW5kYWxvbmVDb21wb25lbnQ6IFR5cGU8dW5rbm93bj4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgc3RhbmRhbG9uZUNvbXBvbmVudCA9IHZhbHVlPy5jb25zdHJ1Y3RvciBhcyBUeXBlPHVua25vd24+O1xuICB9XG4gIGlmIChzdGFuZGFsb25lQ29tcG9uZW50ID09PSB1bmRlZmluZWQgfHwgIWlzU3RhbmRhbG9uZUNvbXBvbmVudChzdGFuZGFsb25lQ29tcG9uZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGVudmlyb25tZW50SW5qZWN0b3I6IEVudmlyb25tZW50SW5qZWN0b3IgfCBudWxsID0gY29udGV4dC5pbmplY3Rvci5nZXQoXG4gICAgRW52aXJvbm1lbnRJbmplY3RvcixcbiAgICBudWxsLFxuICAgIHtvcHRpb25hbDogdHJ1ZX0sXG4gICk7XG4gIC8vIFN0YW5kYWxvbmUgY29tcG9uZW50cyBzaG91bGQgaGF2ZSBhbiBlbnZpcm9ubWVudCBpbmplY3Rvci4gSWYgb25lIGNhbm5vdCBiZVxuICAvLyBmb3VuZCB3ZSBtYXkgYmUgaW4gYSB0ZXN0IGNhc2UgZm9yIGxvdyBsZXZlbCBmdW5jdGlvbmFsaXR5IHRoYXQgZGlkIG5vdCBleHBsaWNpdGx5XG4gIC8vIHNldHVwIHRoaXMgaW5qZWN0b3IuIEluIHRob3NlIGNhc2VzLCB3ZSBzaW1wbHkgaWdub3JlIHRoaXMgZXZlbnQuXG4gIGlmIChlbnZpcm9ubWVudEluamVjdG9yID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge3N0YW5kYWxvbmVJbmplY3RvclRvQ29tcG9uZW50fSA9IGZyYW1ld29ya0RJRGVidWdEYXRhO1xuXG4gIC8vIElmIG91ciBpbmplY3RvciBoYXMgYWxyZWFkeSBiZWVuIG1hcHBlZCwgYXMgaXMgdGhlIGNhc2VcbiAgLy8gd2hlbiBhIHN0YW5kYWxvbmUgY29tcG9uZW50IGltcG9ydHMgYW5vdGhlciBzdGFuZGFsb25lIGNvbXBvbmVudCxcbiAgLy8gd2UgY29uc2lkZXIgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCAodGhlIGNvbXBvbmVudCBkb2luZyB0aGUgaW1wb3J0aW5nKVxuICAvLyBhcyB0aGUgY29tcG9uZW50IGNvbm5lY3RlZCB0byBvdXIgaW5qZWN0b3IuXG4gIGlmIChzdGFuZGFsb25lSW5qZWN0b3JUb0NvbXBvbmVudC5oYXMoZW52aXJvbm1lbnRJbmplY3RvcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gSWYgb3VyIGluamVjdG9yIGhhc24ndCBiZWVuIG1hcHBlZCwgdGhlbiB3ZSBtYXAgaXQgdG8gdGhlIHN0YW5kYWxvbmUgY29tcG9uZW50XG4gIHN0YW5kYWxvbmVJbmplY3RvclRvQ29tcG9uZW50LnNldChlbnZpcm9ubWVudEluamVjdG9yLCBzdGFuZGFsb25lQ29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTdGFuZGFsb25lQ29tcG9uZW50KHZhbHVlOiBUeXBlPHVua25vd24+KTogYm9vbGVhbiB7XG4gIGNvbnN0IGRlZiA9IGdldENvbXBvbmVudERlZih2YWx1ZSk7XG4gIHJldHVybiAhIWRlZj8uc3RhbmRhbG9uZTtcbn1cblxuLyoqXG4gKlxuICogU3RvcmVzIHRoZSBlbWl0dGVkIFByb3ZpZGVyUmVjb3JkcyBmcm9tIHRoZSBJbmplY3RvclByb2ZpbGVyRXZlbnRUeXBlLlByb3ZpZGVyQ29uZmlndXJlZFxuICogZXZlbnQgaW4gZnJhbWV3b3JrRElEZWJ1Z0RhdGEucmVzb2x2ZXJUb1Byb3ZpZGVyc1xuICpcbiAqIEBwYXJhbSBjb250ZXh0IEluamVjdG9yUHJvZmlsZXJDb250ZXh0IHRoZSBpbmplY3Rpb24gY29udGV4dCB0aGF0IHRoaXMgZXZlbnQgb2NjdXJyZWQgaW4uXG4gKiBAcGFyYW0gZGF0YSBQcm92aWRlclJlY29yZCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgaW5zdGFuY2UgdGhhdCB3YXMganVzdCBjcmVhdGVkXG4gKlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm92aWRlckNvbmZpZ3VyZWRFdmVudChcbiAgY29udGV4dDogSW5qZWN0b3JQcm9maWxlckNvbnRleHQsXG4gIGRhdGE6IFByb3ZpZGVyUmVjb3JkLFxuKTogdm9pZCB7XG4gIGNvbnN0IHtyZXNvbHZlclRvUHJvdmlkZXJzfSA9IGZyYW1ld29ya0RJRGVidWdEYXRhO1xuXG4gIGxldCBkaVJlc29sdmVyOiBJbmplY3RvciB8IFROb2RlO1xuICBpZiAoY29udGV4dD8uaW5qZWN0b3IgaW5zdGFuY2VvZiBOb2RlSW5qZWN0b3IpIHtcbiAgICBkaVJlc29sdmVyID0gZ2V0Tm9kZUluamVjdG9yVE5vZGUoY29udGV4dC5pbmplY3RvcikgYXMgVE5vZGU7XG4gIH0gZWxzZSB7XG4gICAgZGlSZXNvbHZlciA9IGNvbnRleHQuaW5qZWN0b3I7XG4gIH1cblxuICBpZiAoZGlSZXNvbHZlciA9PT0gbnVsbCkge1xuICAgIHRocm93RXJyb3IoJ0EgUHJvdmlkZXJDb25maWd1cmVkIGV2ZW50IG11c3QgYmUgcnVuIHdpdGhpbiBhbiBpbmplY3Rpb24gY29udGV4dC4nKTtcbiAgfVxuXG4gIGlmICghcmVzb2x2ZXJUb1Byb3ZpZGVycy5oYXMoZGlSZXNvbHZlcikpIHtcbiAgICByZXNvbHZlclRvUHJvdmlkZXJzLnNldChkaVJlc29sdmVyLCBbXSk7XG4gIH1cblxuICByZXNvbHZlclRvUHJvdmlkZXJzLmdldChkaVJlc29sdmVyKSEucHVzaChkYXRhKTtcbn1cblxuZnVuY3Rpb24gZ2V0RElSZXNvbHZlcihpbmplY3RvcjogSW5qZWN0b3IgfCB1bmRlZmluZWQpOiBJbmplY3RvciB8IExWaWV3IHwgbnVsbCB7XG4gIGxldCBkaVJlc29sdmVyOiBJbmplY3RvciB8IExWaWV3IHwgbnVsbCA9IG51bGw7XG5cbiAgaWYgKGluamVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGlSZXNvbHZlcjtcbiAgfVxuXG4gIC8vIFdlIHVzZSB0aGUgTFZpZXcgYXMgdGhlIGRpUmVzb2x2ZXIgZm9yIE5vZGVJbmplY3RvcnMgYmVjYXVzZSB0aGV5XG4gIC8vIGRvIG5vdCBwZXJzaXN0IGFueXdoZXJlIGluIHRoZSBmcmFtZXdvcmsuIFRoZXkgYXJlIHNpbXBseSB3cmFwcGVycyBhcm91bmQgYW4gTFZpZXcgYW5kIGEgVE5vZGVcbiAgLy8gdGhhdCBkbyBwZXJzaXN0LiBCZWNhdXNlIG9mIHRoaXMsIHdlIHJlbHkgb24gdGhlIExWaWV3IG9mIHRoZSBOb2RlSW5qZWN0b3IgaW4gb3JkZXIgdG8gdXNlXG4gIC8vIGFzIGEgY29uY3JldGUga2V5IHRvIHJlcHJlc2VudCB0aGlzIGluamVjdG9yLiBJZiB3ZSBnZXQgdGhlIHNhbWUgTFZpZXcgYmFjayBsYXRlciwgd2Uga25vd1xuICAvLyB3ZSdyZSBsb29raW5nIGF0IHRoZSBzYW1lIGluamVjdG9yLlxuICBpZiAoaW5qZWN0b3IgaW5zdGFuY2VvZiBOb2RlSW5qZWN0b3IpIHtcbiAgICBkaVJlc29sdmVyID0gZ2V0Tm9kZUluamVjdG9yTFZpZXcoaW5qZWN0b3IpO1xuICB9XG4gIC8vIE90aGVyIGluamVjdG9ycyBjYW4gYmUgdXNlZCBhIGtleXMgZm9yIGEgbWFwIGJlY2F1c2UgdGhlaXIgaW5zdGFuY2VzXG4gIC8vIHBlcnNpc3RcbiAgZWxzZSB7XG4gICAgZGlSZXNvbHZlciA9IGluamVjdG9yO1xuICB9XG5cbiAgcmV0dXJuIGRpUmVzb2x2ZXI7XG59XG5cbi8vIGluc3BpcmVkIGJ5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi9tdWx0aXBhZ2UvZXhlY3V0YWJsZS1jb2RlLWFuZC1leGVjdXRpb24tY29udGV4dHMuaHRtbCNzZWMtY2FuYmVoZWxkd2Vha2x5XG5mdW5jdGlvbiBjYW5CZUhlbGRXZWFrbHkodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAvLyB3ZSBjaGVjayBmb3IgdmFsdWUgIT09IG51bGwgaGVyZSBiZWNhdXNlIHR5cGVvZiBudWxsID09PSAnb2JqZWN0XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJylcbiAgKTtcbn1cbiJdfQ==