/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { assertInInjectionContext, assertNotInReactiveContext, computed, DestroyRef, inject, signal, ɵRuntimeError, } from '@angular/core';
/**
 * Get the current value of an `Observable` as a reactive `Signal`.
 *
 * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced
 * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always
 * have the most recent value emitted by the subscription, and will throw an error if the
 * `Observable` errors.
 *
 * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value
 * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal
 * does not include an `undefined` type.
 *
 * By default, the subscription will be automatically cleaned up when the current [injection
 * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is
 * called during the construction of a component, the subscription will be cleaned up when the
 * component is destroyed. If an injection context is not available, an explicit `Injector` can be
 * passed instead.
 *
 * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`
 * option can be specified instead, which disables the automatic subscription teardown. No injection
 * context is needed in this configuration as well.
 *
 * @developerPreview
 */
export function toSignal(source, options) {
    ngDevMode &&
        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +
            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');
    const requiresCleanup = !options?.manualCleanup;
    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);
    const cleanupRef = requiresCleanup
        ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef)
        : null;
    // Note: T is the Observable value type, and U is the initial value type. They don't have to be
    // the same - the returned signal gives values of type `T`.
    let state;
    if (options?.requireSync) {
        // Initially the signal is in a `NoValue` state.
        state = signal({ kind: 0 /* StateKind.NoValue */ });
    }
    else {
        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.
        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });
    }
    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support
    // this, we would subscribe to the observable outside of the current reactive context, avoiding
    // that side-effect signal reads/writes are attribute to the current consumer. The current
    // consumer only needs to be notified when the `state` signal changes through the observable
    // subscription. Additional context (related to async pipe):
    // https://github.com/angular/angular/pull/50522.
    const sub = source.subscribe({
        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),
        error: (error) => {
            if (options?.rejectErrors) {
                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes
                // the error to end up as an uncaught exception.
                throw error;
            }
            state.set({ kind: 2 /* StateKind.Error */, error });
        },
        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of
        // "complete".
    });
    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {
        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
    }
    // Unsubscribe when the current context is destroyed, if requested.
    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
    // The actual returned signal is a `computed` of the `State` signal, which maps the various states
    // to either values or errors.
    return computed(() => {
        const current = state();
        switch (current.kind) {
            case 1 /* StateKind.Value */:
                return current.value;
            case 2 /* StateKind.Error */:
                throw current.error;
            case 0 /* StateKind.NoValue */:
                // This shouldn't really happen because the error is thrown on creation.
                // TODO(alxhub): use a RuntimeError when we finalize the error semantics
                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9fc2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9yeGpzLWludGVyb3Avc3JjL3RvX3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQ0wsd0JBQXdCLEVBQ3hCLDBCQUEwQixFQUMxQixRQUFRLEVBQ1IsVUFBVSxFQUNWLE1BQU0sRUFFTixNQUFNLEVBR04sYUFBYSxHQUVkLE1BQU0sZUFBZSxDQUFDO0FBNkV2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUN0QixNQUF1QyxFQUN2QyxPQUE4QztJQUU5QyxTQUFTO1FBQ1AsMEJBQTBCLENBQ3hCLFFBQVEsRUFDUiwyREFBMkQ7WUFDekQsb0dBQW9HLENBQ3ZHLENBQUM7SUFFSixNQUFNLGVBQWUsR0FBRyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUM7SUFDaEQsZUFBZSxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsSUFBSSx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxlQUFlO1FBQ2hDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDO1FBQzFELENBQUMsQ0FBQyxJQUFJLENBQUM7SUFFVCwrRkFBK0Y7SUFDL0YsMkRBQTJEO0lBQzNELElBQUksS0FBbUMsQ0FBQztJQUN4QyxJQUFJLE9BQU8sRUFBRSxXQUFXLEVBQUUsQ0FBQztRQUN6QixnREFBZ0Q7UUFDaEQsS0FBSyxHQUFHLE1BQU0sQ0FBQyxFQUFDLElBQUksMkJBQW1CLEVBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7U0FBTSxDQUFDO1FBQ04sMkZBQTJGO1FBQzNGLEtBQUssR0FBRyxNQUFNLENBQWUsRUFBQyxJQUFJLHlCQUFpQixFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsWUFBaUIsRUFBQyxDQUFDLENBQUM7SUFDM0YsQ0FBQztJQUVELDhGQUE4RjtJQUM5RiwrRkFBK0Y7SUFDL0YsMEZBQTBGO0lBQzFGLDRGQUE0RjtJQUM1Riw0REFBNEQ7SUFDNUQsaURBQWlEO0lBQ2pELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDM0IsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUMsSUFBSSx5QkFBaUIsRUFBRSxLQUFLLEVBQUMsQ0FBQztRQUMxRCxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNmLElBQUksT0FBTyxFQUFFLFlBQVksRUFBRSxDQUFDO2dCQUMxQiwyRkFBMkY7Z0JBQzNGLGdEQUFnRDtnQkFDaEQsTUFBTSxLQUFLLENBQUM7WUFDZCxDQUFDO1lBQ0QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFDLElBQUkseUJBQWlCLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztRQUM1QyxDQUFDO1FBQ0QsNkZBQTZGO1FBQzdGLGNBQWM7S0FDZixDQUFDLENBQUM7SUFFSCxJQUFJLFNBQVMsSUFBSSxPQUFPLEVBQUUsV0FBVyxJQUFJLEtBQUssRUFBRSxDQUFDLElBQUksOEJBQXNCLEVBQUUsQ0FBQztRQUM1RSxNQUFNLElBQUksYUFBYSw2REFFckIscUZBQXFGLENBQ3RGLENBQUM7SUFDSixDQUFDO0lBRUQsbUVBQW1FO0lBQ25FLFVBQVUsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUVqRCxrR0FBa0c7SUFDbEcsOEJBQThCO0lBQzlCLE9BQU8sUUFBUSxDQUFDLEdBQUcsRUFBRTtRQUNuQixNQUFNLE9BQU8sR0FBRyxLQUFLLEVBQUUsQ0FBQztRQUN4QixRQUFRLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNyQjtnQkFDRSxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDdkI7Z0JBQ0UsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDO1lBQ3RCO2dCQUNFLHdFQUF3RTtnQkFDeEUsd0VBQXdFO2dCQUN4RSxNQUFNLElBQUksYUFBYSw2REFFckIscUZBQXFGLENBQ3RGLENBQUM7UUFDTixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7XG4gIGFzc2VydEluSW5qZWN0aW9uQ29udGV4dCxcbiAgYXNzZXJ0Tm90SW5SZWFjdGl2ZUNvbnRleHQsXG4gIGNvbXB1dGVkLFxuICBEZXN0cm95UmVmLFxuICBpbmplY3QsXG4gIEluamVjdG9yLFxuICBzaWduYWwsXG4gIFNpZ25hbCxcbiAgV3JpdGFibGVTaWduYWwsXG4gIMm1UnVudGltZUVycm9yLFxuICDJtVJ1bnRpbWVFcnJvckNvZGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGV9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGB0b1NpZ25hbGAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvU2lnbmFsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJbml0aWFsIHZhbHVlIGZvciB0aGUgc2lnbmFsIHByb2R1Y2VkIGJ5IGB0b1NpZ25hbGAuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIHNpZ25hbCB1bnRpbCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gICAqL1xuICBpbml0aWFsVmFsdWU/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlcXVpcmUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBzeW5jaHJvbm91c2x5IHdoZW4gYHRvU2lnbmFsYCBzdWJzY3JpYmVzLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGB0cnVlYCwgYHRvU2lnbmFsYCB3aWxsIGFzc2VydCB0aGF0IHRoZSBvYnNlcnZhYmxlIHByb2R1Y2VzIGEgdmFsdWUgaW1tZWRpYXRlbHkgdXBvblxuICAgKiBzdWJzY3JpcHRpb24uIFNldHRpbmcgdGhpcyBvcHRpb24gcmVtb3ZlcyB0aGUgbmVlZCB0byBlaXRoZXIgZGVhbCB3aXRoIGB1bmRlZmluZWRgIGluIHRoZVxuICAgKiBzaWduYWwgdHlwZSBvciBwcm92aWRlIGFuIGBpbml0aWFsVmFsdWVgLCBhdCB0aGUgY29zdCBvZiBhIHJ1bnRpbWUgZXJyb3IgaWYgdGhpcyByZXF1aXJlbWVudCBpc1xuICAgKiBub3QgbWV0LlxuICAgKi9cbiAgcmVxdWlyZVN5bmM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBgSW5qZWN0b3JgIHdoaWNoIHdpbGwgcHJvdmlkZSB0aGUgYERlc3Ryb3lSZWZgIHVzZWQgdG8gY2xlYW4gdXAgdGhlIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgYSBgRGVzdHJveVJlZmAgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBbaW5qZWN0aW9uXG4gICAqIGNvbnRleHRdKGd1aWRlL2RpL2RlcGVuZGVuY3ktaW5qZWN0aW9uLWNvbnRleHQpLCB1bmxlc3MgbWFudWFsIGNsZWFudXAgaXMgcmVxdWVzdGVkLlxuICAgKi9cbiAgaW5qZWN0b3I/OiBJbmplY3RvcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgKHZpYSBgRGVzdHJveVJlZmApIHdoZW5cbiAgICogYHRvU2lnbmFsYCdzIGNyZWF0aW9uIGNvbnRleHQgaXMgZGVzdHJveWVkLlxuICAgKlxuICAgKiBJZiBtYW51YWwgY2xlYW51cCBpcyBlbmFibGVkLCB0aGVuIGBEZXN0cm95UmVmYCBpcyBub3QgdXNlZCwgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBwZXJzaXN0XG4gICAqIHVudGlsIHRoZSBgT2JzZXJ2YWJsZWAgaXRzZWxmIGNvbXBsZXRlcy5cbiAgICovXG4gIG1hbnVhbENsZWFudXA/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGB0b1NpZ25hbGAgc2hvdWxkIHRocm93IGVycm9ycyBmcm9tIHRoZSBPYnNlcnZhYmxlIGVycm9yIGNoYW5uZWwgYmFjayB0byBSeEpTLCB3aGVyZVxuICAgKiB0aGV5J2xsIGJlIHByb2Nlc3NlZCBhcyB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgKlxuICAgKiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyB0aGF0IHRoZSBzaWduYWwgcmV0dXJuZWQgYnkgYHRvU2lnbmFsYCB3aWxsIGtlZXAgcmV0dXJuaW5nIHRoZSBsYXN0XG4gICAqIGdvb2QgdmFsdWUgZm9yZXZlciwgYXMgT2JzZXJ2YWJsZXMgd2hpY2ggZXJyb3IgcHJvZHVjZSBubyBmdXJ0aGVyIHZhbHVlcy4gVGhpcyBvcHRpb24gZW11bGF0ZXNcbiAgICogdGhlIGJlaGF2aW9yIG9mIHRoZSBgYXN5bmNgIHBpcGUuXG4gICAqL1xuICByZWplY3RFcnJvcnM/OiBib29sZWFuO1xufVxuXG4vLyBCYXNlIGNhc2U6IG5vIG9wdGlvbnMgLT4gYHVuZGVmaW5lZGAgaW4gdGhlIHJlc3VsdCB0eXBlLlxuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQ+KHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPik6IFNpZ25hbDxUIHwgdW5kZWZpbmVkPjtcbi8vIE9wdGlvbnMgd2l0aCBgdW5kZWZpbmVkYCBpbml0aWFsIHZhbHVlIGFuZCBubyBgcmVxdWlyZWRTeW5jYCAtPiBgdW5kZWZpbmVkYC5cbmV4cG9ydCBmdW5jdGlvbiB0b1NpZ25hbDxUPihcbiAgc291cmNlOiBPYnNlcnZhYmxlPFQ+IHwgU3Vic2NyaWJhYmxlPFQ+LFxuICBvcHRpb25zOiBUb1NpZ25hbE9wdGlvbnMgJiB7aW5pdGlhbFZhbHVlPzogdW5kZWZpbmVkOyByZXF1aXJlU3luYz86IGZhbHNlfSxcbik6IFNpZ25hbDxUIHwgdW5kZWZpbmVkPjtcbi8vIE9wdGlvbnMgd2l0aCBgbnVsbGAgaW5pdGlhbCB2YWx1ZSAtPiBgbnVsbGAuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VD4oXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPixcbiAgb3B0aW9uczogVG9TaWduYWxPcHRpb25zICYge2luaXRpYWxWYWx1ZT86IG51bGw7IHJlcXVpcmVTeW5jPzogZmFsc2V9LFxuKTogU2lnbmFsPFQgfCBudWxsPjtcbi8vIE9wdGlvbnMgd2l0aCBgdW5kZWZpbmVkYCBpbml0aWFsIHZhbHVlIGFuZCBgcmVxdWlyZWRTeW5jYCAtPiBzdHJpY3QgcmVzdWx0IHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VD4oXG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPiB8IFN1YnNjcmliYWJsZTxUPixcbiAgb3B0aW9uczogVG9TaWduYWxPcHRpb25zICYge2luaXRpYWxWYWx1ZT86IHVuZGVmaW5lZDsgcmVxdWlyZVN5bmM6IHRydWV9LFxuKTogU2lnbmFsPFQ+O1xuLy8gT3B0aW9ucyB3aXRoIGEgbW9yZSBzcGVjaWZpYyBpbml0aWFsIHZhbHVlIHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdG9TaWduYWw8VCwgY29uc3QgVSBleHRlbmRzIFQ+KFxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4gfCBTdWJzY3JpYmFibGU8VD4sXG4gIG9wdGlvbnM6IFRvU2lnbmFsT3B0aW9ucyAmIHtpbml0aWFsVmFsdWU6IFU7IHJlcXVpcmVTeW5jPzogZmFsc2V9LFxuKTogU2lnbmFsPFQgfCBVPjtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gYE9ic2VydmFibGVgIGFzIGEgcmVhY3RpdmUgYFNpZ25hbGAuXG4gKlxuICogYHRvU2lnbmFsYCByZXR1cm5zIGEgYFNpZ25hbGAgd2hpY2ggcHJvdmlkZXMgc3luY2hyb25vdXMgcmVhY3RpdmUgYWNjZXNzIHRvIHZhbHVlcyBwcm9kdWNlZFxuICogYnkgdGhlIGdpdmVuIGBPYnNlcnZhYmxlYCwgYnkgc3Vic2NyaWJpbmcgdG8gdGhhdCBgT2JzZXJ2YWJsZWAuIFRoZSByZXR1cm5lZCBgU2lnbmFsYCB3aWxsIGFsd2F5c1xuICogaGF2ZSB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZW1pdHRlZCBieSB0aGUgc3Vic2NyaXB0aW9uLCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGVcbiAqIGBPYnNlcnZhYmxlYCBlcnJvcnMuXG4gKlxuICogV2l0aCBgcmVxdWlyZVN5bmNgIHNldCB0byBgdHJ1ZWAsIGB0b1NpZ25hbGAgd2lsbCBhc3NlcnQgdGhhdCB0aGUgYE9ic2VydmFibGVgIHByb2R1Y2VzIGEgdmFsdWVcbiAqIGltbWVkaWF0ZWx5IHVwb24gc3Vic2NyaXB0aW9uLiBObyBgaW5pdGlhbFZhbHVlYCBpcyBuZWVkZWQgaW4gdGhpcyBjYXNlLCBhbmQgdGhlIHJldHVybmVkIHNpZ25hbFxuICogZG9lcyBub3QgaW5jbHVkZSBhbiBgdW5kZWZpbmVkYCB0eXBlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgd2hlbiB0aGUgY3VycmVudCBbaW5qZWN0aW9uXG4gKiBjb250ZXh0XShndWlkZS9kaS9kZXBlbmRlbmN5LWluamVjdGlvbi1jb250ZXh0KSBpcyBkZXN0cm95ZWQuIEZvciBleGFtcGxlLCB3aGVuIGB0b1NpZ25hbGAgaXNcbiAqIGNhbGxlZCBkdXJpbmcgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIGNvbXBvbmVudCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGNsZWFuZWQgdXAgd2hlbiB0aGVcbiAqIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuIElmIGFuIGluamVjdGlvbiBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUsIGFuIGV4cGxpY2l0IGBJbmplY3RvcmAgY2FuIGJlXG4gKiBwYXNzZWQgaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBwZXJzaXN0IHVudGlsIHRoZSBgT2JzZXJ2YWJsZWAgaXRzZWxmIGNvbXBsZXRlcywgdGhlIGBtYW51YWxDbGVhbnVwYFxuICogb3B0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW5zdGVhZCwgd2hpY2ggZGlzYWJsZXMgdGhlIGF1dG9tYXRpYyBzdWJzY3JpcHRpb24gdGVhcmRvd24uIE5vIGluamVjdGlvblxuICogY29udGV4dCBpcyBuZWVkZWQgaW4gdGhpcyBjb25maWd1cmF0aW9uIGFzIHdlbGwuXG4gKlxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2lnbmFsPFQsIFUgPSB1bmRlZmluZWQ+KFxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4gfCBTdWJzY3JpYmFibGU8VD4sXG4gIG9wdGlvbnM/OiBUb1NpZ25hbE9wdGlvbnMgJiB7aW5pdGlhbFZhbHVlPzogVX0sXG4pOiBTaWduYWw8VCB8IFU+IHtcbiAgbmdEZXZNb2RlICYmXG4gICAgYXNzZXJ0Tm90SW5SZWFjdGl2ZUNvbnRleHQoXG4gICAgICB0b1NpZ25hbCxcbiAgICAgICdJbnZva2luZyBgdG9TaWduYWxgIGNhdXNlcyBuZXcgc3Vic2NyaXB0aW9ucyBldmVyeSB0aW1lLiAnICtcbiAgICAgICAgJ0NvbnNpZGVyIG1vdmluZyBgdG9TaWduYWxgIG91dHNpZGUgb2YgdGhlIHJlYWN0aXZlIGNvbnRleHQgYW5kIHJlYWQgdGhlIHNpZ25hbCB2YWx1ZSB3aGVyZSBuZWVkZWQuJyxcbiAgICApO1xuXG4gIGNvbnN0IHJlcXVpcmVzQ2xlYW51cCA9ICFvcHRpb25zPy5tYW51YWxDbGVhbnVwO1xuICByZXF1aXJlc0NsZWFudXAgJiYgIW9wdGlvbnM/LmluamVjdG9yICYmIGFzc2VydEluSW5qZWN0aW9uQ29udGV4dCh0b1NpZ25hbCk7XG4gIGNvbnN0IGNsZWFudXBSZWYgPSByZXF1aXJlc0NsZWFudXBcbiAgICA/IG9wdGlvbnM/LmluamVjdG9yPy5nZXQoRGVzdHJveVJlZikgPz8gaW5qZWN0KERlc3Ryb3lSZWYpXG4gICAgOiBudWxsO1xuXG4gIC8vIE5vdGU6IFQgaXMgdGhlIE9ic2VydmFibGUgdmFsdWUgdHlwZSwgYW5kIFUgaXMgdGhlIGluaXRpYWwgdmFsdWUgdHlwZS4gVGhleSBkb24ndCBoYXZlIHRvIGJlXG4gIC8vIHRoZSBzYW1lIC0gdGhlIHJldHVybmVkIHNpZ25hbCBnaXZlcyB2YWx1ZXMgb2YgdHlwZSBgVGAuXG4gIGxldCBzdGF0ZTogV3JpdGFibGVTaWduYWw8U3RhdGU8VCB8IFU+PjtcbiAgaWYgKG9wdGlvbnM/LnJlcXVpcmVTeW5jKSB7XG4gICAgLy8gSW5pdGlhbGx5IHRoZSBzaWduYWwgaXMgaW4gYSBgTm9WYWx1ZWAgc3RhdGUuXG4gICAgc3RhdGUgPSBzaWduYWwoe2tpbmQ6IFN0YXRlS2luZC5Ob1ZhbHVlfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gaW5pdGlhbCB2YWx1ZSB3YXMgcGFzc2VkLCB1c2UgaXQuIE90aGVyd2lzZSwgdXNlIGB1bmRlZmluZWRgIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgIHN0YXRlID0gc2lnbmFsPFN0YXRlPFQgfCBVPj4oe2tpbmQ6IFN0YXRlS2luZC5WYWx1ZSwgdmFsdWU6IG9wdGlvbnM/LmluaXRpYWxWYWx1ZSBhcyBVfSk7XG4gIH1cblxuICAvLyBOb3RlOiBUaGlzIGNvZGUgY2Fubm90IHJ1biBpbnNpZGUgYSByZWFjdGl2ZSBjb250ZXh0IChzZWUgYXNzZXJ0aW9uIGFib3ZlKS4gSWYgd2UnZCBzdXBwb3J0XG4gIC8vIHRoaXMsIHdlIHdvdWxkIHN1YnNjcmliZSB0byB0aGUgb2JzZXJ2YWJsZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IHJlYWN0aXZlIGNvbnRleHQsIGF2b2lkaW5nXG4gIC8vIHRoYXQgc2lkZS1lZmZlY3Qgc2lnbmFsIHJlYWRzL3dyaXRlcyBhcmUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IGNvbnN1bWVyLiBUaGUgY3VycmVudFxuICAvLyBjb25zdW1lciBvbmx5IG5lZWRzIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGBzdGF0ZWAgc2lnbmFsIGNoYW5nZXMgdGhyb3VnaCB0aGUgb2JzZXJ2YWJsZVxuICAvLyBzdWJzY3JpcHRpb24uIEFkZGl0aW9uYWwgY29udGV4dCAocmVsYXRlZCB0byBhc3luYyBwaXBlKTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzUwNTIyLlxuICBjb25zdCBzdWIgPSBzb3VyY2Uuc3Vic2NyaWJlKHtcbiAgICBuZXh0OiAodmFsdWUpID0+IHN0YXRlLnNldCh7a2luZDogU3RhdGVLaW5kLlZhbHVlLCB2YWx1ZX0pLFxuICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChvcHRpb25zPy5yZWplY3RFcnJvcnMpIHtcbiAgICAgICAgLy8gS2ljayB0aGUgZXJyb3IgYmFjayB0byBSeEpTLiBJdCB3aWxsIGJlIGNhdWdodCBhbmQgcmV0aHJvd24gaW4gYSBtYWNyb3Rhc2ssIHdoaWNoIGNhdXNlc1xuICAgICAgICAvLyB0aGUgZXJyb3IgdG8gZW5kIHVwIGFzIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbi5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBzdGF0ZS5zZXQoe2tpbmQ6IFN0YXRlS2luZC5FcnJvciwgZXJyb3J9KTtcbiAgICB9LFxuICAgIC8vIENvbXBsZXRpb24gb2YgdGhlIE9ic2VydmFibGUgaXMgbWVhbmluZ2xlc3MgdG8gdGhlIHNpZ25hbC4gU2lnbmFscyBkb24ndCBoYXZlIGEgY29uY2VwdCBvZlxuICAgIC8vIFwiY29tcGxldGVcIi5cbiAgfSk7XG5cbiAgaWYgKG5nRGV2TW9kZSAmJiBvcHRpb25zPy5yZXF1aXJlU3luYyAmJiBzdGF0ZSgpLmtpbmQgPT09IFN0YXRlS2luZC5Ob1ZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKFxuICAgICAgybVSdW50aW1lRXJyb3JDb2RlLlJFUVVJUkVfU1lOQ19XSVRIT1VUX1NZTkNfRU1JVCxcbiAgICAgICdgdG9TaWduYWwoKWAgY2FsbGVkIHdpdGggYHJlcXVpcmVTeW5jYCBidXQgYE9ic2VydmFibGVgIGRpZCBub3QgZW1pdCBzeW5jaHJvbm91c2x5LicsXG4gICAgKTtcbiAgfVxuXG4gIC8vIFVuc3Vic2NyaWJlIHdoZW4gdGhlIGN1cnJlbnQgY29udGV4dCBpcyBkZXN0cm95ZWQsIGlmIHJlcXVlc3RlZC5cbiAgY2xlYW51cFJlZj8ub25EZXN0cm95KHN1Yi51bnN1YnNjcmliZS5iaW5kKHN1YikpO1xuXG4gIC8vIFRoZSBhY3R1YWwgcmV0dXJuZWQgc2lnbmFsIGlzIGEgYGNvbXB1dGVkYCBvZiB0aGUgYFN0YXRlYCBzaWduYWwsIHdoaWNoIG1hcHMgdGhlIHZhcmlvdXMgc3RhdGVzXG4gIC8vIHRvIGVpdGhlciB2YWx1ZXMgb3IgZXJyb3JzLlxuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBzdGF0ZSgpO1xuICAgIHN3aXRjaCAoY3VycmVudC5raW5kKSB7XG4gICAgICBjYXNlIFN0YXRlS2luZC5WYWx1ZTpcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XG4gICAgICBjYXNlIFN0YXRlS2luZC5FcnJvcjpcbiAgICAgICAgdGhyb3cgY3VycmVudC5lcnJvcjtcbiAgICAgIGNhc2UgU3RhdGVLaW5kLk5vVmFsdWU6XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IHJlYWxseSBoYXBwZW4gYmVjYXVzZSB0aGUgZXJyb3IgaXMgdGhyb3duIG9uIGNyZWF0aW9uLlxuICAgICAgICAvLyBUT0RPKGFseGh1Yik6IHVzZSBhIFJ1bnRpbWVFcnJvciB3aGVuIHdlIGZpbmFsaXplIHRoZSBlcnJvciBzZW1hbnRpY3NcbiAgICAgICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKFxuICAgICAgICAgIMm1UnVudGltZUVycm9yQ29kZS5SRVFVSVJFX1NZTkNfV0lUSE9VVF9TWU5DX0VNSVQsXG4gICAgICAgICAgJ2B0b1NpZ25hbCgpYCBjYWxsZWQgd2l0aCBgcmVxdWlyZVN5bmNgIGJ1dCBgT2JzZXJ2YWJsZWAgZGlkIG5vdCBlbWl0IHN5bmNocm9ub3VzbHkuJyxcbiAgICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBlbnVtIFN0YXRlS2luZCB7XG4gIE5vVmFsdWUsXG4gIFZhbHVlLFxuICBFcnJvcixcbn1cblxuaW50ZXJmYWNlIE5vVmFsdWVTdGF0ZSB7XG4gIGtpbmQ6IFN0YXRlS2luZC5Ob1ZhbHVlO1xufVxuXG5pbnRlcmZhY2UgVmFsdWVTdGF0ZTxUPiB7XG4gIGtpbmQ6IFN0YXRlS2luZC5WYWx1ZTtcbiAgdmFsdWU6IFQ7XG59XG5cbmludGVyZmFjZSBFcnJvclN0YXRlIHtcbiAga2luZDogU3RhdGVLaW5kLkVycm9yO1xuICBlcnJvcjogdW5rbm93bjtcbn1cblxudHlwZSBTdGF0ZTxUPiA9IE5vVmFsdWVTdGF0ZSB8IFZhbHVlU3RhdGU8VD4gfCBFcnJvclN0YXRlO1xuIl19