{"version":3,"file":"ast.js","sourceRoot":"","sources":["../../../schematics/utils/ast.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport { SchematicsException, Tree } from '@angular-devkit/schematics';\nimport { addRootProvider } from '@schematics/angular/utility';\nimport { Change, InsertChange } from '@schematics/angular/utility/change';\nimport { getAppModulePath, isStandaloneApp } from '@schematics/angular/utility/ng-ast-utils';\nimport { getMainFilePath } from '@schematics/angular/utility/standalone/util';\nimport { getTypeScriptSourceFile } from '.';\n\n/**\n * Import and add module to the root module.\n * @param host {Tree} The source tree.\n * @param importedModuleName {String} The name of the imported module.\n * @param importedModulePath {String} The location of the imported module.\n * @param projectName {String} The name of the project.\n */\nexport async function addModuleImportToRootModule(\n  host: Tree,\n  importedModuleName: string,\n  importedModulePath: string,\n  projectName: string,\n) {\n  const mainPath = await getMainFilePath(host, projectName);\n  if (isStandaloneApp(host, mainPath)) {\n    addRootProvider(projectName, ({ code, external }) => {\n      return code`${external(importedModuleName, importedModulePath)}()`;\n    });\n  } else {\n    const appModulePath = getAppModulePath(host, mainPath);\n    addModuleImportToModule(host, appModulePath, importedModuleName, importedModulePath);\n  }\n}\n\n/**\n * Import and add module to specific module path.\n * @param host {Tree} The source tree.\n * @param moduleToImportIn {String} The location of the module to import in.\n * @param importedModuleName {String} The name of the imported module.\n * @param importedModulePath {String} The location of the imported module.\n */\nfunction addModuleImportToModule(\n  host: Tree,\n  moduleToImportIn: string,\n  importedModuleName: string,\n  importedModulePath: string,\n) {\n  const moduleSource = getTypeScriptSourceFile(host, moduleToImportIn);\n\n  if (!moduleSource) {\n    throw new SchematicsException(`Module not found: ${moduleToImportIn}`);\n  }\n\n  const changes = addImportToModule(moduleSource, importedModulePath, importedModuleName);\n  const recorder = host.beginUpdate(moduleToImportIn);\n\n  const inserted = insertImport(\n    moduleSource,\n    moduleToImportIn,\n    importedModuleName,\n    importedModulePath,\n  );\n\n  if (inserted && inserted instanceof InsertChange) {\n    recorder.insertLeft(inserted.pos, inserted.toAdd);\n  }\n\n  changes\n    .filter((change: Change): change is InsertChange => change instanceof InsertChange)\n    .forEach((change: InsertChange) => recorder.insertLeft(change.pos, change.toAdd));\n\n  host.commitUpdate(recorder);\n}\n\nfunction addImportToModule(\n  source: ts.SourceFile,\n  modulePath: string,\n  symbolName: string,\n): Change[] {\n  return _addSymbolToNgModuleMetadata(source, modulePath, 'imports', symbolName);\n}\n\nfunction _addSymbolToNgModuleMetadata(\n  source: ts.SourceFile,\n  ngModulePath: string,\n  metadataField: string,\n  expression: string,\n): Change[] {\n  const nodes = getDecoratorMetadata(source, 'NgModule', '@angular/core');\n  let node: any = nodes[0];\n\n  // Find the decorator declaration.\n  if (!node) {\n    return [];\n  }\n  // Get all the children property assignment of object literals.\n  const matchingProperties: ts.ObjectLiteralElement[] = (\n    node as ts.ObjectLiteralExpression\n  ).properties\n    .filter((prop): prop is ts.PropertyAssignment => prop.kind == ts.SyntaxKind.PropertyAssignment)\n    // Filter out every fields that's not \"metadataField\". Also handles string literals\n    // (but not expressions).\n    .filter((prop: ts.PropertyAssignment) => {\n      const name = prop.name;\n      switch (name.kind) {\n        case ts.SyntaxKind.Identifier:\n          return (name as ts.Identifier).getText(source) == metadataField;\n        case ts.SyntaxKind.StringLiteral:\n          return (name as ts.StringLiteral).text == metadataField;\n      }\n\n      return false;\n    });\n\n  // Get the last node of the array literal.\n  if (!matchingProperties) {\n    return [];\n  }\n  if (matchingProperties.length == 0) {\n    // We haven't found the field in the metadata declaration. Insert a new field.\n    const expr = node as ts.ObjectLiteralExpression;\n    let position: number;\n    let toInsert: string;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${expression}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${text.match(/^\\r?\\n\\s+/)[0]}${metadataField}: [${expression}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${expression}]`;\n      }\n    }\n    const newMetadataProperty = new InsertChange(ngModulePath, position, toInsert);\n    return [newMetadataProperty];\n  }\n\n  const assignment = matchingProperties[0] as ts.PropertyAssignment;\n\n  // If it's not an array, nothing we can do really.\n  if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n    return [];\n  }\n\n  const arrLiteral = assignment.initializer as ts.ArrayLiteralExpression;\n  if (arrLiteral.elements.length == 0) {\n    // Forward the property.\n    node = arrLiteral;\n  } else {\n    node = arrLiteral.elements;\n  }\n\n  if (!node) {\n    console.log('No app module found. Please add your new class to your component.');\n\n    return [];\n  }\n\n  const isArray = Array.isArray(node);\n  if (isArray) {\n    const nodeArray = node as {} as Array<ts.Node>;\n    const symbolsArray = nodeArray.map(node => node.getText());\n    if (symbolsArray.includes(expression)) {\n      return [];\n    }\n\n    node = node[node.length - 1];\n  }\n\n  let toInsert: string;\n  let position = node.getEnd();\n  if (!isArray && node.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n    // We haven't found the field in the metadata declaration. Insert a new\n    // field.\n    const expr = node as ts.ObjectLiteralExpression;\n    if (expr.properties.length == 0) {\n      position = expr.getEnd() - 1;\n      toInsert = `  ${metadataField}: [${expression}]\\n`;\n    } else {\n      node = expr.properties[expr.properties.length - 1];\n      position = node.getEnd();\n      // Get the indentation of the last element, if any.\n      const text = node.getFullText(source);\n      if (text.match('^\\r?\\r?\\n')) {\n        toInsert = `,${text.match(/^\\r?\\n\\s+/)[0]}${metadataField}: [${expression}]`;\n      } else {\n        toInsert = `, ${metadataField}: [${expression}]`;\n      }\n    }\n  } else if (!isArray && node.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n    // We found the field but it's empty. Insert it just before the `]`.\n    position--;\n    toInsert = `${expression}`;\n  } else {\n    // Get the indentation of the last element, if any.\n    const text = node.getFullText(source);\n    if (text.match(/^\\r?\\n/)) {\n      toInsert = `,${text.match(/^\\r?\\n(\\r?)\\s+/)[0]}${expression}`;\n    } else {\n      toInsert = `, ${expression}`;\n    }\n  }\n  const insert = new InsertChange(ngModulePath, position, toInsert);\n  return [insert];\n}\n\nfunction getDecoratorMetadata(\n  source: ts.SourceFile,\n  identifier: string,\n  module: string,\n): ts.Node[] {\n  const angularImports: { [name: string]: string } = findNodes(\n    source,\n    ts.SyntaxKind.ImportDeclaration,\n  )\n    .map(node => _angularImportsFromNode(node as ts.ImportDeclaration, source))\n    .reduce((acc: { [name: string]: string }, current: { [name: string]: string }) => {\n      for (const key of Object.keys(current)) {\n        acc[key] = current[key];\n      }\n\n      return acc;\n    }, {});\n\n  return getSourceNodes(source)\n    .filter(node => {\n      return (\n        node.kind == ts.SyntaxKind.Decorator &&\n        (node as ts.Decorator).expression.kind == ts.SyntaxKind.CallExpression\n      );\n    })\n    .map(node => (node as ts.Decorator).expression as ts.CallExpression)\n    .filter(expr => {\n      if (expr.expression.kind == ts.SyntaxKind.Identifier) {\n        const id = expr.expression as ts.Identifier;\n\n        return (\n          id.getFullText(source) == identifier && angularImports[id.getFullText(source)] === module\n        );\n      } else if (expr.expression.kind == ts.SyntaxKind.PropertyAccessExpression) {\n        // This covers foo.NgModule when importing * as foo.\n        const paExpr = expr.expression as ts.PropertyAccessExpression;\n        // If the left expression is not an identifier, just give up at that point.\n        if (paExpr.expression.kind !== ts.SyntaxKind.Identifier) {\n          return false;\n        }\n\n        const id = paExpr.name.text;\n        const moduleId = (paExpr.expression as ts.Identifier).getText(source);\n\n        return id === identifier && angularImports[moduleId + '.'] === module;\n      }\n\n      return false;\n    })\n    .filter(\n      expr => expr.arguments[0] && expr.arguments[0].kind == ts.SyntaxKind.ObjectLiteralExpression,\n    )\n    .map(expr => expr.arguments[0] as ts.ObjectLiteralExpression);\n}\n\nfunction getSourceNodes(sourceFile: ts.SourceFile): ts.Node[] {\n  const nodes: ts.Node[] = [sourceFile];\n  const result = [];\n\n  while (nodes.length > 0) {\n    const node = nodes.shift();\n\n    if (node) {\n      result.push(node);\n      if (node.getChildCount(sourceFile) >= 0) {\n        nodes.unshift(...node.getChildren());\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction findNodes(\n  node: ts.Node,\n  kind: ts.SyntaxKind | ts.SyntaxKind[],\n  max = Infinity,\n): ts.Node[] {\n  if (!node || max == 0) {\n    return [];\n  }\n\n  const arr: ts.Node[] = [];\n  const hasMatch = Array.isArray(kind) ? kind.includes(node.kind) : node.kind === kind;\n  if (hasMatch) {\n    arr.push(node);\n    max--;\n  }\n  if (max > 0) {\n    for (const child of node.getChildren()) {\n      findNodes(child, kind, max).forEach(node => {\n        if (max > 0) {\n          arr.push(node);\n        }\n        max--;\n      });\n\n      if (max <= 0) {\n        break;\n      }\n    }\n  }\n\n  return arr;\n}\n\nfunction _angularImportsFromNode(\n  node: ts.ImportDeclaration,\n  _sourceFile: ts.SourceFile,\n): { [name: string]: string } {\n  const ms = node.moduleSpecifier;\n  let modulePath: string;\n  switch (ms.kind) {\n    case ts.SyntaxKind.StringLiteral:\n      modulePath = (ms as ts.StringLiteral).text;\n      break;\n    default:\n      return {};\n  }\n\n  if (!modulePath.startsWith('@angular/')) {\n    return {};\n  }\n\n  if (node.importClause) {\n    if (node.importClause.name) {\n      // This is of the form `import Name from 'path'`. Ignore.\n      return {};\n    } else if (node.importClause.namedBindings) {\n      const nb = node.importClause.namedBindings;\n      if (nb.kind == ts.SyntaxKind.NamespaceImport) {\n        // This is of the form `import * as name from 'path'`. Return `name.`.\n        return {\n          [(nb as ts.NamespaceImport).name.text + '.']: modulePath,\n        };\n      } else {\n        // This is of the form `import {a,b,c} from 'path'`\n        const namedImports = nb as ts.NamedImports;\n\n        return namedImports.elements\n          .map((is: ts.ImportSpecifier) => (is.propertyName ? is.propertyName.text : is.name.text))\n          .reduce((acc: { [name: string]: string }, curr: string) => {\n            acc[curr] = modulePath;\n\n            return acc;\n          }, {});\n      }\n    }\n\n    return {};\n  } else {\n    // This is of the form `import 'path';`. Nothing to do.\n    return {};\n  }\n}\n\nexport function insertImport(\n  source: ts.SourceFile,\n  fileToEdit: string,\n  symbolName: string,\n  fileName: string,\n  isDefault = false,\n) {\n  const rootNode = source;\n  const allImports = findNodes(rootNode, ts.SyntaxKind.ImportDeclaration);\n\n  // get nodes that map to import statements from the file fileName\n  const relevantImports = allImports.filter(node => {\n    // StringLiteral of the ImportDeclaration is the import file (fileName in this case).\n    const importFiles = node\n      .getChildren()\n      .filter(child => child.kind === ts.SyntaxKind.StringLiteral)\n      .map(n => (n as ts.StringLiteral).text);\n\n    return importFiles.filter(file => file === fileName).length === 1;\n  });\n\n  if (relevantImports.length > 0) {\n    let importsAsterisk = false;\n    // imports from import file\n    const imports: ts.Node[] = [];\n    relevantImports.forEach(n => {\n      Array.prototype.push.apply(imports, findNodes(n, ts.SyntaxKind.Identifier));\n      if (findNodes(n, ts.SyntaxKind.AsteriskToken).length > 0) {\n        importsAsterisk = true;\n      }\n    });\n\n    // if imports * from fileName, don't add symbolName\n    if (importsAsterisk) {\n      return null;\n    }\n\n    const importTextNodes = imports.filter(n => (n as ts.Identifier).text === symbolName);\n\n    // insert import if it's not there\n    if (importTextNodes.length === 0) {\n      const fallbackPos =\n        findNodes(relevantImports[0], ts.SyntaxKind.CloseBraceToken)[0].getStart() ||\n        findNodes(relevantImports[0], ts.SyntaxKind.FromKeyword)[0].getStart();\n\n      return insertAfterLastOccurrence(imports, `, ${symbolName}`, fileToEdit, fallbackPos);\n    }\n\n    return null;\n  }\n\n  // no such import declaration exists\n  const useStrict = findNodes(rootNode, ts.SyntaxKind.StringLiteral).filter(\n    n => (n as ts.StringLiteral).text === 'use strict',\n  );\n  let fallbackPos = 0;\n  if (useStrict.length > 0) {\n    fallbackPos = useStrict[0].end;\n  }\n  const open = isDefault ? '' : '{ ';\n  const close = isDefault ? '' : ' }';\n  // if there are no imports or 'use strict' statement, insert import at beginning of file\n  const insertAtBeginning = allImports.length === 0 && useStrict.length === 0;\n  const separator = insertAtBeginning ? '' : ';\\n';\n  const toInsert =\n    `${separator}import ${open}${symbolName}${close}` +\n    ` from '${fileName}'${insertAtBeginning ? ';\\n' : ''}`;\n\n  return insertAfterLastOccurrence(\n    allImports,\n    toInsert,\n    fileToEdit,\n    fallbackPos,\n    ts.SyntaxKind.StringLiteral,\n  );\n}\n\nfunction insertAfterLastOccurrence(\n  nodes: ts.Node[],\n  toInsert: string,\n  file: string,\n  fallbackPos: number,\n  syntaxKind?: ts.SyntaxKind,\n): Change {\n  // sort() has a side effect, so make a copy so that we won't overwrite the parent's object.\n  let lastItem = [...nodes].sort(nodesByPosition).pop();\n  if (!lastItem) {\n    throw new Error();\n  }\n  if (syntaxKind) {\n    lastItem = findNodes(lastItem, syntaxKind).sort(nodesByPosition).pop();\n  }\n  if (!lastItem && fallbackPos == undefined) {\n    throw new Error(`tried to insert ${toInsert} as first occurrence with no fallback position`);\n  }\n  const lastItemPosition: number = lastItem ? lastItem.getEnd() : fallbackPos;\n\n  return new InsertChange(file, lastItemPosition, toInsert);\n}\n\nfunction nodesByPosition(first: ts.Node, second: ts.Node): number {\n  return first.getStart() - second.getStart();\n}\n"]}