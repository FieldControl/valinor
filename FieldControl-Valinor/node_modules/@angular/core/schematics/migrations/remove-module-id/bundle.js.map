{
  "version": 3,
  "sources": ["../../../../../../../../packages/core/schematics/migrations/remove-module-id/index.ts", "../../../../../../../../packages/core/schematics/utils/extract_metadata.ts", "../../../../../../../../packages/core/schematics/utils/typescript/decorators.ts", "../../../../../../../../packages/core/schematics/utils/typescript/imports.ts", "../../../../../../../../packages/core/schematics/utils/ng_decorators.ts", "../../../../../../../../packages/core/schematics/utils/typescript/functions.ts", "../../../../../../../../packages/core/schematics/utils/project_tsconfig_paths.ts", "../../../../../../../../packages/core/schematics/utils/typescript/compiler_host.ts", "../../../../../../../../packages/core/schematics/utils/typescript/parse_tsconfig.ts", "../../../../../../../../packages/core/schematics/utils/typescript/property_name.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\nimport {relative} from 'path';\nimport ts from 'typescript';\n\nimport {extractAngularClassMetadata} from '../../utils/extract_metadata';\nimport {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\nimport {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\nimport {getPropertyNameText} from '../../utils/typescript/property_name';\n\nexport default function(): Rule {\n  return async (tree: Tree) => {\n    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n    const basePath = process.cwd();\n    const allPaths = [...buildPaths, ...testPaths];\n\n    if (!allPaths.length) {\n      throw new SchematicsException(\n          'Could not find any tsconfig file. Cannot run the `RemoveModuleId` migration.');\n    }\n\n    for (const tsconfigPath of allPaths) {\n      runRemoveModuleIdMigration(tree, tsconfigPath, basePath);\n    }\n  };\n}\n\nfunction runRemoveModuleIdMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n  const program = createMigrationProgram(tree, tsconfigPath, basePath);\n  const typeChecker = program.getTypeChecker();\n  const sourceFiles =\n      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n\n  for (const sourceFile of sourceFiles) {\n    const nodesToRemove = collectUpdatesForFile(typeChecker, sourceFile);\n    if (nodesToRemove.length !== 0) {\n      const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n      for (const node of nodesToRemove) {\n        update.remove(node.getFullStart(), node.getFullWidth());\n      }\n      tree.commitUpdate(update);\n    }\n  }\n}\n\nfunction collectUpdatesForFile(typeChecker: ts.TypeChecker, file: ts.SourceFile): ts.Node[] {\n  const removeNodes: ts.Node[] = [];\n  const attemptMigrateClass = (node: ts.ClassDeclaration) => {\n    const metadata = extractAngularClassMetadata(typeChecker, node);\n    if (metadata === null) {\n      return;\n    }\n\n    const syntaxList = metadata.node.getChildren().find(\n        ((n): n is ts.SyntaxList => n.kind === ts.SyntaxKind.SyntaxList));\n    const tokens = syntaxList?.getChildren();\n\n    if (!tokens) {\n      return;\n    }\n\n    let removeNextComma = false;\n    for (const token of tokens) {\n      // Track the comma token if it's requested to be removed.\n      if (token.kind === ts.SyntaxKind.CommaToken) {\n        if (removeNextComma) {\n          removeNodes.push(token);\n        }\n        removeNextComma = false;\n      }\n\n      // Track the `moduleId` property assignment. Note that the AST node does not include a\n      // potential followed comma token.\n      if (ts.isPropertyAssignment(token) && getPropertyNameText(token.name) === 'moduleId') {\n        removeNodes.push(token);\n        removeNextComma = true;\n      }\n    }\n  };\n\n  ts.forEachChild(file, function visitNode(node: ts.Node) {\n    if (ts.isClassDeclaration(node)) {\n      attemptMigrateClass(node);\n    }\n    ts.forEachChild(node, visitNode);\n  });\n\n  return removeNodes;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {getAngularDecorators} from './ng_decorators';\nimport {unwrapExpression} from './typescript/functions';\n\n/** Interface describing metadata of an Angular class. */\nexport interface AngularClassMetadata {\n  type: 'component'|'directive';\n  node: ts.ObjectLiteralExpression;\n}\n\n/** Extracts `@Directive` or `@Component` metadata from the given class. */\nexport function extractAngularClassMetadata(\n    typeChecker: ts.TypeChecker, node: ts.ClassDeclaration): AngularClassMetadata|null {\n  const decorators = ts.getDecorators(node);\n\n  if (!decorators || !decorators.length) {\n    return null;\n  }\n\n  const ngDecorators = getAngularDecorators(typeChecker, decorators);\n  const componentDecorator = ngDecorators.find(dec => dec.name === 'Component');\n  const directiveDecorator = ngDecorators.find(dec => dec.name === 'Directive');\n  const decorator = componentDecorator ?? directiveDecorator;\n\n  // In case no decorator could be found on the current class, skip.\n  if (!decorator) {\n    return null;\n  }\n\n  const decoratorCall = decorator.node.expression;\n\n  // In case the decorator call is not valid, skip this class declaration.\n  if (decoratorCall.arguments.length !== 1) {\n    return null;\n  }\n\n  const metadata = unwrapExpression(decoratorCall.arguments[0]);\n\n  // Ensure that the metadata is an object literal expression.\n  if (!ts.isObjectLiteralExpression(metadata)) {\n    return null;\n  }\n\n  return {\n    type: componentDecorator ? 'component' : 'directive',\n    node: metadata,\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nimport {getImportOfIdentifier, Import} from './imports';\n\nexport function getCallDecoratorImport(\n    typeChecker: ts.TypeChecker, decorator: ts.Decorator): Import|null {\n  // Note that this does not cover the edge case where decorators are called from\n  // a namespace import: e.g. \"@core.Component()\". This is not handled by Ngtsc either.\n  if (!ts.isCallExpression(decorator.expression) ||\n      !ts.isIdentifier(decorator.expression.expression)) {\n    return null;\n  }\n\n  const identifier = decorator.expression.expression;\n  return getImportOfIdentifier(typeChecker, identifier);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\nexport type Import = {\n  name: string,\n  importModule: string,\n  node: ts.ImportDeclaration\n};\n\n/** Gets import information about the specified identifier by using the Type checker. */\nexport function getImportOfIdentifier(typeChecker: ts.TypeChecker, node: ts.Identifier): Import|\n    null {\n  const symbol = typeChecker.getSymbolAtLocation(node);\n\n  if (!symbol || symbol.declarations === undefined || !symbol.declarations.length) {\n    return null;\n  }\n\n  const decl = symbol.declarations[0];\n\n  if (!ts.isImportSpecifier(decl)) {\n    return null;\n  }\n\n  const importDecl = decl.parent.parent.parent;\n\n  if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n    return null;\n  }\n\n  return {\n    // Handles aliased imports: e.g. \"import {Component as myComp} from ...\";\n    name: decl.propertyName ? decl.propertyName.text : decl.name.text,\n    importModule: importDecl.moduleSpecifier.text,\n    node: importDecl\n  };\n}\n\n\n/**\n * Gets a top-level import specifier with a specific name that is imported from a particular module.\n * E.g. given a file that looks like:\n *\n * ```\n * import { Component, Directive } from '@angular/core';\n * import { Foo } from './foo';\n * ```\n *\n * Calling `getImportSpecifier(sourceFile, '@angular/core', 'Directive')` will yield the node\n * referring to `Directive` in the top import.\n *\n * @param sourceFile File in which to look for imports.\n * @param moduleName Name of the import's module.\n * @param specifierName Original name of the specifier to look for. Aliases will be resolved to\n *    their original name.\n */\nexport function getImportSpecifier(\n    sourceFile: ts.SourceFile, moduleName: string|RegExp,\n    specifierName: string): ts.ImportSpecifier|null {\n  return getImportSpecifiers(sourceFile, moduleName, [specifierName])[0] ?? null;\n}\n\nexport function getImportSpecifiers(\n    sourceFile: ts.SourceFile, moduleName: string|RegExp,\n    specifierNames: string[]): ts.ImportSpecifier[] {\n  const matches: ts.ImportSpecifier[] = [];\n  for (const node of sourceFile.statements) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const isMatch = typeof moduleName === 'string' ? node.moduleSpecifier.text === moduleName :\n                                                       moduleName.test(node.moduleSpecifier.text);\n      const namedBindings = node.importClause?.namedBindings;\n      if (isMatch && namedBindings && ts.isNamedImports(namedBindings)) {\n        for (const specifierName of specifierNames) {\n          const match = findImportSpecifier(namedBindings.elements, specifierName);\n          if (match) {\n            matches.push(match);\n          }\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n\n/**\n * Replaces an import inside a named imports node with a different one.\n *\n * @param node Node that contains the imports.\n * @param existingImport Import that should be replaced.\n * @param newImportName Import that should be inserted.\n */\nexport function replaceImport(\n    node: ts.NamedImports, existingImport: string, newImportName: string) {\n  const isAlreadyImported = findImportSpecifier(node.elements, newImportName);\n  if (isAlreadyImported) {\n    return node;\n  }\n\n  const existingImportNode = findImportSpecifier(node.elements, existingImport);\n  if (!existingImportNode) {\n    return node;\n  }\n\n  const importPropertyName =\n      existingImportNode.propertyName ? ts.factory.createIdentifier(newImportName) : undefined;\n  const importName = existingImportNode.propertyName ? existingImportNode.name :\n                                                       ts.factory.createIdentifier(newImportName);\n\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter(current => current !== existingImportNode),\n    // Create a new import while trying to preserve the alias of the old one.\n    ts.factory.createImportSpecifier(false, importPropertyName, importName)\n  ]);\n}\n\n/**\n * Removes a symbol from the named imports and updates a node\n * that represents a given named imports.\n *\n * @param node Node that contains the imports.\n * @param symbol Symbol that should be removed.\n * @returns An updated node (ts.NamedImports).\n */\nexport function removeSymbolFromNamedImports(node: ts.NamedImports, symbol: ts.ImportSpecifier) {\n  return ts.factory.updateNamedImports(node, [\n    ...node.elements.filter(current => current !== symbol),\n  ]);\n}\n\n/** Finds an import specifier with a particular name. */\nexport function findImportSpecifier(\n    nodes: ts.NodeArray<ts.ImportSpecifier>, specifierName: string): ts.ImportSpecifier|undefined {\n  return nodes.find(element => {\n    const {name, propertyName} = element;\n    return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\nimport {getCallDecoratorImport} from './typescript/decorators';\n\nexport type CallExpressionDecorator = ts.Decorator&{\n  expression: ts.CallExpression;\n};\n\nexport interface NgDecorator {\n  name: string;\n  moduleName: string;\n  node: CallExpressionDecorator;\n  importNode: ts.ImportDeclaration;\n}\n\n/**\n * Gets all decorators which are imported from an Angular package (e.g. \"@angular/core\")\n * from a list of decorators.\n */\nexport function getAngularDecorators(\n    typeChecker: ts.TypeChecker, decorators: ReadonlyArray<ts.Decorator>): NgDecorator[] {\n  return decorators.map(node => ({node, importData: getCallDecoratorImport(typeChecker, node)}))\n      .filter(({importData}) => importData && importData.importModule.startsWith('@angular/'))\n      .map(({node, importData}) => ({\n             node: node as CallExpressionDecorator,\n             name: importData!.name,\n             moduleName: importData!.importModule,\n             importNode: importData!.node\n           }));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n/** Checks whether a given node is a function like declaration. */\nexport function isFunctionLikeDeclaration(node: ts.Node): node is ts.FunctionLikeDeclaration {\n  return ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) ||\n      ts.isArrowFunction(node) || ts.isFunctionExpression(node) ||\n      ts.isGetAccessorDeclaration(node) || ts.isSetAccessorDeclaration(node);\n}\n\n/**\n * Unwraps a given expression TypeScript node. Expressions can be wrapped within multiple\n * parentheses or as expression. e.g. \"(((({exp}))))()\". The function should return the\n * TypeScript node referring to the inner expression. e.g \"exp\".\n */\nexport function unwrapExpression(node: ts.Expression|ts.ParenthesizedExpression): ts.Expression {\n  if (ts.isParenthesizedExpression(node) || ts.isAsExpression(node)) {\n    return unwrapExpression(node.expression);\n  } else {\n    return node;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {json, normalize, virtualFs, workspaces} from '@angular-devkit/core';\nimport {Tree} from '@angular-devkit/schematics';\n\n/**\n * Gets all tsconfig paths from a CLI project by reading the workspace configuration\n * and looking for common tsconfig locations.\n */\nexport async function getProjectTsConfigPaths(tree: Tree):\n    Promise<{buildPaths: string[]; testPaths: string[];}> {\n  // Start with some tsconfig paths that are generally used within CLI projects. Note\n  // that we are not interested in IDE-specific tsconfig files (e.g. /tsconfig.json)\n  const buildPaths = new Set<string>();\n  const testPaths = new Set<string>();\n\n  const workspace = await getWorkspace(tree);\n  for (const [, project] of workspace.projects) {\n    for (const [name, target] of project.targets) {\n      if (name !== 'build' && name !== 'test') {\n        continue;\n      }\n\n      for (const [, options] of allTargetOptions(target)) {\n        const tsConfig = options.tsConfig;\n        // Filter out tsconfig files that don't exist in the CLI project.\n        if (typeof tsConfig !== 'string' || !tree.exists(tsConfig)) {\n          continue;\n        }\n\n        if (name === 'build') {\n          buildPaths.add(normalize(tsConfig));\n        } else {\n          testPaths.add(normalize(tsConfig));\n        }\n      }\n    }\n  }\n\n  return {\n    buildPaths: [...buildPaths],\n    testPaths: [...testPaths],\n  };\n}\n\n/** Get options for all configurations for the passed builder target. */\nfunction*\n    allTargetOptions(target: workspaces.TargetDefinition):\n        Iterable<[string | undefined, Record<string, json.JsonValue|undefined>]> {\n  if (target.options) {\n    yield [undefined, target.options];\n  }\n\n  if (!target.configurations) {\n    return;\n  }\n\n  for (const [name, options] of Object.entries(target.configurations)) {\n    if (options) {\n      yield [name, options];\n    }\n  }\n}\n\nfunction createHost(tree: Tree): workspaces.WorkspaceHost {\n  return {\n    async readFile(path: string): Promise<string> {\n      const data = tree.read(path);\n      if (!data) {\n        throw new Error('File not found.');\n      }\n\n      return virtualFs.fileBufferToString(data);\n    },\n    async writeFile(path: string, data: string): Promise<void> {\n      return tree.overwrite(path, data);\n    },\n    async isDirectory(path: string): Promise<boolean> {\n      // Approximate a directory check.\n      // We don't need to consider empty directories and hence this is a good enough approach.\n      // This is also per documentation, see:\n      // https://angular.io/guide/schematics-for-libraries#get-the-project-configuration\n      return !tree.exists(path) && tree.getDir(path).subfiles.length > 0;\n    },\n    async isFile(path: string): Promise<boolean> {\n      return tree.exists(path);\n    },\n  };\n}\n\nasync function getWorkspace(tree: Tree): Promise<workspaces.WorkspaceDefinition> {\n  const host = createHost(tree);\n  const {workspace} = await workspaces.readWorkspace('/', host);\n\n  return workspace;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Tree} from '@angular-devkit/schematics';\nimport {dirname, relative, resolve} from 'path';\nimport ts from 'typescript';\n\nimport {parseTsconfigFile} from './parse_tsconfig';\n\ntype FakeReadFileFn = (fileName: string) => string|undefined;\n\n/**\n * Creates a TypeScript program instance for a TypeScript project within\n * the virtual file system tree.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n */\nexport function createMigrationProgram(\n    tree: Tree, tsconfigPath: string, basePath: string, fakeFileRead?: FakeReadFileFn,\n    additionalFiles?: string[]) {\n  const {rootNames, options, host} =\n      createProgramOptions(tree, tsconfigPath, basePath, fakeFileRead, additionalFiles);\n  return ts.createProgram(rootNames, options, host);\n}\n\n/**\n * Creates the options necessary to instantiate a TypeScript program.\n * @param tree Virtual file system tree that contains the source files.\n * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.\n * @param basePath Base path for the virtual file system tree.\n * @param fakeFileRead Optional file reader function. Can be used to overwrite files in\n *   the TypeScript program, or to add in-memory files (e.g. to add global types).\n * @param additionalFiles Additional file paths that should be added to the program.\n * @param optionOverrides Overrides of the parsed compiler options.\n */\nexport function createProgramOptions(\n    tree: Tree, tsconfigPath: string, basePath: string, fakeFileRead?: FakeReadFileFn,\n    additionalFiles?: string[], optionOverrides?: ts.CompilerOptions) {\n  // Resolve the tsconfig path to an absolute path. This is needed as TypeScript otherwise\n  // is not able to resolve root directories in the given tsconfig. More details can be found\n  // in the following issue: https://github.com/microsoft/TypeScript/issues/37731.\n  tsconfigPath = resolve(basePath, tsconfigPath);\n  const parsed = parseTsconfigFile(tsconfigPath, dirname(tsconfigPath));\n  const options = optionOverrides ? {...parsed.options, ...optionOverrides} : parsed.options;\n  const host = createMigrationCompilerHost(tree, options, basePath, fakeFileRead);\n  return {rootNames: parsed.fileNames.concat(additionalFiles || []), options, host};\n}\n\nfunction createMigrationCompilerHost(\n    tree: Tree, options: ts.CompilerOptions, basePath: string,\n    fakeRead?: FakeReadFileFn): ts.CompilerHost {\n  const host = ts.createCompilerHost(options, true);\n  const defaultReadFile = host.readFile;\n\n  // We need to overwrite the host \"readFile\" method, as we want the TypeScript\n  // program to be based on the file contents in the virtual file tree. Otherwise\n  // if we run multiple migrations we might have intersecting changes and\n  // source files.\n  host.readFile = fileName => {\n    const treeRelativePath = relative(basePath, fileName);\n    let result: string|undefined = fakeRead?.(treeRelativePath);\n\n    if (typeof result !== 'string') {\n      // If the relative path resolved to somewhere outside of the tree, fall back to\n      // TypeScript's default file reading function since the `tree` will throw an error.\n      result = treeRelativePath.startsWith('..') ? defaultReadFile.call(host, fileName) :\n                                                   tree.read(treeRelativePath)?.toString();\n    }\n\n    // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset,\n    // which breaks the CLI UpdateRecorder.\n    // See: https://github.com/angular/angular/pull/30719\n    return typeof result === 'string' ? result.replace(/^\\uFEFF/, '') : undefined;\n  };\n\n  return host;\n}\n\n/**\n * Checks whether a file can be migrate by our automated migrations.\n * @param basePath Absolute path to the project.\n * @param sourceFile File being checked.\n * @param program Program that includes the source file.\n */\nexport function canMigrateFile(\n    basePath: string, sourceFile: ts.SourceFile, program: ts.Program): boolean {\n  // We shouldn't migrate .d.ts files, files from an external library or type checking files.\n  if (sourceFile.fileName.endsWith('.ngtypecheck.ts') || sourceFile.isDeclarationFile ||\n      program.isSourceFileFromExternalLibrary(sourceFile)) {\n    return false;\n  }\n\n  // Our migrations are set up to create a `Program` from the project's tsconfig and to migrate all\n  // the files within the program. This can include files that are outside of the Angular CLI\n  // project. We can't migrate files outside of the project, because our file system interactions\n  // go through the CLI's `Tree` which assumes that all files are within the project. See:\n  // https://github.com/angular/angular-cli/blob/0b0961c9c233a825b6e4bb59ab7f0790f9b14676/packages/angular_devkit/schematics/src/tree/host-tree.ts#L131\n  return !relative(basePath, sourceFile.fileName).startsWith('..');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as path from 'path';\nimport ts from 'typescript';\n\nexport function parseTsconfigFile(tsconfigPath: string, basePath: string): ts.ParsedCommandLine {\n  const {config} = ts.readConfigFile(tsconfigPath, ts.sys.readFile);\n  const parseConfigHost = {\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n    fileExists: ts.sys.fileExists,\n    readDirectory: ts.sys.readDirectory,\n    readFile: ts.sys.readFile,\n  };\n\n  // Throw if incorrect arguments are passed to this function. Passing relative base paths\n  // results in root directories not being resolved and in later type checking runtime errors.\n  // More details can be found here: https://github.com/microsoft/TypeScript/issues/37731.\n  if (!path.isAbsolute(basePath)) {\n    throw Error('Unexpected relative base path has been specified.');\n  }\n\n  return ts.parseJsonConfigFileContent(config, parseConfigHost, basePath, {});\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport ts from 'typescript';\n\n/** Type that describes a property name with an obtainable text. */\ntype PropertyNameWithText = Exclude<ts.PropertyName, ts.ComputedPropertyName>;\n\n/**\n * Gets the text of the given property name. Returns null if the property\n * name couldn't be determined statically.\n */\nexport function getPropertyNameText(node: ts.PropertyName): string|null {\n  if (ts.isIdentifier(node) || ts.isStringLiteralLike(node)) {\n    return node.text;\n  }\n  return null;\n}\n\n/** Checks whether the given property name has a text. */\nexport function hasPropertyNameText(node: ts.PropertyName): node is PropertyNameWithText {\n  return ts.isStringLiteral(node) || ts.isNumericLiteral(node) || ts.isIdentifier(node);\n}\n"],
  "mappings": "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",
  "names": ["import_path", "import_typescript", "import_typescript", "import_typescript", "ts", "ts", "import_typescript", "ts", "ts", "path", "import_typescript", "import_typescript", "ts", "ts", "import_typescript", "ts", "ts"]
}
